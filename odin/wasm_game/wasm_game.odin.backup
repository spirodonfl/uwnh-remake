package wasm_game

import "core:fmt"
import "core:strings"

SENTRY: u32 : max(u32)
@(export)
get_sentry :: proc() -> u32 {
    return SENTRY
}
// NOTE: DO NOT USE THIS! It borks the entire memory state in WASM when you do
make_int_array :: proc($N: u32) -> (res: [N]u32) {
    for i in 0..<N {
        res[i] = SENTRY;
    }
    return res;
}

USE_JS :: #config(USE_JS, false)
when USE_JS {
    foreign import env "env"

    @(default_calling_convention="contextless")
    foreign env {
        js_console_log :: proc(ptr: rawptr, len: u32) ---
        js_output_string_buffer :: proc(ptr: rawptr, len: u32) ---
        js_output_array_buffer :: proc(ptr: rawptr, len: u32) ---
    }

    buffer: [4096]u8
    console_log :: proc(message: string, args: ..any) {
        when ODIN_DEBUG {
            // panic("Test")
        }
        if len(args) == 0 {
            js_console_log(raw_data(message), u32(len(message)))
        } else {
            formatted := fmt.bprintf(buffer[:], message, ..args)
            js_console_log(raw_data(formatted), u32(len(formatted)))
        }
    }
    to_output_string_buffer :: proc(message: string, args: ..any) {
        if len(args) == 0 {
            js_output_string_buffer(raw_data(message), u32(len(message)))
        } else {
            formatted := fmt.bprintf(buffer[:], message, ..args)
            js_output_string_buffer(raw_data(formatted), u32(len(formatted)))
        }
    }
    to_output_array_buffer :: proc(array: [OUTPUT_ARRAY_BUFFER_SIZE]u32) {
        output_array_buffer = array
        js_output_array_buffer(raw_data(output_array_buffer[:]), OUTPUT_ARRAY_BUFFER_SIZE)
    }
} else {
    buffer: [4096]u8
    console_log :: proc(message: string, args: ..any) {
        if len(args) == 0 {
            fmt.bprintln(transmute([]u8)message)
        } else {
            formatted := fmt.bprintf(buffer[:], message, ..args)
            fmt.bprintln(transmute([]u8)formatted)
        }
    }
    to_output_string_buffer :: proc(message: string, buffer_index: u32 = 0, args: ..any) {
        if len(args) == 0 {
            copy(output_string_buffer[:], message[:])
        } else {
            formatted := fmt.bprintf(buffer[:], message, ..args)
            // cannot assign value formatted of type string to [4096]u8
            copy(output_string_buffer[:], formatted[:])
        }
    }
}


//------------------------------------- I/O BUFFERS -------------------------------------//
INPUT_STRING_BUFFER_SIZE :: 4096
input_string_buffer: [INPUT_STRING_BUFFER_SIZE]u8
INPUT_ARRAY_BUFFER_SIZE :: 1024
input_array_buffer: [INPUT_ARRAY_BUFFER_SIZE]u32
input_string_buffer_length: u32
@(export)
set_input_string_buffer_length :: proc(length: u32) {
    input_string_buffer_length = length
}
@(export)
format_input_string :: proc() -> string {
    return string(input_string_buffer[:input_string_buffer_length])
}
@(export)
get_input_string_buffer_ptr :: proc() -> rawptr {
    return raw_data(input_string_buffer[:])
}
@(export)
get_input_string_buffer_len :: proc() -> u32 {
    return INPUT_STRING_BUFFER_SIZE
}
@(export)
get_input_array_buffer_ptr :: proc() -> rawptr {
    return raw_data(input_array_buffer[:])
}
@(export)
get_input_array_buffer_len :: proc() -> u32 {
    return INPUT_ARRAY_BUFFER_SIZE
}
OUTPUT_STRING_BUFFER_SIZE :: INPUT_STRING_BUFFER_SIZE
OUTPUT_ARRAY_BUFFER_SIZE :: INPUT_ARRAY_BUFFER_SIZE
OUTPUT_ARRAY_BUFFER_TYPE :: [OUTPUT_ARRAY_BUFFER_SIZE]u32
output_string_buffer: [OUTPUT_STRING_BUFFER_SIZE]u8
output_array_buffer: OUTPUT_ARRAY_BUFFER_TYPE
@(export)
get_output_string_buffer_ptr :: proc() -> rawptr {
    return raw_data(output_string_buffer[:])
}
@(export)
get_output_string_buffer_len :: proc() -> u32 {
    // Use null terminator as length
    for i := 0; i < OUTPUT_STRING_BUFFER_SIZE; i += 1 {
        if output_string_buffer[i] == 0 {
            return u32(i)
        }
    }
    return OUTPUT_STRING_BUFFER_SIZE
}
@(export)
get_output_array_buffer_ptr :: proc() -> rawptr {
    return raw_data(output_array_buffer[:])
}
@(export)
get_output_array_buffer_len :: proc() -> u32 {
    return OUTPUT_ARRAY_BUFFER_SIZE
}
write_to_output_buffer :: proc(str: string) {
    for i := 0; i < OUTPUT_STRING_BUFFER_SIZE; i += 1 {
        output_string_buffer[i] = 0
    }
    copy(output_string_buffer[:], str[:])
}
format_string :: proc(str: string, args: ..any) -> string {
    format_buffer: [4096]u8
    formatted := fmt.bprintf(format_buffer[:], str, ..args)
    return string(formatted[:])
}


//------------------------------------- RNG -------------------------------------//
@(export)
get_random_number :: proc(min: u32, max: u32) -> u32 {
    rng := init_random(tick_counter)

    adjusted_max := max
    if min == max {
        adjusted_max = 100
    }
    random_value := next_random(&rng, min, adjusted_max)

    return random_value
}
tick_counter: u32
Random_Generator :: struct {
    state: u32,
}
init_random :: proc(seed: u32) -> Random_Generator {
    return Random_Generator{state = seed}
}
next_random :: proc(using gen: ^Random_Generator, min_value: u32, max_value: u32) -> u32 {
    // LCG constants
    a: u32 = 1664525
    c: u32 = 1013904223
    
    // Generate next value
    state = (a * state + c) % 0xFFFFFFFF
    
    // Scale to desired range
    range := max_value - min_value + 1
    result := min_value + u32(state % u32(range))
    return result
}
increment_tick_counter :: proc(tick: ^u32) {
    if tick^ == max(u32) {
        // Reset to 1 instead of 0 to avoid using 0 as a seed
        tick^ = 1
    } else {
        tick^ += 1
    }
}


//------------------------------------- DISTANCES -------------------------------------//
@(export)
is_coordinate_in_range_of_coordinate :: proc(a_x: u32, a_y: u32, b_x: u32, b_y: u32, range: u32) -> bool {
    return distance_between_coordinates(a_x, a_y, b_x, b_y, range) <= range
}
@(export)
distance_between_coordinates :: proc(a_x: u32, a_y: u32, b_x: u32, b_y: u32, range: u32) -> u32 {
    dx := abs(b_x - a_x)
    dy := abs(b_y - a_y)
    manhattan_distance := dx + dy
    return manhattan_distance
}


//------------------------------------- STRINGS -------------------------------------//
StringStruct :: struct {
    text: string,
    machine_name: string,
}
MAX_STRING_RESOURCES: u32 : 1000
MAX_STRING_FREE_IDS: u32 : 100
Strings_Pool: Resource_Pool(StringStruct, MAX_STRING_RESOURCES, MAX_STRING_FREE_IDS)

ran_string :: proc(text: string, machine_name: string) -> u32 {
    return resource_add_new(&Strings_Pool, StringStruct{
        text = text,
        machine_name = machine_name
    })
}

@(export)
get_string_text_ptr :: proc(id: u32) -> rawptr {
    if id == SENTRY {
        console_log("Tried to get string text with SENTRY index")
        return nil
    }
    return raw_data(Strings_Pool.data[id].text[:])
}
@(export)
get_string_text_len :: proc(id: u32) -> u32 {
    if id == SENTRY {
        console_log("Tried to get string text length with SENTRY index")
        return SENTRY
    }
    return u32(len(Strings_Pool.data[id].text))
}
@(export)
get_string_machine_name_ptr :: proc(id: u32) -> rawptr {
    if id == SENTRY {
        console_log("Tried to get string machine name with SENTRY index")
        return nil
    }
    return raw_data(Strings_Pool.data[id].machine_name[:])
}
@(export)
get_string_machine_name_len :: proc(id: u32) -> u32 {
    if id == SENTRY {
        console_log("Tried to get string machine name length with SENTRY index")
        return SENTRY
    }
    return u32(len(Strings_Pool.data[id].machine_name))
}

// string_predicate := proc(s: StringStruct) -> bool { return s.text == "A text!" }
// Usage: string_id := resource_find(String_Pool, string_predicate)

@(export)
find_string_id_by_machine_name_from_input :: proc() -> u32 {
    return find_string_id_by_machine_name(format_input_string())
}
fsibmnfi :: proc() -> u32 {
    return find_string_id_by_machine_name_from_input()
}
find_string_id_by_machine_name :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_STRING_RESOURCES; i += 1 {
        if Strings_Pool.data[i].machine_name == text {
            return i
        }
    }
    console_log("Could not find string with machine name %s", text)
    return SENTRY
}
fsibmn :: proc(text: string) -> u32 {
    return find_string_id_by_machine_name(text)
}
find_string_id_by_text :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_STRING_RESOURCES; i += 1 {
        if Strings_Pool.data[i].text == text {
            return i
        }
    }
    return SENTRY
}
fsibt :: proc(text: string) -> u32 {
    return find_string_id_by_text(text)
}
find_string_ref_by_machine_name :: proc(text: string) -> ^StringStruct {
    for i: u32 = 0; i < MAX_STRING_RESOURCES; i += 1 {
        if Strings_Pool.data[i].machine_name == text {
            return &Strings_Pool.data[i]
        }
    }
    return nil
}
fsrbmn :: proc(text: string) -> ^StringStruct {
    return find_string_ref_by_machine_name(text)
}
find_string_ref_by_text :: proc(text: string) -> ^StringStruct {
    for i: u32 = 0; i < MAX_STRING_RESOURCES; i += 1 {
        if Strings_Pool.data[i].text == text {
            return &Strings_Pool.data[i]
        }
    }
    return nil
}
fsrbt :: proc(text: string) -> ^StringStruct {
    return find_string_ref_by_text(text)
}
get_string_machine_name_by_id :: proc(index: u32) -> string {
    return Strings_Pool.data[index].machine_name
}
gsmnb_id :: proc(index: u32) -> string {
    return get_string_machine_name_by_id(index)
}
get_string_text_by_id :: proc(index: u32) -> string {
    if index == SENTRY {
        console_log("Tried to get string text with SENTRY index")
        return ""
    }
    return Strings_Pool.data[index].text
}
gstb_id :: proc(index: u32) -> string {
    return get_string_text_by_id(index)
}
get_string_text_by_machine_name :: proc(text: string) -> string {
    string_id := find_string_id_by_machine_name(text)
    if string_id == SENTRY {
        return ""
    }
    return Strings_Pool.data[string_id].text
}
gstbmn :: proc(text: string) -> string {
    return get_string_text_by_machine_name(text)
}


//------------------------------------- SHIPS -------------------------------------//
BaseShipStruct :: struct {
    // Reference to string ID
    name_id: u32,
    // Reference to material
    top_material_id: u32,
    base_price: u32,
    max_capacity: u32,
    base_tacking: u32, // handling
    base_power: u32, // to move forward
    base_speed: u32,
}
MAX_BASE_SHIPS: u32 : 100
MAX_BASE_SHIPS_FREE_IDS: u32 : 100
Base_Ships_Pool: Resource_Pool(BaseShipStruct, MAX_BASE_SHIPS, MAX_BASE_SHIPS_FREE_IDS)

find_base_ship_id_by_machine_name :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_BASE_SHIPS; i += 1 {
        base_ship := &Base_Ships_Pool.data[i]
        if base_ship.name_id == SENTRY {
            continue
        }
        name := &Strings_Pool.data[base_ship.name_id]
        if name.machine_name == text {
            return i
        }
    }
    return SENTRY
}

free_base_ship :: proc(index: u32) {
    item := &Base_Ships_Pool.data[index]

    free_resource(&Base_Ships_Pool, index)
    item.name_id = SENTRY
    item.top_material_id = SENTRY
    item.base_price = 0
    item.max_capacity = 0
    item.base_tacking = 0
    item.base_power = 0
    item.base_speed = 0
}

ShipStruct :: struct {
    name_id: u32,
    custom_name: string,
    base_ship_id: u32,
    price: u32,
    material_id: u32,
    capacity: u32,
    tacking: u32,
    power: u32,
    speed: u32,
    captain_id: u32,
    figurehead_id: u32,
}
MAX_SHIPS: u32 : 100
MAX_SHIPS_FREE_IDS: u32 : 10
Ships_Pool: Resource_Pool(ShipStruct, MAX_SHIPS, MAX_SHIPS_FREE_IDS)

find_ship_id_by_custom_name :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_SHIPS; i += 1 {
        ship := &Ships_Pool.data[i]
        if ship.custom_name == "" {
            continue
        }
        if ship.custom_name == text {
            return i
        }
    }
    return SENTRY
}

get_total_ships_by_captain_id :: proc(captain_id: u32) -> u32 {
    total_ships: u32 = 0
    for i: u32 = 0; i < MAX_SHIPS; i += 1 {
        ship := &Ships_Pool.data[i]
        if ship.captain_id == captain_id {
            total_ships += 1
        }
    }
    return total_ships
}

free_ship :: proc(index: u32) {
    item := &Ships_Pool.data[index]

    free_resource(&Ships_Pool, index)
    item.name_id = SENTRY
    item.custom_name = ""
    item.base_ship_id = SENTRY
    item.price = SENTRY
    item.material_id = SENTRY
    item.capacity = SENTRY
    item.tacking = SENTRY
    item.power = SENTRY
    item.speed = SENTRY
    item.captain_id = SENTRY
    item.figurehead_id = SENTRY
}

// ship_predicate := proc(s: ShipStruct) -> bool { return ship.capacity > 10 }
// Usage: ship_id := resource_find(Ships_Pool, ship_predicate)

ShipMaterialStruct :: struct {
    name_id: u32,
    base_price: u32,
    mod_power: u32,
    mod_capacity: u32,
    mod_tacking: u32,
    mod_speed: u32,
}
MAX_SHIP_MATERIALS: u32 : 100
MAX_SHIP_MATERIALS_FREE_IDS: u32 : 10
Ship_Materials_Pool: Resource_Pool(ShipMaterialStruct, MAX_SHIP_MATERIALS, MAX_SHIP_MATERIALS_FREE_IDS)

free_ship_material :: proc(index: u32) {
    item := &Ship_Materials_Pool.data[index]

    free_resource(&Ship_Materials_Pool, index)
    item.name_id = SENTRY
    item.base_price = 0
    item.mod_power = 0
    item.mod_capacity = 0
    item.mod_tacking = 0
    item.mod_speed = 0
}


//------------------------------------- GOODS -------------------------------------//
GoodStruct :: struct {
    name_id: u32,
    base_price: u32,
}
MAX_GOODS: u32 : 100
MAX_GOODS_FREE_IDS: u32 : 10
Goods_Pool: Resource_Pool(GoodStruct, MAX_GOODS, MAX_GOODS_FREE_IDS)

free_good :: proc(index: u32) {
    item := &Goods_Pool.data[index]

    free_resource(&Goods_Pool, index)
    item.name_id = SENTRY
    item.base_price = 0
}


//------------------------------------- WEAPONS -------------------------------------//
WeaponStruct :: struct {
    name_id: u32,
    base_price: u32,
    power: u32,
}
MAX_WEAPONS: u32 : 100
MAX_WEAPONS_FREE_IDS: u32 : 10
Weapons_Pool: Resource_Pool(WeaponStruct, MAX_WEAPONS, MAX_WEAPONS_FREE_IDS)

free_weapon :: proc(index: u32) {
    item := &Weapons_Pool.data[index]

    free_resource(&Weapons_Pool, index)
    item.name_id = SENTRY
    item.base_price = 0
    item.power = 0
}


//------------------------------------- ARMORS -------------------------------------//
ArmorStruct :: struct {
    name_id: u32,
    base_price: u32,
    defense: u32,
}
MAX_ARMORS: u32 : 100
MAX_ARMORS_FREE_IDS: u32 : 10
Armors_Pool: Resource_Pool(ArmorStruct, MAX_ARMORS, MAX_ARMORS_FREE_IDS)

free_armor :: proc(index: u32) {
    item := &Armors_Pool.data[index]

    free_resource(&Armors_Pool, index)
    item.name_id = SENTRY
    item.base_price = 0
    item.defense = 0
}


//------------------------------------- GENERAL ITEMS -------------------------------------//
GeneralItemStruct :: struct {
    name_id: u32,
    base_price: u32,
}
MAX_GENERAL_ITEMS: u32 : 100
MAX_GENERAL_ITEMS_FREE_IDS: u32 : 10
General_Items_Pool: Resource_Pool(GeneralItemStruct, MAX_GENERAL_ITEMS, MAX_GENERAL_ITEMS_FREE_IDS)

free_general_item :: proc(index: u32) {
    item := &General_Items_Pool.data[index]

    free_resource(&General_Items_Pool, index)
    item.name_id = SENTRY
    item.base_price = 0
}


//------------------------------------- SCENES -------------------------------------//
current_scene: u32
trigger_scene :: proc(scene: u32) {
    console_log("Handling scene %d %s", scene, gsmnb_id(scene))
    if current_scene != SENTRY {
        console_log("Serious error. Tried to trigger a scene while we were already in one")
        return
    }
    found: bool = false
    switch gsmnb_id(scene) {
        case "scene_digi_tal_bank":
            current_scene = find_scene_by_name_id(scene)
            found = true
        case "scene_player_menu":
            current_scene = find_scene_by_name_id(scene)
            found = true
        case "scene_general_shop":
            current_scene = find_scene_by_name_id(scene)
            found = true
        case "scene_blackjack":
            current_scene = find_scene_by_name_id(scene)
            Finite_State_Machines_Pool.data[current_scene].trigger()
            console_log("Scene blackjack found: %d", current_scene)
            found = true
    }
    if !found {
        console_log("Could not find scene %d", scene)
    } else {
        should_redraw_everything()
    }
}


//------------------------------------- NPCs -------------------------------------//
NPCTypes :: enum u32 {
    Empty,
    Human,
    Animal,
    Other,
}
NPCStruct :: struct {
    name_id: u32,
    type: u32,
}
MAX_NPCS: u32 : 100
MAX_NPCS_FREE_IDS: u32 : 10
NPCS_Pool: Resource_Pool(NPCStruct, MAX_NPCS, MAX_NPCS_FREE_IDS)
free_npc :: proc(index: u32) {
    item := &NPCS_Pool.data[index]

    item.name_id = 0
    item.type = 0
    free_resource(&NPCS_Pool, index)
}


//------------------------------------- WORLD NPCS -------------------------------------//
WorldNPCStruct :: struct {
    npc_id: u32,
    captain_id: u32,
    position_x: u32,
    position_y: u32,
    // References Direction enum
    direction: u32,
    is_interactable: bool,
    is_captain: bool,
    interaction_scene: u32,
}
MAX_WORLD_NPCS: u32 : 100
MAX_WORLD_NPCS_FREE_IDS: u32 : 10
World_NPCS_Pool: Resource_Pool(WorldNPCStruct, MAX_WORLD_NPCS, MAX_WORLD_NPCS_FREE_IDS)
free_all_world_npcs :: proc() {
    for i: u32 = 0; i < MAX_WORLD_NPCS; i += 1 {
        free_world_npc(i)
    }
}
free_world_npc :: proc(index: u32) {
    item := &World_NPCS_Pool.data[index]

    free_resource(&World_NPCS_Pool, index)
    item.npc_id = SENTRY
    item.position_x = SENTRY
    item.position_y = SENTRY
    item.direction = SENTRY
    item.is_interactable = false
    item.interaction_scene = SENTRY
}


//------------------------------------- GLOBAL CAPTAINS -------------------------------------//
CaptainStruct :: struct {
    npc_id: u32,
    world_npc_id: u32,
    in_world: bool,
    // Position in the earth
    global_position_x: u32,
    global_position_y: u32,
    // Reference to port map
    in_port: u32,
    // Reference to land map
    on_land: u32,
    // Reference to ocean map
    in_ocean: u32,
    sailing: bool,
    skills_id: u32,
    stats_id: u32,
    inventory_id: u32,

    // Player ID (0 or higher, so you can have multiple players as captains down the road)
    player: u32,
    gold: u32,

    fleet_id: u32,

    equipped_weapon_id: u32,
    equipped_armor_id: u32,
}
MAX_CAPTAINS: u32 : 100
MAX_CAPTAINS_FREE_IDS: u32 : 10
Captains_Pool: Resource_Pool(CaptainStruct, MAX_CAPTAINS, MAX_CAPTAINS_FREE_IDS)
free_captain :: proc(index: u32) {
    item := &Captains_Pool.data[index]

    // TODO: Clear / free stats ?
    // TODO: Clear / free skills ?
    // TODO: Clear / free fleet ?

    item.npc_id = SENTRY
    item.global_position_x = SENTRY
    item.global_position_y = SENTRY
    item.in_port = SENTRY
    item.on_land = SENTRY
    item.in_ocean = SENTRY
    item.sailing = false
    item.skills_id = SENTRY
    item.stats_id = SENTRY
    item.inventory_id = SENTRY
    item.player = SENTRY
    item.gold = SENTRY
    item.fleet_id = SENTRY
    item.equipped_weapon_id = SENTRY
    item.equipped_armor_id = SENTRY
    free_resource(&Captains_Pool, index)
}


//------------------------------------- WORLDS -------------------------------------//
WorldStruct :: struct {
    name_id: u32,
    width: u32,
    height: u32,
    total_npcs: u32,
    total_captains: u32,
    total_layers: u32,
}
current_world: ^WorldStruct
MAX_WORLDS: u32 : 100
MAX_WORLDS_FREE_IDS: u32 : 10
Worlds_Pool: Resource_Pool(WorldStruct, MAX_WORLDS, MAX_WORLDS_FREE_IDS)

MAX_WORLD_LAYERS: u32 : 20
MAX_WORLD_WIDTH: u32 : 200
MAX_WORLD_HEIGHT: u32 : 200
MAX_WORLD_LENGTH: u32 : MAX_WORLD_WIDTH * MAX_WORLD_HEIGHT
WORLD_LAYER_DATA_LENGTH: u32 : MAX_WORLD_LENGTH * MAX_WORLD_LAYERS
WORLD_LAYER_DATA: [WORLD_LAYER_DATA_LENGTH]u32
WORLD_LAYER_ITERATOR: u32 = 0
CURRENT_LAYER_DATA: [MAX_WORLD_LENGTH]u32
@(export)
get_world_layer_data :: proc(index: u32) -> u32 {
    return WORLD_LAYER_DATA[index]
}
@(export)
set_world_layer_data :: proc(index: u32, value: u32) {
    WORLD_LAYER_DATA[index] = value
}
@(export)
clear_world_layer_data :: proc() {
    for i: u32 = 0; i < WORLD_LAYER_DATA_LENGTH; i += 1 {
        WORLD_LAYER_DATA[i] = SENTRY
    }
    WORLD_LAYER_ITERATOR = 0
}

free_world :: proc(index: u32) {
    item := &Worlds_Pool.data[index]

    current_world = nil
    // TODO: Free all the layers too
    clear_world_layer_data()

    item.name_id = SENTRY
    item.width = SENTRY
    item.height = SENTRY
    item.total_npcs = SENTRY
    item.total_captains = SENTRY
    item.total_layers = SENTRY
    free_resource(&Worlds_Pool, index)
}

@(export)
get_current_world_total_layers :: proc() -> u32 {
    return current_world.total_layers
}


//------------------------------------- LAYERS -------------------------------------//
LayerType :: enum u32 {
    Matches_World_Size,
    Has_Specific_Size,
    Has_Specific_Coordinates,
    Is_Same_Value,
    Has_Function,
}
LayerStruct :: struct {
    name_id: u32,
    start: u32,
    length: u32,
    width: u32,
    height: u32,
    type: u32,
    same_value: u32,
    is_block: bool,

    // TODO: Potentially sort layers by this order?
    order: u32,
    // For layers of a specific size (smaller than world)
    offset_x: u32,
    offset_y: u32,
}
MAX_LAYERS: u32 : 100
MAX_LAYERS_FREE_IDS: u32 : 10
Layers_Pool: Resource_Pool(LayerStruct, MAX_LAYERS, MAX_LAYERS_FREE_IDS)

free_layer :: proc(index: u32) {
    item := &Layers_Pool.data[index]

    item.name_id = SENTRY
    item.length = SENTRY
    item.type = SENTRY
    item.same_value = SENTRY
    item.is_block = false
    item.order = SENTRY
    item.offset_x = SENTRY
    item.offset_y = SENTRY
    free_resource(&Layers_Pool, index)
}

// TODO: This
free_all_layers :: proc() {
    // TODO: Iterate over layers and free_layer them all
}

@(export)
layer_get_value :: proc(layer_index: u32 = 0, x: u32 = 0, y: u32 = 0) -> u32 {
    layer := &Layers_Pool.data[layer_index]
    if layer.same_value != SENTRY {
        return layer.same_value
    }
    index := (y * current_world.width) + x
    // console_log("%d %d %d", layer.start, index, WORLD_LAYER_DATA[layer.start + index])
    return WORLD_LAYER_DATA[layer.start + index]
}

append_world_layer_data :: proc() {
    // console_log("Starting world layer iterator: %d", WORLD_LAYER_ITERATOR)
    for i: u32 = 0; i < MAX_WORLD_LENGTH; i += 1 {
        WORLD_LAYER_DATA[WORLD_LAYER_ITERATOR + i] = CURRENT_LAYER_DATA[i]
    }
    // This ensures that WORLD_LAYER_ITERATOR is incremented by MAX_WORLD_LENGTH after copying the data, preventing any unintended offsets.
    WORLD_LAYER_ITERATOR += MAX_WORLD_LENGTH
    // console_log("Ending world layer iterator: %d", WORLD_LAYER_ITERATOR)
}
@(export)
clear_layer_data :: proc() {
    for i: u32 = 0; i < MAX_WORLD_LENGTH; i += 1 {
        CURRENT_LAYER_DATA[i] = SENTRY
    }
}
@(export)
set_layer_data :: proc(x: u32 = 0, y: u32 = 0, value: u32 = 0) {
    index := y * current_world.width + x
    console_log("Setting layer data at index %d (x: %d, y: %d, width: %d)", index, x, y, current_world.width)
    CURRENT_LAYER_DATA[index] = value
}
@(export)
set_generated_layer_data :: proc(layer_index: u32, x: u32 = 0, y: u32 = 0, value: u32 = 0) {
    direct_layer := &Layers_Pool.data[layer_index]
    world_data := WORLD_LAYER_DATA[direct_layer.start:(direct_layer.start+direct_layer.length)]
    index := y * current_world.width + x
    world_data[index] = value
}
@(export)
get_generated_layer_data :: proc(layer_index: u32, x: u32 = 0, y: u32 = 0) -> u32 {
    direct_layer := &Layers_Pool.data[layer_index]
    world_data := WORLD_LAYER_DATA[direct_layer.start:(direct_layer.start+direct_layer.length)]
    index := y * current_world.width + x
    return world_data[index]
}

@(export)
find_layer_id_by_string_id :: proc(string_id: u32) -> u32 {
    for i: u32 = 0; i < MAX_WORLD_LAYERS; i += 1 {
        if Layers_Pool.data[i].name_id == string_id {
            return i
        }
    }
    return SENTRY
}

@(export)
generate_world :: proc(world_name: string) {
    switch world_name {
        // athens port world
        case "athens":
            current_game_mode = GameMode.In_Port
            world_id := resource_find(&Worlds_Pool, proc(w: WorldStruct) -> bool {
                string_id := find_string_id_by_machine_name("athens")
                return w.name_id == string_id
            })
            current_world = &Worlds_Pool.data[world_id]

            clear_layer_data()

            clear_world_layer_data()

            resource_add_new(
                &Layers_Pool,
                LayerStruct{
                    name_id = find_string_id_by_machine_name("bg_layer"),
                    length = MAX_WORLD_LENGTH,
                    start = WORLD_LAYER_ITERATOR,
                    width = current_world.width,
                    height = current_world.height,
                    type = u32(LayerType.Matches_World_Size),
                    same_value = 1,
                    is_block = false,
                })
            current_world.total_layers = 1

            resource_add_new(
                &Layers_Pool,
                LayerStruct{
                    name_id = find_string_id_by_machine_name("npc_layer"),
                    length = MAX_WORLD_LENGTH,
                    start = WORLD_LAYER_ITERATOR,
                    width = current_world.width,
                    height = current_world.height,
                    type = u32(LayerType.Matches_World_Size),
                    same_value = SENTRY,
                    is_block = false,
                })
            current_world.total_layers += 1

            resource_add_new(
                &Layers_Pool,
                LayerStruct{
                    name_id = find_string_id_by_machine_name("block_layer"),
                    length = MAX_WORLD_LENGTH,
                    start = WORLD_LAYER_ITERATOR,
                    width = current_world.width,
                    height = current_world.height,
                    type = u32(LayerType.Matches_World_Size),
                    same_value = SENTRY,
                    is_block = false,
                })
            clear_layer_data()
            set_layer_data(0, 1, 1)
            append_world_layer_data()
            current_world.total_layers += 1

            resource_add_new(
                &Layers_Pool,
                LayerStruct{
                    name_id = find_string_id_by_machine_name("layer_one"),
                    length = MAX_WORLD_LENGTH,
                    start = WORLD_LAYER_ITERATOR,
                    width = current_world.width,
                    height = current_world.height,
                    type = u32(LayerType.Matches_World_Size),
                    same_value = SENTRY,
                    is_block = false,
                })
            // NOTE: MUST put layer data AFTER resource insertion so WORLD_LAYER_ITERATOR is not an "off by X" indices
            clear_layer_data()
            set_layer_data(4, 3, 33)
            append_world_layer_data()
            current_world.total_layers += 1

            npc_id := Captains_Pool.data[players[0]].npc_id
            world_npc_id := resource_add_new(
                &World_NPCS_Pool,
                WorldNPCStruct{
                    npc_id = npc_id,
                    captain_id = players[0],
                    position_x = 0,
                    position_y = 0,
                    direction = u32(Direction.Down),
                    is_interactable = true,
                    interaction_scene = SENTRY,
                    is_captain = true,
                })
            captain := &Captains_Pool.data[players[0]]
            captain.in_world = true
            captain.world_npc_id = world_npc_id

            npc_id = find_x_id_by_machine_name(MAX_NPCS, &NPCS_Pool, "bank_teller")
            resource_add_new(
                &World_NPCS_Pool,
                WorldNPCStruct{
                    npc_id = npc_id,
                    captain_id = SENTRY,
                    position_x = 3,
                    position_y = 3,
                    direction = u32(Direction.Down),
                    is_interactable = true,
                    interaction_scene = fsibmn("scene_digi_tal_bank"),
                    is_captain = false,
                })

            npc_id = find_x_id_by_machine_name(MAX_NPCS, &NPCS_Pool, "general_shop_owner")
            resource_add_new(
                &World_NPCS_Pool,
                WorldNPCStruct{
                    npc_id = npc_id,
                    captain_id = SENTRY,
                    position_x = 4,
                    position_y = 4,
                    direction = u32(Direction.Down),
                    is_interactable = true,
                    interaction_scene = fsibmn("scene_general_shop"),
                    is_captain = false,
                })

            npc_id = find_x_id_by_machine_name(MAX_NPCS, &NPCS_Pool, "blackjack_player")
            resource_add_new(
                &World_NPCS_Pool,
                WorldNPCStruct{
                    npc_id = npc_id,
                    captain_id = SENTRY,
                    position_x = 5,
                    position_y = 5,
                    direction = u32(Direction.Down),
                    is_interactable = true,
                    interaction_scene = fsibmn("scene_blackjack"),
                    is_captain = false,
                })

            general_shop_inventory_id := resource_add_new(&Inventories_Pool, InventoryStruct{
                name_id = fsibmn("general_shop_inventory"),
                total_items = 0,
            })
            item_id := find_x_id_by_machine_name(MAX_GENERAL_ITEMS, &General_Items_Pool, "telescope")
            inventory_item_id := resource_add_new(&Inventory_Items_Pool, InventoryItemStruct{
                name_id = fsibmn("telescope"),
                number_held = 1,
                adjusted_price = 300,
                type_id = u32(InventoryType.GeneralItem),
                type_name_id = fsibmn("general_item"),
                type_reference = item_id,
                inventory_id = general_shop_inventory_id,
            })
            Inventories_Pool.data[general_shop_inventory_id].total_items += 1
            item_id = find_x_id_by_machine_name(MAX_GENERAL_ITEMS, &General_Items_Pool, "quadrant")
            inventory_item_id = resource_add_new(&Inventory_Items_Pool, InventoryItemStruct{
                name_id = fsibmn("quadrant"),
                number_held = 1,
                adjusted_price = 400,
                type_id = u32(InventoryType.GeneralItem),
                type_name_id = fsibmn("general_item"),
                type_reference = item_id,
                inventory_id = general_shop_inventory_id,
            })
            Inventories_Pool.data[general_shop_inventory_id].total_items += 1
            item_id = find_x_id_by_machine_name(MAX_GENERAL_ITEMS, &General_Items_Pool, "theodolite")
            inventory_item_id = resource_add_new(&Inventory_Items_Pool, InventoryItemStruct{
                name_id = fsibmn("theodolite"),
                number_held = 1,
                adjusted_price = 400,
                type_id = u32(InventoryType.GeneralItem),
                type_name_id = fsibmn("general_item"),
                type_reference = item_id,
                inventory_id = general_shop_inventory_id,
            })
            Inventories_Pool.data[general_shop_inventory_id].total_items += 1
            item_id = find_x_id_by_machine_name(MAX_GENERAL_ITEMS, &General_Items_Pool, "sextant")
            inventory_item_id = resource_add_new(&Inventory_Items_Pool, InventoryItemStruct{
                name_id = fsibmn("sextant"),
                number_held = 1,
                adjusted_price = 400,
                type_id = u32(InventoryType.GeneralItem),
                type_name_id = fsibmn("general_item"),
                type_reference = item_id,
                inventory_id = general_shop_inventory_id,
            })
            Inventories_Pool.data[general_shop_inventory_id].total_items += 1

            should_redraw_everything()
        case:
            console_log("Could not find world by name %s", world_name)
    }
}


//------------------------------------- BANK -------------------------------------//
BANK_MAX_DEPOSIT: u32 : 999999999
BANK_MAX_LOAN: u32 = 10000
BankStruct :: struct {
    deposit: u32,
    loan: u32,
    deposit_original_amount: u32,
    deposit_interest_rate: u32,
    deposit_interest: u32,
    loan_original_amount: u32,
    loan_interest_rate: u32,
    loan_interest: u32,
}
global_digi_tal_bank: BankStruct
bank_default_values :: proc() {
    global_digi_tal_bank.deposit = SENTRY
    global_digi_tal_bank.loan = SENTRY
    global_digi_tal_bank.deposit_original_amount = SENTRY
    global_digi_tal_bank.deposit_interest = SENTRY
    global_digi_tal_bank.loan_original_amount = SENTRY
    global_digi_tal_bank.loan_interest = SENTRY
    global_digi_tal_bank.deposit_interest_rate = 7
    global_digi_tal_bank.loan_interest_rate = 23
}


//------------------------------------- MOVEMENTS -------------------------------------//
move_player_left :: proc(override_block: bool = false) {
    player := get_player_in_world()
    if override_block {
        player.position_x -= 1
    } else {
        if (player.position_x > 0) {
            intended_position_x := player.position_x - 1
            intended_position_y := player.position_y
            if !are_coordinates_blocked(intended_position_x, intended_position_y) && intended_position_x >= 0 {
                player.position_x -= 1
                should_redraw_everything()
            }
        }
    }
    player.direction = u32(Direction.Left)
}
move_player_right :: proc(override_block: bool = false) {
    player := get_player_in_world()
    if override_block {
        player.position_x += 1
    } else {
        if (player.position_x < current_world.width) {
            intended_position_x := player.position_x + 1
            intended_position_y := player.position_y
            if !are_coordinates_blocked(intended_position_x, intended_position_y) && intended_position_x < current_world.width {
                player.position_x += 1
                should_redraw_everything()
            }
        }
    }
    player.direction = u32(Direction.Right)
}
move_player_down :: proc(override_block: bool = false) {
    player := get_player_in_world()
    if override_block {
        player.position_y += 1
    } else {
        if (player.position_y < current_world.height) {
            intended_position_x := player.position_x
            intended_position_y := player.position_y + 1
            if !are_coordinates_blocked(intended_position_x, intended_position_y) && intended_position_y < current_world.height {
                player.position_y += 1
                should_redraw_everything()
            }
        }
    }
    player.direction = u32(Direction.Down)
}
move_player_up :: proc(override_block: bool = false) {
    player := get_player_in_world()
    if override_block {
        player.position_y -= 1
    } else {
        if (player.position_y > 0) {
            intended_position_x := player.position_x
            intended_position_y := player.position_y - 1
            if !are_coordinates_blocked(intended_position_x, intended_position_y) && intended_position_y >= 0 {
                player.position_y -= 1
                should_redraw_everything()
            }
        }
    }
    player.direction = u32(Direction.Up)
}
move_player_to_coordinates :: proc(x: u32, y: u32, override_block: bool = false) {
    player := get_player_in_world()
    if override_block {
        player.position_x = x
        player.position_y = y
    } else {
        intended_position_x := player.position_x
        intended_position_y := player.position_y
        if !are_coordinates_blocked(intended_position_x, intended_position_y) &&
            intended_position_x >= 0 && intended_position_y >= 0 &&
            intended_position_x < current_world.width &&
            intended_position_y < current_world.height
        {
            player.position_x = x
            player.position_y = y
            should_redraw_everything()
        }
    }
}


//------------------------------------- RENDERING -------------------------------------//
SHOULD_REDRAW :: enum u32 {
    Nothing,
    Everything,
    Ships,
    NPCs,
    Players,
}
should_redraw: u32 = 0
@(export)
renderer_should_redraw :: proc() -> u32 {
    if should_redraw > 0 {
        original_should_redraw := should_redraw
        should_redraw = u32(SHOULD_REDRAW.Nothing)
        return original_should_redraw
    }

    return 0
}
@(export)
should_redraw_everything :: proc() {
    should_redraw = u32(SHOULD_REDRAW.Everything)
}


//------------------------------------- VIEWPORT -------------------------------------//
viewport_width: u32 = 8
viewport_height: u32 = 8
@(export)
set_viewport_size :: proc(width: u32, height: u32) {
    viewport_width = width
    viewport_height = height
}
@(export)
get_viewport_width :: proc() -> u32 {
    return viewport_width
}
@(export)
get_viewport_height :: proc() -> u32 {
    return viewport_height
}
@(export)
get_viewport_value_at_coordinates :: proc(layer_index: u32, x: u32, y: u32) -> u32 {
    world_width: u32 = current_world.width
    world_height: u32 = current_world.height
    x_padding: u32 = 0
    y_padding: u32 = 0
    if viewport_width > world_width {
        x_padding = (viewport_width - world_width) / 2
    }
    if viewport_height > world_height {
        y_padding = (viewport_height - world_height) / 2
    }
    x_offset := x - x_padding
    y_offset := y - y_padding
    x_offset += camera_offset_x
    y_offset += camera_offset_y
    if x_offset < 0 || y_offset < 0 || x_offset >= world_width || y_offset >= world_height {
        // console_log("Off the edge of viewport %d %d %d %d", x_offset, y_offset, world_width, world_height)
        return SENTRY
    }

    npc_string_id := resource_find(&Strings_Pool, proc(s: StringStruct) -> bool {
        return s.machine_name == "npc_layer"
    })
    layer := &Layers_Pool.data[layer_index]
    if layer.name_id == npc_string_id {
        for i: u32 = 0; i < MAX_WORLD_NPCS; i += 1 {
            world_npc := &World_NPCS_Pool.data[i]
            // if world_npc.is_captain == true {
            //     continue
            // }
            if world_npc.npc_id == SENTRY {
                continue
            }
            npc := &NPCS_Pool.data[world_npc.npc_id]
            if world_npc.position_x == x_offset && world_npc.position_y == y_offset {
                // console_log("%d %s", i, Strings_Pool.data[npc.name_id].text)
                return i
            }
        }
        return SENTRY
    }

    return layer_get_value(layer_index, x_offset, y_offset)
}

@(export)
is_world_coordinate_in_viewport :: proc(x: u32, y: u32) -> bool {
    return x >= camera_offset_x && x < camera_offset_x + viewport_width &&
           y >= camera_offset_y && y < camera_offset_y + viewport_height
}
is_world_coordinate_halfway_of_viewport :: proc(x: u32, y: u32) -> (bool, bool, bool, bool) {
    halfway_x := camera_offset_x + viewport_width / 2
    halfway_y := camera_offset_y + viewport_height / 2

    more_than_halfway_x := x > halfway_x
    more_than_halfway_y := y > halfway_y
    less_than_halfway_x := x < halfway_x
    less_than_halfway_y := y < halfway_y

    return more_than_halfway_x, more_than_halfway_y, less_than_halfway_x, less_than_halfway_y
}


//------------------------------------- CAMERA -------------------------------------//
camera_offset_x: u32 = 0
camera_offset_y: u32 = 0
move_camera_down :: proc() {
    map_height := current_world.height
    
    // Calculate the maximum allowed camera offset
    max_camera_offset_y := max(0, map_height - viewport_height)
    
    // Check if moving down would exceed the map bounds
    if camera_offset_y < max_camera_offset_y {
        camera_offset_y += 1
        should_redraw_everything()
    }
}
move_camera_right :: proc() {
    map_width := current_world.width
    
    // Calculate the maximum allowed camera offset
    max_camera_offset_x := max(0, map_width - viewport_width)
    
    // Check if moving right would exceed the map bounds
    if camera_offset_x < max_camera_offset_x {
        camera_offset_x += 1
        should_redraw_everything()
    }
}
move_camera_up :: proc() {
    if camera_offset_y > 0 {
        camera_offset_y -= 1
        should_redraw_everything()
    }
}
move_camera_left :: proc() {
    if camera_offset_x > 0 {
        camera_offset_x -= 1
        should_redraw_everything()
    }
}


//------------------------------------- INVENTORIES -------------------------------------//
MAX_INVENTORY_SPACE: u32 : 100
InventoryType :: enum u32 {
    Good,
    Armor,
    Weapon,
    GeneralItem,
    Cannon,
    BaseShip,
    Ship,
}
InventoryItemStruct :: struct {
    name_id: u32,
    number_held: u32,
    adjusted_price: u32,
    type_id: u32, // u32(InventoryType)
    type_name_id: u32, // &Strings.data[type_id]
    type_reference: u32, // &Goods_Pool.data[type_id]
    inventory_id: u32, // &Inventories_Pool.data[inventory_id]
    number_chosen: u32,
}
MAX_INVENTORY_ITEMS: u32 : 100
MAX_INVENTORY_ITEMS_FREE_IDS: u32 : 10
Inventory_Items_Pool: Resource_Pool(InventoryItemStruct, MAX_INVENTORY_ITEMS, MAX_INVENTORY_ITEMS_FREE_IDS)
InventoryStruct :: struct {
    name_id: u32,
    total_items: u32,
}
MAX_INVENTORIES: u32 : 100
MAX_INVENTORIES_FREE_IDS: u32 : 10
Inventories_Pool: Resource_Pool(InventoryStruct, MAX_INVENTORIES, MAX_INVENTORIES_FREE_IDS)
free_inventory :: proc(index: u32) {
    item := &Inventories_Pool.data[index]

    // TODO: Iterate over Inventory_Items_Pool, find index/inventory_id, free_resource

    free_resource(&Inventories_Pool, index)
    item.name_id = SENTRY
    item.total_items = SENTRY
}
free_inventory_item :: proc(index: u32) {
    item := &Inventory_Items_Pool.data[index]

    free_resource(&Inventory_Items_Pool, index)
    // console_log("Freeing inventory item %d", index)
    item.name_id = SENTRY
    item.number_held = SENTRY
    item.adjusted_price = 0
    item.type_id = SENTRY
    item.type_name_id = SENTRY
    item.type_reference = SENTRY
    item.inventory_id = SENTRY
}
free_all_inventory_items :: proc() {
    // console_log("Freeing all inventory items")
    for i: u32 = 0; i < MAX_INVENTORY_ITEMS; i += 1 {
        free_inventory_item(i)
    }
}

@(export)
get_inventory_item_adjusted_price :: proc(inventory_item_id: u32) -> u32 {
    return Inventory_Items_Pool.data[inventory_item_id].adjusted_price
}

@(export)
get_inventory_item_number_held :: proc(inventory_item_id: u32) -> u32 {
    return Inventory_Items_Pool.data[inventory_item_id].number_held
}

@(export)
get_item_ref_name_id_from_inventory_item :: proc(inventory_item_id: u32) -> u32 {
    inventory_item := &Inventory_Items_Pool.data[inventory_item_id]
    switch inventory_item.type_id {
        case u32(InventoryType.Good):
            return Goods_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.Armor):
            return Armors_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.Weapon):
            return Weapons_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.GeneralItem):
            return General_Items_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.Cannon):
            return Cannons_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.BaseShip):
            return Base_Ships_Pool.data[inventory_item.type_reference].name_id
        case u32(InventoryType.Ship):
            return Ships_Pool.data[inventory_item.type_reference].name_id
    }
    return SENTRY
}

find_inventory_id_by_name_id :: proc(name_id: u32) -> u32 {
    for i: u32 = 0; i < MAX_INVENTORIES; i += 1 {
        if Inventories_Pool.data[i].name_id == name_id {
            return i
        }
    }
    return SENTRY
}
fiibni :: proc(name_id: u32) -> u32 {
    return find_inventory_id_by_name_id(name_id)
}

//------------------------------------- PORTS -------------------------------------//
PortStruct :: struct {
    name_id: u32,
    global_location_x: u32,
    global_location_y: u32,
    overall_investment_level: u32,
    market_investment_level: u32,
    shipyard_investment_level: u32,
}
// TODO: Port influenced by (all countries or whatever + percentage they influence)


//------------------------------------- SKILLS -------------------------------------//
StatsStruct :: struct {
    battle_level: u32,
    navigation_level: u32,
    leadership: u32,
    seamanship: u32,
    knowledge: u32,
    intuition: u32,
    courage: u32,
    swordsmanship: u32,
    charm: u32,
    luck: u32,
}
SkillStruct :: struct {
    name_id: u32,
    stats_requirements: StatsStruct,
}
MAX_SKILLS: u32 : 100
MAX_SKILLS_FREE_IDS: u32 : 10
Skills_Pool: Resource_Pool(SkillStruct, MAX_SKILLS, MAX_SKILLS_FREE_IDS)


//------------------------------------- ENTITY -------------------------------------//
EntityStruct :: struct {
    name: u32,
    name_ref: ^StringStruct,
    is_interactable: bool,
    is_blockable: bool,
    interaction_on_stepover: bool,
    interaction_scene: u32,
}
// TODO: Resource pool for this


//------------------------------------- FLEETS -------------------------------------//
// Once a ship is in a fleet, it needs some overrides based on overall fleet and who captains it (if anybody)
// Captains can belong to a fleet but only one captain is the leader of the fleet and the others are mates but captains can be captains of ships or mates of lead captain
FleetStruct :: struct {
    total_ships: u32,
    total_captains: u32,
    first_mate_id: u32, // Captain
    accountant_id: u32,
    navigator_id: u32,
    general_id: u32,
}
MAX_FLEETS: u32 : 100
MAX_FLEETS_FREE_IDS: u32 : 10
Fleets_Pool: Resource_Pool(FleetStruct, MAX_FLEETS, MAX_FLEETS_FREE_IDS)
FleetShipStruct :: struct {
    ship_id: u32,
    fleet_id: u32,
}
MAX_FLEET_SHIPS: u32 : 100
MAX_FLEET_SHIPS_FREE_IDS: u32 : 10
Fleet_Ships_Pool: Resource_Pool(FleetShipStruct, MAX_FLEET_SHIPS, MAX_FLEET_SHIPS_FREE_IDS)
MAX_FLEET_CAPTAINS: u32 : 100
MAX_FLEET_CAPTAINS_FREE_IDS: u32 : 10
FleetCaptain :: struct {
    captain_id: u32,
    fleet_id: u32,
}


//------------------------------------- CANNONS -------------------------------------//
CannonStruct :: struct {
    name_id: u32,
    range: u32,
    power: u32,
    base_price: u32,
}
MAX_CANNONS: u32 : 100
MAX_CANNONS_FREE_IDS: u32 : 10
Cannons_Pool: Resource_Pool(CannonStruct, MAX_CANNONS, MAX_CANNONS_FREE_IDS)

find_cannon_id_by_machine_name :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_CANNONS; i += 1 {
        if Cannons_Pool.data[i].name_id == SENTRY {
            continue
        }
        name_id := Cannons_Pool.data[i].name_id
        this_string := Strings_Pool.data[name_id].machine_name
        if this_string == text {
            return i
        }
    }
    return SENTRY
}


//------------------------------------- FIGUREHEADS -------------------------------------//
FigureHeadStruct :: struct {
    name_id: u32,
    base_price: u32,
}
MAX_FIGUREHEADS: u32 : 100
MAX_FIGUREHEADS_FREE_IDS: u32 : 10
FigureHeads_Pool: Resource_Pool(FigureHeadStruct, MAX_FIGUREHEADS, MAX_FIGUREHEADS_FREE_IDS)

find_figurehead_id_by_machine_name :: proc(text: string) -> u32 {
    for i: u32 = 0; i < MAX_FIGUREHEADS; i += 1 {
        if FigureHeads_Pool.data[i].name_id == SENTRY {
            continue
        }
        name_id := FigureHeads_Pool.data[i].name_id
        this_string := Strings_Pool.data[name_id].machine_name
        if this_string == text {
            return i
        }
    }
    return SENTRY
}


//------------------------------------- INPUT -------------------------------------//
accepting_input: bool
UserInput :: enum {
    A,
    B,
    X,
    Y,
    Up,
    Down,
    Left,
    Right,
    Start,
    Select,
    LeftBumper,
    RightBumper,
    CustomNumber,
    CustomString,
}
@(export)
user_input_a :: proc(force: bool = false) {
    handle_input(UserInput.A, force)
}
@(export)
user_input_b :: proc(force: bool = false) {
    handle_input(UserInput.B, force)
}
@(export)
user_input_x :: proc(force: bool = false) {
    handle_input(UserInput.X, force)
}
@(export)
user_input_y :: proc(force: bool = false) {
    handle_input(UserInput.Y, force)
}
@(export)
user_input_start :: proc(force: bool = false) {
    handle_input(UserInput.Start, force)
}
@(export)
user_input_select :: proc(force: bool = false) {
    handle_input(UserInput.Select, force)
}
@(export)
user_input_right_bumper :: proc(force: bool = false) {
    handle_input(UserInput.RightBumper, force)
}
@(export)
user_input_left_bumper :: proc(force: bool = false) {
    handle_input(UserInput.LeftBumper, force)
}
@(export)
user_input_up :: proc(force: bool = false) {
    handle_input(UserInput.Up, force)
}
@(export)
user_input_down :: proc(force: bool = false) {
    handle_input(UserInput.Down, force)
}
@(export)
user_input_left :: proc(force: bool = false) {
    handle_input(UserInput.Left, force)
}
@(export)
user_input_right :: proc(force: bool = false) {
    handle_input(UserInput.Right, force)
}
input_number: u32
@(export)
user_input_number :: proc(number: u32, force: bool = false) {
    input_number = number
    handle_input(UserInput.CustomNumber, force)
}
@(export)
user_input_string :: proc(force: bool = false) {
    handle_input(UserInput.CustomString, force)
}
handle_input :: proc(input: UserInput, force: bool = false) {
    if (!accepting_input && !force) {
        return
    }
    if current_game_mode == GameMode.In_Scene {
        current_scene_handle_input(input)
    } else if current_game_mode == GameMode.In_Port {
        player := get_player_in_world()
        if input == UserInput.Up {
            move_player_up()
            update_camera()
        } else if input == UserInput.Down {
            move_player_down()
            update_camera()
        } else if input == UserInput.Left {
            move_player_left()
            update_camera()
        } else if input == UserInput.Right {
            move_player_right()
            update_camera()
        } else if input == UserInput.Start {
            trigger_scene(fsibmn("scene_player_menu"))
        } else if input == UserInput.A {
            intended_direction_x: u32 = 0
            intended_direction_y: u32 = 0
            if player.direction == u32(Direction.Right) {
                intended_direction_x = player.position_x + 1
                if (intended_direction_x >= current_world.width) {
                    intended_direction_x = (current_world.width - 1)
                }
                intended_direction_y = player.position_y
            }
            if player.direction == u32(Direction.Left) {
                if player.position_x - 1 > 0 {
                    intended_direction_x = player.position_x - 1
                } else {
                    intended_direction_x = 0
                }
                intended_direction_y = player.position_y
            }
            if player.direction == u32(Direction.Down) {
                intended_direction_x = player.position_x
                intended_direction_y = player.position_y + 1
                if (intended_direction_y >= current_world.height) {
                    intended_direction_y = (current_world.height - 1)
                }
            }
            if player.direction == u32(Direction.Up) {
                intended_direction_x = player.position_x
                if player.position_y - 1 > 0 {
                    intended_direction_y = player.position_y - 1
                } else {
                    intended_direction_y = 0
                }
            }

            for i: u32 = 0; i < MAX_WORLD_NPCS; i += 1 {
                world_npc := World_NPCS_Pool.data[i]
                if 
                    world_npc.position_x == intended_direction_x &&
                    world_npc.position_y == intended_direction_y &&
                    world_npc.is_interactable
                {
                    trigger_scene(world_npc.interaction_scene)
                }
            }
        }
    } else if current_game_mode == GameMode.In_Ocean {
        // TODO: This
    } else if current_game_mode == GameMode.In_Ocean_Battle {
        // TODO: This
    }
}


//------------------------------------- CAMERA BASED ON INPUT -------------------------------------//
update_camera :: proc() {
    player := get_player_in_world()
    mt_x, mt_y, lt_x, lt_y := is_world_coordinate_halfway_of_viewport(player.position_x, player.position_y)
    if mt_x {
        move_camera_right()
    } else if lt_x && camera_offset_x > 0 {
        move_camera_left()
    }
    if mt_y {
        move_camera_down()
    } else if lt_y && camera_offset_y > 0 {
        move_camera_up()
    }
}


//------------------------------------- MOVE NPCS -------------------------------------//
@(export)
are_coordinates_blocked :: proc(x: u32, y: u32) -> bool {
    for i: u32 = 0; i < MAX_WORLD_NPCS; i += 1 {
        if World_NPCS_Pool.data[i].position_x == x && World_NPCS_Pool.data[i].position_y == y {
            return true
        }
    }

    // console_log("Checking if coordinates are blocked %d %d", x, y)
    if layer_id := find_x_id_by_machine_name(MAX_LAYERS, &Layers_Pool, "block_layer"); layer_id != SENTRY {
        layer_value := layer_get_value(layer_id, x, y)
        if layer_value == SENTRY {
            return false
        }
        if layer_value > 0 {
            return true
        }
    }

    // if entity_id := get_world_layer_coordinate_value("entity", x, y); entity_id > 0 {
    //     if world_entities[entity_id].is_blockable {
    //         return true
    //     }
    // }

    return false
}


//------------------------------------- OCEAN BATTLES -------------------------------------//
// TODO: This


//------------------------------------- LAND BATTLES -------------------------------------//
// TODO: This


//------------------------------------- GENERAL GAME STUFF -------------------------------------//
Direction :: enum {
    Up,
    Down,
    Left,
    Right,
}
GameMode :: enum u32 {
    Empty,
    In_Scene,
    In_Ocean_Battle,
    Opening_Title,
    In_Port,
    In_Ocean,
    On_Land,
}
current_game_mode: GameMode
@(export)
get_current_game_mode :: proc() -> u32 {
    #partial switch current_game_mode {
        case .Empty:
            return find_string_id_by_machine_name("empty")
        case .In_Port:
            return find_string_id_by_machine_name("in_port")
        case .In_Scene:
            return find_string_id_by_machine_name("in_scene")
        case:
            console_log("Could not find game mode?")
    }
    return SENTRY
}
has_game_started: bool = false
@(export)
tick :: proc () {
    increment_tick_counter(&tick_counter)
    if !has_game_started {
        has_game_started = true
        accepting_input = true
        generate_world("athens")
    } else if current_game_mode == GameMode.In_Port {
        // TODO: Anything here?
    } else if current_game_mode == GameMode.In_Scene {
        // TODO: Anything here?
    }
}

find_x_id_by_machine_name :: proc(max_items: u32, pool: ^Resource_Pool($T, $MAX_RESOURCES, $MAX_FREE_IDS), text: string) -> u32 {
    for i: u32 = 0; i < max_items; i += 1 {
        item := pool.data[i]
        if item.name_id == SENTRY {
            continue
        }
        name := &Strings_Pool.data[item.name_id]
        if name.machine_name == text {
            return i
        }
    }
    return SENTRY
}


//------------------------------------- BLACKJACK -------------------------------------//
DECK: [48]u32 // Adjusted size to 48 to exclude Jacks
PLAYER_DECK: [10]u32
PLAYER_DECK_INDEX: u32
DEALER_DECK: [10]u32
DEALER_DECK_INDEX: u32
DECK_INDEX: u32
PLAYER_STANDING: bool
DEALER_STANDING: bool
BET: u32

@(export)
blackjack_get_player_deck_card :: proc(index: u32) -> u32 {
    return PLAYER_DECK[index]
}

@(export)
blackjack_get_dealer_deck_card :: proc(index: u32) -> u32 {
    return DEALER_DECK[index]
}

@(export)
blackjack_randomize_deck :: proc() {
    deck_index := 0
    for i: u32 = 0; i < 52; i += 1 {
        // Skip Jack cards
        if i % 13 != 10 {
            DECK[deck_index] = i
            deck_index += 1
        }
    }
    // Adjusted loop to 47 from 52
    for i: u32 = 47; i > 0; i -= 1 {
        random_index := get_random_number(0, i + 1)
        temp := DECK[i]
        DECK[i] = DECK[random_index]
        DECK[random_index] = temp
    }
    DECK_INDEX = 0
    BET = 0
    PLAYER_STANDING = false
    DEALER_STANDING = false
}

@(export)
blackjack_start_game :: proc() {
    blackjack_randomize_deck()
    PLAYER_DECK_INDEX = 0
    DEALER_DECK_INDEX = 0
    PLAYER_DECK_INDEX = blackjack_add_card_to_deck(&PLAYER_DECK, PLAYER_DECK_INDEX)
    DEALER_DECK_INDEX = blackjack_add_card_to_deck(&DEALER_DECK, DEALER_DECK_INDEX)
    PLAYER_DECK_INDEX = blackjack_add_card_to_deck(&PLAYER_DECK, PLAYER_DECK_INDEX)
    DEALER_DECK_INDEX = blackjack_add_card_to_deck(&DEALER_DECK, DEALER_DECK_INDEX)
}

@(export)
blackjack_add_card_to_players_deck :: proc() {
    PLAYER_DECK_INDEX = blackjack_add_card_to_deck(&PLAYER_DECK, PLAYER_DECK_INDEX)
}

@(export)
blackjack_add_card_to_dealers_deck :: proc() {
    DEALER_DECK_INDEX = blackjack_add_card_to_deck(&DEALER_DECK, DEALER_DECK_INDEX)
}

blackjack_add_card_to_deck :: proc(someones_deck: ^[10]u32, someones_deck_index: u32) -> u32 {
    someones_deck[someones_deck_index] = DECK[DECK_INDEX]
    DECK_INDEX += 1
    return someones_deck_index + 1
}

@(export)
blackjack_get_card_value :: proc(card_index: u32) -> u32 {
    card := card_index % 13
    if card == 0 {
        return 11
    }
    if card > 10 {
        return 10
    }
    return card
}

@(export)
blackjack_get_dealers_deck_value :: proc() -> u32 {
    total: u32 = 0
    for i: u32 = 0; i < DEALER_DECK_INDEX; i += 1 {
        total += blackjack_get_card_value(DEALER_DECK[i])
    }
    return total
}

@(export)
blackjack_get_players_deck_value :: proc() -> u32 {
    total: u32 = 0
    for i: u32 = 0; i < PLAYER_DECK_INDEX; i += 1 {
        total += blackjack_get_card_value(PLAYER_DECK[i])
    }
    return total
}

@(export)
blackjack_player_hit :: proc() {
    PLAYER_DECK_INDEX = blackjack_add_card_to_deck(&PLAYER_DECK, PLAYER_DECK_INDEX)
}

@(export)
blackjack_dealer_hit :: proc() {
    DEALER_DECK_INDEX = blackjack_add_card_to_deck(&DEALER_DECK, DEALER_DECK_INDEX)
}

blackjack_get_deck_value :: proc(deck: ^[10]u32, deck_index: u32) -> u32 {
    total: u32 = 0
    for i: u32 = 0; i < deck_index; i += 1 {
        total += blackjack_get_card_value(deck[i])
    }
    return total
}

@(export)
blackjack_check_winner :: proc() -> u32 {
    player_total := blackjack_get_deck_value(&PLAYER_DECK, PLAYER_DECK_INDEX)
    dealer_total := blackjack_get_deck_value(&DEALER_DECK, DEALER_DECK_INDEX)
    if player_total > 21 {
        return 2
    }
    if dealer_total > 21 {
        return 1
    }
    if player_total > dealer_total {
        return 1
    }
    if dealer_total > player_total {
        return 2
    }
    // 2 = dealer, 1 = player, 0 = tie
    return 0
}

@(export)
blackjack_player_stand :: proc() {
    PLAYER_STANDING = true
}

@(export)
blackjack_dealer_stand :: proc() {
    DEALER_STANDING = true
}

@(export)
blackjack_dealer_turn :: proc() {
    dealer_total := blackjack_get_deck_value(&DEALER_DECK, DEALER_DECK_INDEX)
    if dealer_total < 17 {
        blackjack_dealer_hit()
    } else {
        DEALER_STANDING = true
    }
}


//------------------------------------- PLAYERS -------------------------------------//
players: [10]u32
// TODO: A more efficient way to do this man
// TODO: Set players[0] to Captains_Pool[0].player = 1
get_player_in_world :: proc() -> ^WorldNPCStruct {
    // TODO: Where World_NPCS_Pool.is_captain && captain_id = players[0] (captain_pool id)
    captain := &Captains_Pool.data[players[0]]
    if captain.in_world {
        return &World_NPCS_Pool.data[captain.world_npc_id]
    }
    return nil
}
get_player :: proc() -> ^CaptainStruct {
    return &Captains_Pool.data[players[0]]
}
@(export)
get_player_gold :: proc() -> u32 {
    return get_player().gold
}
@(export)
get_player_total_items :: proc() -> u32 {
    // Reference the players captainstruct inventory_id -> total_items
    return Inventories_Pool.data[get_player().inventory_id].total_items
}


//------------------------------------- INITIALIZE -------------------------------------//
@(export)
initialize_game :: proc() {
    tick_counter = 1
    current_game_mode = GameMode.Empty

    current_scene = SENTRY

    free_all_world_npcs()
    free_all_inventory_items()

    ran_string(
        "Empty",
        "empty"
    )
    ran_string(
        "You have %d gold.",
        "you_have_x_gold"
    )
    ran_string(
        "Hello",
        "hello"
    )
    ran_string(
        "Player Menu",
        "player_menu"
    )
    ran_string(
        "Inside",
        "inside"
    )
    ran_string(
        "General Shop",
        "general_shop"
    )
    ran_string(
        "Invest",
        "invest"
    )
    ran_string(
        "General",
        "general"
    )
    ran_string(
        "You don't have enough gold for this",
        "not_enough_gold"
    )
    ran_string(
        "General",
        "general_item"
    )
    ran_string(
        "Exit",
        "exit"
    )

    // Menu Item Texts
    ran_string(
        "Buy",
        "buy"
    )
    ran_string(
        "Sell",
        "sell"
    )
    ran_string(
        "Cancel",
        "cancel"
    )
    ran_string(
        "Confirm",
        "confirm"
    )
    ran_string(
        "Yes",
        "yes"
    )
    ran_string(
        "No",
        "no"
    )
    ran_string(
        "Withdraw",
        "withdraw"
    )
    ran_string(
        "Deposit",
        "deposit"
    )
    ran_string(
        "Loan",
        "loan"
    )
    ran_string(
        "Play",
        "play"
    )
    ran_string(
        "Number Input",
        "number_input"
    )

    // Scene Texts
    // Digi Tal Bank
    ran_string(
        "Digi Tal Bank",
        "digi_tal_bank"
    )
    ran_string(
        "Welcome to the Global Digi Tal Bank",
        "welcome_to_digi_tal_bank"
    )
    ran_string(
        "We offer loans up to 10,000 gold at a %d%% interest rate per year. Are you interested?",
        "loan_details"
    )
    ran_string(
        "How much of a loan would you like to take? Remember, the maximum is 10,000.",
        "take_loan_amount"
    )
    ran_string(
        "Are you sure you want to take a loan for %d gold?",
        "confirm_loan_amount"
    )
    ran_string(
        "Congratulations on your loan. May you be prosperous.",
        "loan_taken"
    )
    ran_string(
        "You don't have enough gold to pay down your loan",
        "pay_loan_no_money"
    )
    ran_string(
        "You don't have an active deposit account with us to withdraw from",
        "withdraw_no_account"
    )
    ran_string(
        "I would love to take your money but you don't seem to have any",
        "deposit_no_money"
    )
    ran_string(
        "We offer a %d%% interest rate per year on deposits. Are you interested?",
        "deposit_to_new_account"
    )
    ran_string(
        "Your account currently has %d gold. How much would you like to deposit?",
        "deposit_to_existing_account"
    )
    ran_string(
        "How much would you like to deposit?",
        "deposit_amount"
    )
    ran_string(
        "Are you sure you want to deposit %d gold?",
        "confirm_deposit_amount"
    )
    ran_string(
        "I've added your gold to your account. Thank you for your business.",
        "deposit_confirmed"
    )
    ran_string(
        "Your account currently has %d gold. Would you like to withdraw some gold?",
        "withdraw_from_account"
    )
    ran_string(
        "How much do you want to withdraw?",
        "withdraw_amount"
    )
    ran_string(
        "Are you sure you want to withdraw %d gold? Your account will have %d gold remaining.",
        "confirm_withdraw_amount"
    )
    ran_string(
        "You cannot withdraw more than you have in your account",
        "withdraw_too_much"
    )
    ran_string(
        "Are you sure you want to withdraw %d gold? This will empty your account.",
        "confirm_withdraw_amount_will_empty"
    )
    ran_string(
        "Here is your gold from your account. Thank you for your business.",
        "withdraw_confirmed"
    )
    // General Shop
    ran_string(
        "Welcome to the General Shop",
        "welcome_to_general_shop"
    )
    ran_string(
        "Are you sure you want to purchase these for %d gold?",
        "confirm_purchase"
    )
    ran_string(
        "Thank you for your purchase",
        "thank_you_for_your_purchase"
    )
    ran_string(
        "Here's what I have to offer today",
        "general_shop_buy"
    )
    ran_string(
        "What would you like to sell?",
        "general_shop_sell"
    )
    ran_string(
        "This will cost you %d gold. Are you sure?",
        "confirm_buy"
    )
    ran_string(
        "I would love nothing more than to take your money but you don't seem to have enough",
        "buy_not_enough_money"
    )
    ran_string(
        "Thank you for your purchase",
        "buy_confirmed"
    )
    ran_string(
        "Are you sure you want to sell these for %d gold?",
        "confirm_sell"
    )
    ran_string(
        "I'll take those items off your hands. Here is your gold.",
        "sell_confirmed"
    )
    // Blackjack
    ran_string(
        "Welcome to the Blackjack Table",
        "welcome_to_blackjack"
    )
    ran_string(
        "Would you like to place a bet?",
        "blackjack_place_bet"
    )
    ran_string(
        "How much would you like to bet?",
        "blackjack_bet_amount"
    )
    ran_string(
        "Are you sure you want to bet %d gold?",
        "blackjack_confirm_bet"
    )
    ran_string(
        "You don't have enough gold to place that bet",
        "blackjack_bet_too_much"
    )
    ran_string(
        "You can hit or stay",
        "blackjack_play"
    )
    ran_string(
        "You're going to hit? Nice.",
        "blackjack_hit"
    )
    ran_string(
        "You're going to stay? Good choice.",
        "blackjack_stay"
    )
    ran_string(
        "Looks like you lost this time. Better luck next time.",
        "blackjack_dealer_won"
    )
    ran_string(
        "Congratulations! You won!",
        "blackjack_player_won"
    )
    ran_string(
        "Hit",
        "hit"
    )
    ran_string(
        "Stand",
        "stand"
    )
    ran_string(
        "Dealers turn",
        "blackjack_dealer_turn"
    )

    // Game Modes
    ran_string(
        "In Ocean",
        "in_ocean"
    )
    ran_string(
        "In Scene",
        "in_scene"
    )
    ran_string(
        "In Ocean Battle",
        "in_ocean_battle"
    )
    ran_string(
        "Opening Title",
        "opening_title"
    )
    ran_string(
        "In Port",
        "in_port"
    )
    ran_string(
        "On Land",
        "on_land"
    )

    // Layers
    ran_string(
        "Background Layer",
        "bg_layer"
    )
    ran_string(
        "NPC Layer",
        "npc_layer"
    )
    ran_string(
        "Block Layer",
        "block_layer"
    )
    ran_string(
        "Layer 1",
        "layer_one"
    )

    // Players
    ran_string(
        "Player 1",
        "player_one"
    )
    ran_string(
        "Player 1's Inventory",
        "player_ones_inventory"
    )

    // NPCs
    ran_string(
        "Bank Teller",
        "bank_teller"
    )
    ran_string(
        "General Shop Owner",
        "general_shop_owner"
    )
    ran_string(
        "General Shop Inventory",
        "general_shop_inventory"
    )
    ran_string(
        "Blackjack Player",
        "blackjack_player"
    )

    // Ports
    ran_string(
        "Athens",
        "athens"
    )

    // Items
    ran_string(
        "Telescope",
        "telescope"
    )
    ran_string(
        "Quadrant",
        "quadrant"
    )
    ran_string(
        "Theodolite",
        "theodolite"
    )
    ran_string(
        "Sextant",
        "sextant"
    )

    // Ship Materials
    ran_string(
        "Beech",
        "beech"
    )

    // Ships
    ran_string(
        "Balsa",
        "balsa"
    )
    ran_string(
        "Hansa Cog",
        "hansa_cog"
    )
    ran_string(
        "Light Galley",
        "light_galley"
    )
    ran_string(
        "Tallette",
        "tallette"
    )
    ran_string(
        "Kansen",
        "kansen"
    )
    ran_string(
        "Caravela Latina",
        "caravela_latina"
    )
    ran_string(
        "Caravela Redonda",
        "caravela_redonda"
    )
    ran_string(
        "Dhow",
        "dhow"
    )
    ran_string(
        "Junk",
        "junk"
    )
    ran_string(
        "Brigantine",
        "brigantine"
    )
    ran_string(
        "Atakabune",
        "atakabune"
    )
    ran_string(
        "Flemish Galleon",
        "flemish_galleon"
    )
    ran_string(
        "Nao",
        "nao"
    )
    ran_string(
        "Xebec",
        "xebec"
    )
    ran_string(
        "Venetian Galeass",
        "venetian_galeass"
    )
    ran_string(
        "Pinnace",
        "pinnace"
    )
    ran_string(
        "Carrack",
        "carrack"
    )
    ran_string(
        "La Reale",
        "la_reale"
    )
    ran_string(
        "Buss",
        "buss"
    )
    ran_string(
        "Galleon",
        "galleon"
    )
    ran_string(
        "Sloop",
        "sloop"
    )
    ran_string(
        "Tekkousen",
        "tekkousen"
    )
    ran_string(
        "Frigate",
        "frigate"
    )
    ran_string(
        "Barge",
        "barge"
    )
    ran_string(
        "Full-Rigged Ship",
        "full_rigged_ship"
    )

    // Figureheads
    ran_string(
        "Seahorse",
        "seahorse"
    )
    ran_string(
        "Commodore",
        "commodore"
    )
    ran_string(
        "Unicorn",
        "unicorn"
    )
    ran_string(
        "Lion",
        "lion"
    )
    ran_string(
        "Giant Eagle",
        "gian_eagle"
    )
    ran_string(
        "Hero",
        "hero"
    )
    ran_string(
        "Neptune",
        "neptune"
    )
    ran_string(
        "Dragon",
        "dragon"
    )
    ran_string(
        "Angel",
        "angel"
    )
    ran_string(
        "Goddess",
        "goddess"
    )

    // Cannons
    ran_string(
        "Cannon",
        "cannon"
    )
    ran_string(
        "Demi-Cannon",
        "demi_cannon"
    )
    ran_string(
        "Cannon Pedero",
        "cannon_pedero"
    )
    ran_string(
        "Culverin",
        "culverin"
    )
    ran_string(
        "Demi-Culverin",
        "demi_culverin"
    )
    ran_string(
        "Saker",
        "saker"
    )
    ran_string(
        "Carronade",
        "carronade"
    )
    ran_string(
        "Heavy Cannon",
        "heavy_cannon"
    )

    // Items
    ran_string(
        "Pocket Watch",
        "pocket_watch"
    )
    ran_string(
        "Rat Poison",
        "rat_poison"
    )
    ran_string(
        "Cat",
        "cat"
    )
    ran_string(
        "Lime Juice",
        "lime_juice"
    )
    ran_string(
        "Balm",
        "balm"
    )

    // Scenes
    ran_string(
        "Digi Tal Bank Scene",
        "scene_digi_tal_bank"
    )
    ran_string(
        "General Shop Scene",
        "scene_general_shop"
    )
    ran_string(
        "Player Menu Scene",
        "scene_player_menu"
    )
    ran_string(
        "Blackjack Scene",
        "scene_blackjack"
    )

    // Worlds
    string_id := find_string_id_by_machine_name("athens")
    resource_add_new(
        &Worlds_Pool,
        WorldStruct{
            // Note: You cannot directly assign the "find_string*" functions or Odin freaks out in WASM browser
            name_id=string_id,
            width=20,
            height=20,
            // total_npcs
            // total_captains
            // total_layers
        })

    // NPCS
    string_id = find_string_id_by_machine_name("bank_teller")
    resource_add_new(
        &NPCS_Pool,
        NPCStruct{
            name_id=string_id,
            type=u32(NPCTypes.Human),
        })
    string_id = find_string_id_by_machine_name("general_shop_owner")
    resource_add_new(
        &NPCS_Pool,
        NPCStruct{
            name_id=string_id,
            type=u32(NPCTypes.Human),
        })
    string_id = find_string_id_by_machine_name("blackjack_player")
    resource_add_new(
        &NPCS_Pool,
        NPCStruct{
            name_id=string_id,
            type=u32(NPCTypes.Human),
        })
    string_id = find_string_id_by_machine_name("player_one")
    npc_id := resource_add_new(
        &NPCS_Pool,
        NPCStruct{
            name_id=string_id,
            type=u32(NPCTypes.Human),
        })

    // Inventories
    string_id = find_string_id_by_machine_name("player_ones_inventory")
    inventory_id := resource_add_new(
        &Inventories_Pool,
        InventoryStruct{
            name_id=string_id,
            total_items=0
        })

    // Materials
    string_id = find_string_id_by_machine_name("beech")
    top_material_id := resource_add_new(
        &Ship_Materials_Pool,
        ShipMaterialStruct{
            name_id=string_id,
            base_price=100,
            mod_power=20,
            mod_capacity=20,
            mod_tacking=20,
            mod_speed=20,
        })

    // Base Ships
    string_id = find_string_id_by_machine_name("balsa")
    resource_add_new(
        &Base_Ships_Pool,
        BaseShipStruct{
            name_id=string_id,
            top_material_id=top_material_id,
            base_price=100,
            max_capacity=100,
            base_tacking=30,
            base_power=30,
            base_speed=30,
        })

    string_id = find_string_id_by_machine_name("empty")
    captain_id: u32
    captain_id = resource_add_new(
        &Captains_Pool,
        CaptainStruct{
            npc_id=npc_id,
            // TODO: Deal with this appropriately
            in_world=true,
            player=1,
            inventory_id=inventory_id,
        })
    players[0] = captain_id

    bank_default_values()

    string_id = find_string_id_by_machine_name("telescope")
    resource_add_new(
        &General_Items_Pool,
        GeneralItemStruct{
            name_id=string_id,
            base_price=100,
        })
    string_id = find_string_id_by_machine_name("quadrant")
    resource_add_new(
        &General_Items_Pool,
        GeneralItemStruct{
            name_id=string_id,
            base_price=100,
        })
    string_id = find_string_id_by_machine_name("theodolite")
    resource_add_new(
        &General_Items_Pool,
        GeneralItemStruct{
            name_id=string_id,
            base_price=100,
        })
    string_id = find_string_id_by_machine_name("sextant")
    resource_add_new(
        &General_Items_Pool,
        GeneralItemStruct{
            name_id=string_id,
            base_price=100,
        })

    string_id = find_string_id_by_machine_name("angel")
    resource_add_new(
        &FigureHeads_Pool,
        FigureHeadStruct{
            name_id = string_id,
            base_price = 10,
        })

    // TODO: Player menu
    // Mostly just showing stats and stuff
    // Inventory state needs inventory, which the renderer should be able to pull directly
    // When using an item, that's where this kicks in. Use item should be a handle in this scene
    // Status effects, buffs, equip/unequip, etc...
    // Sort by count or type can simply be inventory functions you can all with a referenced inventory

    /*
    Goods shop would have to be
    -> list of goods, show their market price
    -> choice -> the good you want to buy
    -> what to buy (what good), how many lots, which ships to put lots into and how many lots per individual ship
    -> you will have to show all available ships in fleet and how much cannonballs, crew and available cargo space
    -> input would have to be multi-array I guess
    -> ship_id,# of lots in ship

    Sell goods would have to be
    -> list of all available goods across all ships, # available to sell, market price
    -> pick one
    -> haggle
    ----> I will buy this for X per lot, what do you think?
    ----> Yes = accept this price
    ----> No = do not accept this price Ok how much will you sell it to me for?
    -----> wait for input _input_number_
    -----> if _input_number_ is within threshold then say "I can pay that much" else "That's too rich for me" and go back to list
    ----> accepted price per lot, ask "How many will you sell me?"
    ----> wait for input -> input_number = how many lots
    ----> "Are you sure you want to sell me X lots? The total would be X gold"
    ----> Yes -> gold += payment, lots are taken away from ship
    ----> No = go back to beginning
    */

    /*
    Shipyard would be
    -> New, Used, Sell, Remodel, Invest

    New -> Choose Type, Hull, Sails(?), Space for Cannons, Space for Crew
    Remodel -> Choose which ship -> Cannon Type, Space for Cannons, Space for Crew, Sails, Figurehead
    Sell -> show list of ships, pick one, owner says "I'll buy that for X dollars", yes/no, yes = if ship has cargo, distribute or sell, if crew > 0 distribute or let go, remove from fleet, if ship had captain set as free captain in fleet, if captain was player then choose another flagship for player    
    Used -> show list of used ships, review their details, ask for X dollars, haggle, then accept and add to fleet or don't
    Invest -> how much? are you sure? Wow thank you!
    */

    create_blackjack_fsm()
}

@(export)
test :: proc() {
    player := &Captains_Pool.data[players[0]]
    player.gold = 10000
    telescope_id := find_x_id_by_machine_name(
        MAX_GENERAL_ITEMS,
        &General_Items_Pool,
        "telescope"
    )
    resource_add_new(
        &Inventory_Items_Pool,
        InventoryItemStruct{
            name_id = find_string_id_by_machine_name("telescope"),
            number_held = 1,
            adjusted_price = 120,
            type_id = u32(InventoryType.GeneralItem),
            type_name_id = fsibmn("general_item"),
            type_reference = telescope_id,
            inventory_id = player.inventory_id,
        })
    player_inventory := &Inventories_Pool.data[player.inventory_id]
    player_inventory.total_items += 1

    fleet_id := resource_add_new(
        &Fleets_Pool,
        FleetStruct{
            total_ships = SENTRY,
            total_captains = SENTRY,
            first_mate_id = SENTRY,
            accountant_id = SENTRY,
            navigator_id = SENTRY,
            general_id = SENTRY,
        })
    player.fleet_id = fleet_id
    name_id := find_string_id_by_machine_name("balsa")
    base_ship_id := find_x_id_by_machine_name(MAX_BASE_SHIPS, &Base_Ships_Pool, "balsa")
    figurehead_id := find_figurehead_id_by_machine_name("angel")
    ship_id := resource_add_new(
        &Ships_Pool,
        ShipStruct{
            name_id = name_id,
            custom_name = "Player Ones Test Ship",
            base_ship_id = base_ship_id,
            price = 200,
            material_id = Base_Ships_Pool.data[base_ship_id].top_material_id,
            capacity = 200,
            tacking = 100,
            power = 100,
            speed = 100,
            captain_id = players[0],
            figurehead_id = figurehead_id,
        })
    fleet_ship_id := resource_add_new(
        &Fleet_Ships_Pool,
        FleetShipStruct{
            ship_id = ship_id,
            fleet_id = fleet_id,
        })
}



// TODO: Use this style of if statement
/*
npc := &NPC_Pool.data[npc_index]
if name := get_npc_name(npc); name != nil {
    console_log("NPC Name: %s", name.text)
}
if captain := get_npc_captain(npc); captain != nil {
    // Use captain attributes
}
*/
// TODO: Write your own allocator for this maybe?
Resource_Pool :: struct($T: typeid, $MAX_RESOURCES, $MAX_FREE_IDS: u32) {
    data: [MAX_RESOURCES]T,
    free_ids: [MAX_FREE_IDS]u32,
    free_ids_count: u32,
    next_free_id: u32,
}
allocate_resource :: proc(pool: ^Resource_Pool($T, $MAX_RESOURCES, $MAX_FREE_IDS)) -> u32 {
    // #no_bounds_check {
    if pool.free_ids_count > 0 {
        id := pool.free_ids[pool.free_ids_count-1]
        pool.free_ids[pool.free_ids_count-1] = 0  // Reset to default
        pool.free_ids_count -= 1
        return id
    } else if pool.next_free_id < MAX_RESOURCES {
        id := pool.next_free_id
        pool.next_free_id += 1
        return id
    }
    // }
    return SENTRY // Sentinel value indicating failure
}
free_resource :: proc(pool: ^Resource_Pool($T, $MAX_RESOURCES, $MAX_FREE_IDS), id: u32) {
    if id < MAX_RESOURCES {
        if pool.free_ids_count < MAX_FREE_IDS {
            pool.free_ids[pool.free_ids_count] = id
            pool.free_ids_count += 1
        }
        // Reset the resource at this ID to default state
        pool.data[id] = T{}
    }
}
resource_add_new :: proc(pool: ^Resource_Pool($T, $MAX_RESOURCES, $MAX_FREE_IDS), new_entry: T) -> u32 {
    id := allocate_resource(pool)
    // console_log("New resource added %d %s", id, new_entry)
    if id < MAX_RESOURCES {
        pool.data[id] = new_entry
        return id
    }
    return SENTRY
}
resource_find :: proc(pool: ^Resource_Pool($T, $MAX_RESOURCES, $MAX_FREE_IDS), predicate: proc(T) -> bool) -> u32 {
    for id in 0..<MAX_RESOURCES {
        if predicate(pool.data[id]) {
            return id
        }
    }
    console_log("Resource not found")
    return SENTRY
}


//------------------------------------- FINITE STATE MACHINES -------------------------------------//
MAX_FINITE_STATES: u32 : 100
MAX_FINITE_STATE_FLAGS: u32 : 100
MAX_FINITE_STATE_HISTORY: u32 : 100
Finite_State_Machine_Type :: enum {
    None,
    Scene,
}
FiniteStateMachineStruct :: struct {
    name_id: u32,
    states: [MAX_FINITE_STATES]u32,
    type: u32,
    current_state: u32,
    total_states: u32,
    flags: [MAX_FINITE_STATE_FLAGS]u32,
    history: [MAX_FINITE_STATE_HISTORY]u32,
    trigger: proc(),
}
MAX_FINITE_STATE_MACHINES: u32 : 100
MAX_FINITE_STATE_MACHINES_FREE_IDS: u32 : 10
Finite_State_Machines_Pool: Resource_Pool(FiniteStateMachineStruct, MAX_FINITE_STATE_MACHINES, MAX_FINITE_STATE_MACHINES_FREE_IDS)
// Note: The naming here is purposefully faked so you know what you're reaching for. Under the hood, it's all FSMs
find_scene_by_name_id :: proc(name_id: u32) -> u32 {
    for i: u32 = 0; i < MAX_FINITE_STATE_MACHINES; i += 1 {
        if Finite_State_Machines_Pool.data[i].type != u32(Finite_State_Machine_Type.Scene) {
            continue
        }
        if Finite_State_Machines_Pool.data[i].name_id == name_id {
            return i
        }
    }
    return SENTRY
}

DefaultFiniteStateStruct :: struct {
    name_id: u32,
    
    on_enter: proc(),
    on_exit: proc(),
    execute_action: proc(action: u32),
    enter_allowed: proc() -> bool,
}
MAX_DEFAULT_FINITE_STATES: u32 : 100
MAX_DEFAULT_FINITE_STATES_FREE_IDS: u32 : 10
Default_Finite_States_Pool: Resource_Pool(DefaultFiniteStateStruct, MAX_DEFAULT_FINITE_STATES, MAX_DEFAULT_FINITE_STATES_FREE_IDS)
get_default_finite_state_ref :: proc(fsm: ^FiniteStateMachineStruct, state: u32) -> ^DefaultFiniteStateStruct {
    return &Default_Finite_States_Pool.data[fsm.states[state]]
}

SceneStateStruct :: struct {
    default_state_id: u32,

    // Just use ENUMS
    // choices: [MAX_SCENE_CHOICES]u32,
    total_choices: u32,
    // TODO: Track this based on user input
    current_choice: u32,
    // For things like "How much?" and you have to focus on number input and listen to up and down inputs to change the number
    focused_on_choice: bool,
    make_choice: proc(choice: u32),
    get_choice: proc(choice: u32) -> u32,
    choice_to_string_id: proc(choice: u32) -> u32,
    handle_input: proc(input: UserInput),

    inventory_id: u32,
    // Store this in the InventoryItemStruct instead. It's pretty common
    // current_chosen_inventory: [MAX_INVENTORY_SPACE * 2]u32,
    // TODO: Track this based on user input (increment decrement amount)
    current_chosen_inventory: u32,
    set_chosen_inventory: proc(item_id: u32, amount: u32),

    // TODO: Track this based on user input (like up down increases decreases number + right bumper increases by 10, etc...)
    current_input_number: u32,

    dialogue_id: u32,
    should_free_dialogue: bool,
}
MAX_SCENE_FINITE_STATES: u32 : 100
MAX_SCENE_FINITE_STATES_FREE_IDS: u32 : 10
Scene_Finite_States_Pool: Resource_Pool(SceneStateStruct, MAX_SCENE_FINITE_STATES, MAX_SCENE_FINITE_STATES_FREE_IDS)
get_scene_finite_state_ref :: proc(fsm: ^FiniteStateMachineStruct, state: u32) -> ^SceneStateStruct {
    return &Scene_Finite_States_Pool.data[fsm.states[state]]
}
get_scene_default_finite_state_ref :: proc(fsm: ^FiniteStateMachineStruct, state: u32) -> ^DefaultFiniteStateStruct {
    return get_default_finite_state_ref(fsm, get_scene_finite_state_ref(fsm, state).default_state_id)
}
@(export)
current_scene_get_dialogue :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).dialogue_id
}
@(export)
current_scene_get_total_choices :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).total_choices
}
@(export)
current_scene_get_choice_string :: proc(choice: u32) -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    actual_choice := get_scene_finite_state_ref(fsm, fsm.current_state).get_choice(choice)
    return get_scene_finite_state_ref(fsm, fsm.current_state).choice_to_string_id(actual_choice)
}
current_scene_handle_input :: proc(input: UserInput) {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    scene_state := get_scene_finite_state_ref(fsm, fsm.current_state)
    scene_state.handle_input(input)
}
@(export)
current_scene_get_name :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return fsm.name_id
}
@(export)
current_scene_get_state :: proc() -> u32 {
    // Get the defaultstatestruct from current state of fsm and then return its name_id
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_default_finite_state_ref(fsm, fsm.current_state).name_id
}
@(export)
current_scene_get_current_chosen_inventory :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).current_chosen_inventory
}
@(export)
current_scene_get_current_input_number :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).current_input_number
}
@(export)
current_scene_get_current_choice :: proc() -> u32 {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).current_choice
}
@(export)
current_scene_get_current_choice_focused :: proc() -> bool {
    fsm := &Finite_State_Machines_Pool.data[current_scene]
    return get_scene_finite_state_ref(fsm, fsm.current_state).focused_on_choice
}

BlackjackSceneStates :: enum {
    // These first 4 must be in sequential order
    SayHello,
    NoMoneyToPlay,
    AskToPlaceBet,
    AskToConfirmBet,
    DealFirstCards,

    // If the player has already stood then we execute this state but just skip to the dealer
    AskPlayerToHitOrStand,
    DealPlayerCard,
    // If the dealer has stood then we execute this state but just skip to CheckForWinner
    DealerHitsOrStands,
    DealDealerCard,
    // If both players have stood OR there's already a winner...
    CheckForWinner,
}
BlackjackSceneChoices :: enum {
    Confirm,
    Cancel,
    Hit,
    Stand,
    NumberInput,
}
BLACKJACK_FSM: ^FiniteStateMachineStruct
create_blackjack_fsm :: proc() {
    fsm_id := resource_add_new(
        &Finite_State_Machines_Pool,
        FiniteStateMachineStruct{
            name_id = find_string_id_by_machine_name("scene_blackjack"),
            type = u32(Finite_State_Machine_Type.Scene),
            current_state = u32(BlackjackSceneStates.SayHello),
            total_states = len(BlackjackSceneStates),
        })
    BLACKJACK_FSM = &Finite_State_Machines_Pool.data[fsm_id]
    BLACKJACK_FSM.trigger = proc() {
        scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.SayHello))
        BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
        scene_state.on_enter()
    }
    for i: u32 = 0; i < len(BlackjackSceneStates); i += 1 {
        default_state_id := resource_add_new(
            &Default_Finite_States_Pool,
            DefaultFiniteStateStruct{
                name_id = find_string_id_by_machine_name("empty"),
                on_enter = proc() {console_log("Why dis empty do?")},
                on_exit = proc() {},
                execute_action = proc(action: u32) {},
                enter_allowed = proc() -> bool { return true },
            })
        scene_state_id := resource_add_new(
            &Scene_Finite_States_Pool,
            SceneStateStruct{
                default_state_id = default_state_id,
                total_choices = SENTRY,
                current_choice = SENTRY,
                focused_on_choice = false,
                make_choice = proc(choice: u32) {},
                get_choice = proc(choice: u32) -> u32 { return SENTRY },
                choice_to_string_id = proc(choice: u32) -> u32 { return SENTRY },
                inventory_id = SENTRY,
                set_chosen_inventory = proc(item_id: u32, amount: u32) {},
                dialogue_id = SENTRY,
                should_free_dialogue = false,
                // Interestingly enough, if you don't have this definition here (and probably the others), when you enter a scene and run handle_input, it tells you there's a signature mismatch
                // TODO: Come up with a function return a default struct so you don't have to do this every time
                handle_input = proc(input: UserInput) {},
                current_chosen_inventory = SENTRY,
                current_input_number = SENTRY,
            })
        BLACKJACK_FSM.states[i] = scene_state_id

        if i == u32(BlackjackSceneStates.SayHello) {
            blackjack_scene_say_hello()
        } else if i == u32(BlackjackSceneStates.NoMoneyToPlay) {
            blackjack_scene_no_money_to_play()
        } else if i == u32(BlackjackSceneStates.AskToPlaceBet) {
            blackjack_scene_ask_to_place_bet()
        } else if i == u32(BlackjackSceneStates.AskToConfirmBet) {
            blackjack_scene_ask_to_confirm_bet()
        } else if i == u32(BlackjackSceneStates.DealFirstCards) {
            blackjack_scene_deal_first_cards()
        } else if i == u32(BlackjackSceneStates.AskPlayerToHitOrStand) {
            blackjack_scene_ask_player_to_hit_or_stand()
        }
    }
}

blackjack_scene_say_hello :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.SayHello))
    default_state.name_id = find_string_id_by_machine_name("welcome_to_blackjack")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.SayHello))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("welcome_to_blackjack")
        current_game_mode = GameMode.In_Scene
        scene_state.current_choice = 0
    }
    // TODO: on_exit = if should_free_dialogue then free_string(dialogue_id)
    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.SayHello))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                scene_state.current_choice += 1
                if scene_state.current_choice >= scene_state.total_choices {
                    scene_state.current_choice = 0
                }
                should_redraw_everything()
            }
            case UserInput.Up: {
                if scene_state.current_choice == 0 {
                    scene_state.current_choice = scene_state.total_choices - 1
                } else {
                    scene_state.current_choice -= 1
                }
                should_redraw_everything()
            }
            case UserInput.A: {
                scene_state.make_choice(scene_state.current_choice)
            }
        }
    }
    state.make_choice = proc(choice: u32) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): {
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.AskToPlaceBet)
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToPlaceBet))
                default_scene_state.on_enter()
                should_redraw_everything()
            }
            case u32(BlackjackSceneChoices.Cancel): {
                current_game_mode = GameMode.In_Port
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_no_money_to_play :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.NoMoneyToPlay))
    default_state.name_id = find_string_id_by_machine_name("blackjack_no_money")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.NoMoneyToPlay))
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("blackjack_no_money")
        scene_state.current_choice = 0
    }

    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.NoMoneyToPlay))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                scene_state.current_choice += 1
                if scene_state.current_choice >= scene_state.total_choices {
                    scene_state.current_choice = 0
                }
                should_redraw_everything()
            }
            case UserInput.Up: {
                if scene_state.current_choice == 0 {
                    scene_state.current_choice = scene_state.total_choices - 1
                } else {
                    scene_state.current_choice -= 1
                }
                should_redraw_everything()
            }
            case UserInput.A: {
                scene_state.make_choice(scene_state.current_choice)
            }
        }
    }
    state.make_choice = proc(choice: u32) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        switch choice {
            case 0: {
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
            case 1: {
                current_game_mode = GameMode.In_Port
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_ask_to_place_bet :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToPlaceBet))
    default_state.name_id = find_string_id_by_machine_name("blackjack_place_bet")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToPlaceBet))
        // Number Input, Confirm, Cancel
        scene_state.total_choices = 3
        scene_state.dialogue_id = find_string_id_by_machine_name("blackjack_place_bet")
        scene_state.current_choice = 0
        scene_state.focused_on_choice = false
    }

    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToPlaceBet))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                if scene_state.focused_on_choice == false {
                    scene_state.current_choice += 1
                    if scene_state.current_choice >= scene_state.total_choices {
                        scene_state.current_choice = 0
                    }
                } else {
                    if scene_state.current_input_number > 0 {
                        scene_state.current_input_number -= 1
                    }
                    if scene_state.current_input_number == 0 {
                        scene_state.current_input_number = get_player().gold
                    }
                }
                should_redraw_everything()
            }
            case UserInput.Up: {
                if scene_state.focused_on_choice == false {
                    if scene_state.current_choice == 0 {
                        scene_state.current_choice = scene_state.total_choices - 1
                    } else {
                        scene_state.current_choice -= 1
                    }
                } else {
                    if scene_state.current_input_number + 1 > get_player().gold {
                        scene_state.current_input_number = get_player().gold
                    } else {
                        scene_state.current_input_number += 1
                    }
                }
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 0 {
                    scene_state.focused_on_choice = true
                } else {
                    if scene_state.current_choice == 1 {
                        if scene_state.current_input_number == 0 {
                            // TODO: State indicating you have to bet more than 0 gold
                        } else {
                            // TODO: Move to confirm bet
                        }
                    }
                    // TODO: Does the logic above belong here: scene_state.make_choice(scene_state.current_choice)
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                if scene_state.focused_on_choice {
                    scene_state.focused_on_choice = false
                } else {
                    default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                    default_scene_state.on_exit()
                    BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                    default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                    default_scene_state.on_enter()
                }
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.NumberInput)
            case 1: return u32(BlackjackSceneChoices.Confirm)
            case 2: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.NumberInput): return fsibmn("number_input")
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_ask_to_confirm_bet :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToConfirmBet))
    default_state.name_id = find_string_id_by_machine_name("blackjack_confirm_bet")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToConfirmBet))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("blackjack_confirm_bet")
        scene_state.current_choice = 0
    }
    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskToConfirmBet))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thingk
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 1 {
                    BET = input_number
                    // TODO: Move to "deal first cards state"
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_exit()
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_deal_first_cards :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealFirstCards))
    default_state.name_id = find_string_id_by_machine_name("empty")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealFirstCards))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("empty")
        scene_state.current_choice = 0

        blackjack_start_game()
    }
    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealFirstCards))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 1 {
                    // TODO: Move to ???
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_exit()
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_ask_player_to_hit_or_stand :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskPlayerToHitOrStand))
    default_state.name_id = find_string_id_by_machine_name("empty")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskPlayerToHitOrStand))
        // Hit, Stand
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("empty")
        scene_state.current_choice = 0

        if PLAYER_STANDING && !DEALER_STANDING {
            default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskPlayerToHitOrStand))
            default_state.on_exit()
            BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.DealerHitsOrStands)
            default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealerHitsOrStands))
            default_scene_state.on_enter()
        } else {
            default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskPlayerToHitOrStand))
            default_state.on_exit()
            BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.CheckForWinner)
            default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.CheckForWinner))
            default_scene_state.on_enter()
        }
    }

    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.AskPlayerToHitOrStand))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 0 {
                    blackjack_player_hit()
                    // TODO: Go to DealPlayerCard
                } else if scene_state.current_choice == 1 {
                    blackjack_player_stand()
                }
                should_redraw_everything()
            }
            // Note: B doesn't get you out of this. Once you're in, you're in
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Hit)
            case 1: return u32(BlackjackSceneChoices.Stand)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Hit): return fsibmn("blackjack_hit")
            case u32(BlackjackSceneChoices.Stand): return fsibmn("blackjack_stand")
        }
        return SENTRY
    }
}

blackjack_scene_dealer_hits_or_stands :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealerHitsOrStands))
    default_state.name_id = find_string_id_by_machine_name("empty")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealerHitsOrStands))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("empty")
        scene_state.current_choice = 0
    }
    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealerHitsOrStands))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 1 {
                    // TODO: Move to ???
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_exit()
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_deal_dealer_card :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealDealerCard))
    default_state.name_id = find_string_id_by_machine_name("empty")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealDealerCard))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("empty")
        scene_state.current_choice = 0
    }
    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.DealDealerCard))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 1 {
                    // TODO: Move to ???
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_exit()
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}

blackjack_scene_check_for_winner :: proc () {
    default_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.CheckForWinner))
    default_state.name_id = find_string_id_by_machine_name("empty")
    default_state.on_enter = proc() {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.CheckForWinner))
        // Confirm, Cancel
        scene_state.total_choices = 2
        scene_state.dialogue_id = find_string_id_by_machine_name("empty")
        scene_state.current_choice = 0
    }

    state := get_scene_finite_state_ref(BLACKJACK_FSM, u32(BlackjackSceneStates.CheckForWinner))
    state.handle_input = proc(input: UserInput) {
        scene_state := get_scene_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
        #partial switch input {
            case UserInput.Down: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.Up: {
                // TODO: Cursor choice thing
                should_redraw_everything()
            }
            case UserInput.A: {
                if scene_state.current_choice == 1 {
                    // TODO: Move to ???
                }
                should_redraw_everything()
            }
            case UserInput.B: {
                default_scene_state := get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_exit()
                BLACKJACK_FSM.current_state = u32(BlackjackSceneStates.SayHello)
                default_scene_state = get_scene_default_finite_state_ref(BLACKJACK_FSM, BLACKJACK_FSM.current_state)
                default_scene_state.on_enter()
                should_redraw_everything()
            }
        }
    }
    state.get_choice = proc(choice: u32) -> u32 {
        switch choice {
            case 0: return u32(BlackjackSceneChoices.Confirm)
            case 1: return u32(BlackjackSceneChoices.Cancel)
        }
        return SENTRY
    }
    state.choice_to_string_id = proc(choice: u32) -> u32 {
        switch choice {
            case u32(BlackjackSceneChoices.Confirm): return fsibmn("confirm")
            case u32(BlackjackSceneChoices.Cancel): return fsibmn("cancel")
        }
        return SENTRY
    }
}