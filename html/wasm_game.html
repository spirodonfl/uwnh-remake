<html>
    <head>
        <title>The Game</title>
        <link rel="stylesheet" type="text/css" href="wasm_game.css">
        <script src="js/game_strings.js"></script>
        <script src="js/structs.js"></script>
        <script src="js/consts.js"></script>
        <script src="js/dragElement.js"></script>
        <script type="text/javascript">
            var wasmBase64 = "<!-- WASM_FILE_HERE -->";
            // NOTE: Confirmed that if you open this file as file:// path, you CAN connect to a local websocket without security!

            var testArrayToBinDumper = function()
            {
                var data = [1, 2, 3, 4, 5, 69, 69420, 420, 666];
                var test_blob = new Blob(
                    [new Uint32Array(data)],
                    {type: 'application/octet-stream'}
                );
                var editorDownload = function (data, file_name)
                {
                    const link = document.createElement('a');
                    const url = window.URL.createObjectURL(data);

                    link.href = url;
                    link.download = file_name;
                    document.body.appendChild(link);
                    link.click();

                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                };
                editorDownload(test_blob, "rvice_sucks.bin");
            };

            function getRandomInt(max)
            {
                return Math.floor(Math.random() * max);
            }

            var importObject = {
                env: {
                    memory: new WebAssembly.Memory({
                        initial: 512,     // 200 pages = ~12.8MB
                        maximum: 2048     // 1000 pages = ~64MB
                    }),
                    js_console_log: function(ptr, len)
                    {
                        var bytes = new Uint8Array(
                            wasm.exports.memory.buffer,
                            ptr,
                            len
                        );
                        var message = new TextDecoder('utf-8').decode(bytes);
                        if (message.startsWith("STRUCT_"))
                        {
                            var data = message.substring(
                                message.indexOf('{'),
                                message.indexOf('}') + 1
                            );
                            console.log(data, JSON.parse(data));
                        }
                        console.log(message);
                    },
                }
            }

            function formatMemorySize(bytes)
            {
                const kb = bytes / 1024;
                const mb = kb / 1024;
                const gb = mb / 1024;
                
                if (gb >= 1) return `${gb.toFixed(2)} GB`;
                if (mb >= 1) return `${mb.toFixed(2)} MB`;
                if (kb >= 1) return `${kb.toFixed(2)} KB`;
                return `${bytes} Bytes`;
            }

            function is_sentry(value)
            {
                if (value !== wasm.exports.get_sentry() && value !== 4294967295)
                {
                    return false;
                }
                return true;
            }

            function get_layer_value(layer, x, y)
            {
                if (!is_sentry(layer.same_value))
                {
                    return layer.same_value;
                }
                return layer.data[(layer.width * y) + x];
            }

            var VIEWPORT =
            {
                width: 12,
                height: 12,
            };

            var CAMERA =
            {
                offset: {x: 0, y: 0},
                moveLeft: function ()
                {
                    this.offset.x -= 1;
                    if (this.offset.x < 0)
                    {
                        this.offset.x = 0;
                    }
                },
                moveRight: function ()
                {
                    this.offset.x += 1;
                    var max_offset_x = (WORLD[gh.current.world].width - (VIEWPORT.width / 2));
                    if (this.offset.x >= max_offset_x)
                    {
                        this.offset.x = max_offset_x - 1;
                    }
                },
                moveUp: function ()
                {
                    this.offset.y -= 1;
                    if (this.offset.y < 0)
                    {
                        this.offset.y = 0;
                    }
                },
                moveDown: function ()
                {
                    this.offset.y += 1;
                    var max_offset_y = (WORLD[gh.current.world].height - (VIEWPORT.height / 2));
                    if (this.offset.y >= max_offset_y)
                    {
                        this.offset.y = max_offset_y - 1;
                    }
                },
            };

            var ATLAS_IMAGE_SIZE = {x: 3008, y: 2304};
            var LAYER_ATLAS_MAP = {
                // Note: array values are "layer_value", "atlas-x", "atlas-y"
                "athens": {
                    "background_layer": [],
                    "layer_one":[],
                    "layer_two":[],
                    "npc_layer":[],
                },
                "dingus_land": {
                    "background_layer": [],
                    "layer_one":[],
                    "layer_two":[],
                    "npc_layer":[],
                },
            };
            LAYER_ATLAS_MAP["athens"]["background_layer"][1] = [0, 0];
            LAYER_ATLAS_MAP["athens"]["layer_one"][33] = [3, 1];
            LAYER_ATLAS_MAP["athens"]["layer_one"][34] = [33, 0];
            LAYER_ATLAS_MAP["athens"]["layer_one"][35] = [41, 0];
            LAYER_ATLAS_MAP["athens"]["layer_one"][36] = [28, 1];
            LAYER_ATLAS_MAP["athens"]["layer_one"][37] = [7, 1];
            LAYER_ATLAS_MAP["athens"]["layer_one"][38] = [32, 1];
            LAYER_ATLAS_MAP["athens"]["layer_one"][39] = [8, 1];
            LAYER_ATLAS_MAP["athens"]["layer_one"][40] = [46, 0];
            LAYER_ATLAS_MAP["athens"]["layer_one"][41] = [44, 0];
            LAYER_ATLAS_MAP["athens"]["layer_one"][50] = [16, 5];
            LAYER_ATLAS_MAP["athens"]["layer_one"][51] = [16, 6];
            LAYER_ATLAS_MAP["athens"]["layer_one"][52] = [16, 7];
            LAYER_ATLAS_MAP["athens"]["layer_one"][53] = [16, 4];
            LAYER_ATLAS_MAP["athens"]["layer_one"][54] = [24, 5];
            LAYER_ATLAS_MAP["athens"]["layer_one"][55] = [24, 7];
            LAYER_ATLAS_MAP["athens"]["layer_one"][56] = [24, 4];
            LAYER_ATLAS_MAP["athens"]["layer_one"][57] = [21, 8];
            LAYER_ATLAS_MAP["athens"]["layer_one"][58] = [24, 6];
            LAYER_ATLAS_MAP["athens"]["layer_one"][59] = [16, 3];
            LAYER_ATLAS_MAP["athens"]["layer_two"][69] = [12, 0];
            LAYER_ATLAS_MAP["athens"]["layer_two"][70] = [12, 0];
            LAYER_ATLAS_MAP["athens"]["layer_two"][71] = [18, 3];
            LAYER_ATLAS_MAP["athens"]["layer_two"][72] = [18, 4];
            // Building
            LAYER_ATLAS_MAP["athens"]["layer_one"][0] = [32, 4];
            LAYER_ATLAS_MAP["athens"]["layer_one"][1] = [33, 4];
            LAYER_ATLAS_MAP["athens"]["layer_one"][2] = [32, 5];
            LAYER_ATLAS_MAP["athens"]["layer_one"][3] = [33, 5];
            // Door
            LAYER_ATLAS_MAP["athens"]["layer_two"][4] = [34, 4];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][0] = [34, 1];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][1] = [35, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][2] = [36, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][3] = [35, 6];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][4] = [37, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][5] = [40, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][6] = [41, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][7] = [42, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][8] = [43, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][9] = [44, 2];
            LAYER_ATLAS_MAP["athens"]["npc_layer"][10] = [44, 2];
            LAYER_ATLAS_MAP["dingus_land"]["background_layer"][1] = [0, 0];
            LAYER_ATLAS_MAP["dingus_land"]["layer_one"][42] = [16, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["player_one"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["player_two"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["player_three"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["player_four"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["player_five"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["npc_blackbeard"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["npc_davey_jones"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["npc_kraken"] = [18, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_player_one"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_player_two"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_player_three"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_player_four"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_player_five"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_npc_blackbeard"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_npc_davey_jones"] = [20, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_npc_kraken"] = [18, 0];
            LAYER_ATLAS_MAP["dingus_land"]["npc_layer"]["ship_ship"] = [20, 0];
            var LAYER_COORDINATES_VALUE_HISTORY = [];
            var LAYER_COORDINATES_VALUE_UNDO_COUNTER = 0;
            var LAYER_COORDINATES_VALUE_REDO_COUNTER = 0;
            var STRINGS = [];
            STRINGS["DIALOG_NPC_RVICE"] = "Rvice: I no likey";
            STRINGS["DIALOG_NPC_LAFOLIE"] = "Lafolie: Lua, bruh";
            STRINGS["DIALOG_NPC_NAKOR"] = "Nakor: Have you even played a game before?";
            STRINGS["DIALOG_NPC_LOLLER"] = "Loller: My mom hurts me";
            STRINGS["DIALOG_NPC_TRAVIS"] = "Travis: You shall call me 'Chief Dingus GigaChad'";
            STRINGS["ITEM_TELESCOPE"] = "Telescope";
            STRINGS["ITEM_QUADRANT"] = "Quadrant";
            STRINGS["ITEM_THEODOLITE"] = "Theodolite";
            STRINGS["ITEM_SEXTANT"] = "Sextant";
            STRINGS["SCENE_GENERAL_SHOP"] = "Welcome to my shop. Have a look around.";
            STRINGS["SCENE_GENERAL_SHOP_THANK_YOU"] = "Thank you for your purchase. Go ahead and purchase more.";
            STRINGS["INVENTORY_TYPE_GENERAL_ITEM"] = "General Item";
            STRINGS["WORLD_ATHENS"] = "Athens";
            STRINGS["WORLD_DINGUS_LAND"] = "Dingus Land";
            STRINGS["LAYER_BACKGROUND"] = "Background";
            STRINGS["LAYER_ONE"] = "One";
            STRINGS["LAYER_TWO"] = "Two";
            STRINGS["LAYER_NPC"] = "NPC";
            STRINGS["LAYER_BLOCK"] = "Block";
            STRINGS["LAYER_ENTITY"] = "Entity";
            STRINGS["DIALOG_BANK_WELCOME"] = "Welcome to Digi Tal Bank. How can we help?";
            STRINGS["ACTION_BANK_DEPOSIT_SUCCESS"] = "We've deposited your gold into your account. Our deposit accounts accrue %d% per year.";
            STRINGS["BASE_SHIP_BALSA"] = "Balsa";
            STRINGS["BASE_SHIP_HANSA_COG"] = "Hansa Cog";
            STRINGS["SHIP_MATERIAL_TEAK"] = "Teak";
            var UNDERSTRINGS = [];
            UNDERSTRINGS["WORLD_ATHENS"] = "athens";
            UNDERSTRINGS["WORLD_DINGUS_LAND"] = "dingus_land";
            UNDERSTRINGS["NPC_PLAYER_ONE"] = "player_one";
            UNDERSTRINGS["NPC_PLAYER_TWO"] = "player_two";
            UNDERSTRINGS["NPC_PLAYER_THREE"] = "player_three";
            UNDERSTRINGS["NPC_PLAYER_FOUR"] = "player_four";
            UNDERSTRINGS["NPC_PLAYER_FIVE"] = "player_five";
            UNDERSTRINGS["NPC_OCEAN_BATTLE"] = "ocean_battle";
            UNDERSTRINGS["NPC_GENERAL_SHOP_OWNER"] = "general_shop_owner";
            UNDERSTRINGS["NPC_BANK_TELLER"] = "bank_teller";
            UNDERSTRINGS["NPC_BLACKJACK_PLAYER"] = "blackjack_player";
            UNDERSTRINGS["NPC_LOLLER"] = "loller";
            UNDERSTRINGS["NPC_RVICE"] = "rvice";
            UNDERSTRINGS["NPC_SHIP"] = "ship";
            UNDERSTRINGS["LAYER_BACKGROUND"] = "background";
            UNDERSTRINGS["LAYER_ONE"] = "one";
            UNDERSTRINGS["LAYER_TWO"] = "two";
            UNDERSTRINGS["LAYER_NPC"] = "npc";
            UNDERSTRINGS["LAYER_BLOCK"] = "block";
            UNDERSTRINGS["LAYER_ENTITY"] = "entity";
            var INVENTORY = [];
            var WORLD = [];
            var CAPTAIN = [];
            var BASE_SHIP = [];
            var NPC = [];
            var SHIP_MATERIAL = [];
            var GOOD = [];
            var ARMOR = [];
            var WEAPON = [];
            var SPECIAL_ITEM = [];
            var FIGUREHEAD = [];
            var CANNON = [];
            var FLEET = [];
            var LAYER = [];
            var PLAYER = {
                captain: null,
                previous_world_npc_id: null,
                world_npc: null,
                inventory: null,
                inventory_items: [],
                fleet: null,
                fleet_ships: [],
                stats: null,
                updateData: function ()
                {
                    PLAYER.captain = CAPTAIN[0];
                    // PLAYER.captain = new GAME_DATA_CAPTAIN(wasm.exports, [0]);
                    PLAYER.fleet = FLEET[PLAYER.captain.general_of_fleet_id];
                    // PLAYER.fleet = new GAME_DATA_FLEET(wasm.exports, [PLAYER.captain.general_of_fleet_id]);
                    PLAYER.inventory = INVENTORY[PLAYER.captain.inventory_id];
                    // PLAYER.inventory = new GAME_DATA_INVENTORY(wasm.exports, [PLAYER.captain.inventory_id]);
                    PLAYER.fleet_ships = [];
                    for (var s = 0; s < PLAYER.fleet.ship_ids.length; ++s)
                    {
                        if (!is_sentry(PLAYER.fleet.ship_ids[s]))
                        {
                            var fsid = PLAYER.fleet.ship_ids[s];
                            PLAYER.fleet_ships.push(
                                new GAME_DATA_FLEET_SHIP(wasm.exports, [fsid])
                            );
                        }
                    }
                    for (var f = 0; f < PLAYER.fleet_ships.length; ++f)
                    {
                        var fs = PLAYER.fleet_ships[f];
                        fs.name_game_string = GAME_STRINGS[fs.name_id];
                        fs.name_string = STRINGS[fs.name_game_string];
                        fs.ship = new GAME_DATA_SHIP(wasm.exports, [fs.ship_id]);
                        fs.ship.name_game_string = GAME_STRINGS[fs.ship.name_id];
                        fs.ship.name_string = STRINGS[fs.ship.name_game_string];
                        fs.ship.base_ship = new GAME_DATA_BASE_SHIP(wasm.exports, [fs.ship.base_ship_id]);
                        fs.ship.base_ship.name_game_string = GAME_STRINGS[fs.ship.base_ship.name_id];
                        fs.ship.base_ship.name_string = STRINGS[fs.ship.base_ship.name_game_string];
                    }
                    PLAYER.inventory_items = [];
                    for (var t = 0; t < PLAYER.inventory.inventory_items.length; ++t)
                    {
                        if (!is_sentry(PLAYER.inventory.inventory_items[t]))
                        {
                            var inventory_id = PLAYER.inventory.inventory_items[t];
                            PLAYER.inventory_items.push(
                                new GAME_DATA_INVENTORY_ITEM(wasm.exports, [inventory_id])
                            );
                            var last_index = PLAYER.inventory_items.length - 1;
                            var inventory_item = PLAYER.inventory_items[last_index];
                            inventory_item.name = STRINGS[GAME_STRINGS[inventory_item.name_id]];
                        }
                    }
                    PLAYER.stats = new GAME_DATA_STATS(wasm.exports, [PLAYER.captain.stats_id]);
                }
            };

            var UI_PLAYER_MENU =
            {
                // TODO: If you hit the start button while this is open, close it and free it up
                data: null,
                rendered: false,
                initialized: false,
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.initialized = true;
                    }
                },
                render: function ()
                {
                    // TODO: This probably runs here too often, honestly. Reduce runs
                    PLAYER.updateData();
                    if (!this.rendered)
                    {
                        var html = `<div id="player_menu"
                            style="max-width: fit-content;
                            position: absolute;
                            top: 0px;
                            background-color: rgba(0, 0, 0, 0.7);
                            padding: 10px;">`;
                        html += `<div>Gold: ${wasm.exports.get_player_gold(0)}</div>`;
                        html += `<div>${PLAYER.inventory.total_items} Items In Inventory</div>`;
                        for (var i = 0; i < PLAYER.inventory_items.length; ++i)
                        {
                            if (!is_sentry(PLAYER.inventory_items[i]))
                            {
                                var ii = PLAYER.inventory_items[i];
                                html += `<div>${ii.name} [${ii.number_held}]</div>`;
                            }
                        }
                        html += `<div>Player Stats</div>`;
                        html += `<div>- Leadership: ${PLAYER.stats.leadership}</div>`;
                        html += `<div>- Seamanship: ${PLAYER.stats.seamanship}</div>`;
                        html += `<div>------</div>`;
                        html += `<div>Ships In Fleet: ${PLAYER.fleet.total_ships}</div>`;
                        for (var i = 0; i < PLAYER.fleet_ships.length; ++i)
                        {
                            if (!is_sentry(PLAYER.fleet_ships[i]))
                            {
                                var fi = PLAYER.fleet_ships[i];
                                html += `<div>${fi.name_string}</div>`;
                                html += `<div>- Total Cargo Items: ${fi.ship.total_cargo_goods}</div>`;
                                html += `<div>- Tacking: ${fi.ship.tacking}</div>`;
                                html += `<div>- Power: ${fi.ship.power}</div>`;
                                html += `<div>- Speed: ${fi.ship.speed}</div>`;
                            }
                        }
                        // TODO: Go look at goods across all ships (lay out which ships goods are in)
                        // TODO: View captains along with you (skills, assignments, ship captaining, monthly wage)
                        // TODO: General things like -> total monthly costs (crew + captains) or ships that need repairs or low on supplies
                        // TODO: Personal stats
                        // TODO: Equipped armor / weapons
                        // TODO: Any special items you can use or special actions to take?
                        html += `<div><button class="red" onclick="UI_PLAYER_MENU.exit();">Exit</button></div>`;
                        html += `</div>`;
                        document.getElementById("player_menu").outerHTML = html;
                        this.rendered = true;
                    }
                },
                exit: function ()
                {
                    document.getElementById("player_menu").outerHTML = `<div id="player_menu"></div>`;
                    gh.current.game_mode = GAME_STRINGS.indexOf("GAME_MODE_IN_PORT");
                    this.rendered = false;
                }
            }

            var UI_OCEAN_BATTLE =
            {
                data: {
                    scene: null,
                    battle: null,
                    original_coords:
                    {
                        x: null, y: null
                    },
                },
                animating_cannons: false,
                animating_boarding: false,
                current_world_npc: false,
                current_world_npc_id: false,
                initialized: false,
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.initialized = true;
                        this.data.scene = new GAME_DATA_SCENE_OCEAN_BATTLE(wasm.exports);
                        this.data.battle = new GAME_DATA_OCEAN_BATTLE(wasm.exports);
                        this.render();
                    }
                },
                hide: function ()
                {
                    document.getElementById("ocean_battle").outerHTML = `<div id="ocean_battle"></div>`;
                    this.initialized = false;
                },
                render: function ()
                {
                    wasm.exports.ob_get_in_range();
                    var captains_html = ``;
                    for (var i = 0; i < this.data.battle.turn_order_fleets.length; ++i)
                    {
                        // Assumption is a linear layout with no gaps
                        if (is_sentry(this.data.battle.turn_order_fleets[i]))
                        {
                            break;
                        }
                        var fleet_id = this.data.battle.turn_order_fleets[i];
                        var fleet = new GAME_DATA_FLEET(wasm.exports, [fleet_id]);
                        var general_id = fleet.general_id;
                        var captain = new GAME_DATA_CAPTAIN(wasm.exports, [general_id]);
                        captains_html += `
                        <div>Captain: ${captain.getName()}</div>
                        `;
                    }
                    var ships_html = ``;
                    var players_turn = false;
                    for (var i = 0; i < this.data.battle.turn_order_ships.length; ++i)
                    {
                        // Assumption is a linear layout with no gaps
                        if (is_sentry(this.data.battle.turn_order_ships[i]))
                        {
                            break;
                        }
                        var fleet_ship_id = this.data.battle.turn_order_fleet_ships[i];
                        var ship_id = this.data.battle.turn_order_ships[i];
                        var wnpc_id = this.data.battle.turn_order_world_npcs[i];
                        var ship = new GAME_DATA_SHIP(wasm.exports, [ship_id]);
                        var wnpc = new GAME_DATA_WORLD_NPC(wasm.exports, [wnpc_id]);
                        var fleet_ship = new GAME_DATA_FLEET_SHIP(wasm.exports, [fleet_ship_id]);
                        var fleet = new GAME_DATA_FLEET(wasm.exports, [fleet_ship.fleet_id]);
                        var onmouseover = `
                            this.style.cursor = 'pointer';
                            UI_OCEAN_BATTLE.highlightWorldNPC(${wnpc_id});
                        `;
                        var onmouseout = `UI_OCEAN_BATTLE.clearWorldNPCHighlights();`;
                        var style = ``;
                        if (i === this.data.battle.turn_order && fleet.general_id === 0)
                        {
                            players_turn = true;
                        }
                        if (i === this.data.battle.turn_order)
                        {
                            style = `color: rgb(255 217 0); border-left: 2px solid gold; padding-left: 6px;`;
                        }
                        ships_html += `
                            <div onmouseover="${onmouseover}" onmouseout="${onmouseout}" style="${style}">
                                Ship [${ship_id}]
                            </div>
                            <div style="${style}">Crew: ${ship.crew}/100 - <progress max="100" value="${ship.crew}" /></div>
                            <div style="${style}">Hull: ${ship.hull}/100 - <progress max="100" value="${ship.hull}" /></div>
                        `;
                    }
                    var buttons = ``;
                    if (this.data.battle.victory)
                    {
                        if (this.data.battle.player_victory)
                        {
                            buttons += `<button onclick="UI_OCEAN_BATTLE.hide();">Claim Victory</button>`;
                        }
                        else
                        {
                            buttons += `<button>You Lost</button>`;
                        }
                    }
                    else if (players_turn)
                    {
                        buttons += `<button disable>Escape</button>`;
                        if (this.data.battle.moved !== 1)
                        {
                            buttons += `<button onclick="UI_OCEAN_BATTLE.highlightValidMoves();">Move</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_confirm_move"
                                onclick="UI_OCEAN_BATTLE.confirmMove();"
                                style="display: none;">Confirm Move</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_cancel_move"
                                onclick="UI_OCEAN_BATTLE.cancelMove();"
                                style="display: none;">Cancel Move</button>`;
                        }
                        if (this.data.battle.attacked !== 1)
                        {
                            buttons += `<button
                                onclick="UI_OCEAN_BATTLE.highlightValidCannons();"
                            >Fire Cannons</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_confirm_cannons"
                                onclick="UI_OCEAN_BATTLE.confirmCannons();"
                                style="display: none;">Confirm Cannons</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_cancel_cannons"
                                onclick="UI_OCEAN_BATTLE.cancelCannons();"
                                style="display: none;">Cancel Cannons</button>`;
                            buttons += `<button
                                onclick="UI_OCEAN_BATTLE.highlightValidBoarding();"
                            >Board</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_confirm_boarding"
                                onclick="UI_OCEAN_BATTLE.confirmBoarding();"
                                style="display: none;">Confirm Boarding</button>`;
                            buttons += `<button
                                id="ui_ocean_battle_cancel_boarding"
                                onclick="UI_OCEAN_BATTLE.cancelBoarding();"
                                style="display: none;">Cancel Boarding</button>`;
                        }
                        buttons += `<button disabled>Duel Captain</button>`;
                        buttons += `<button>Order Fleet</button>`;
                        buttons += `<button onclick="UI_OCEAN_BATTLE.endTurn();">End Turn</button>`;
                    }
                    else
                    {
                        buttons += `<button onclick="UI_OCEAN_BATTLE.takeNPCTurn();">Run NPCs Turn</button>`;
                    }
                    var html = `
<div id="ocean_battle" class="popup">
    <div class="outer_border" style="display: grid; grid-auto-flow: column;">
        <div id="ocean-battle-drag-handle" class="drag-bar svg svg-handle-bar-white"></div>
        <div>
            <div class="inner_text" style="margin-bottom: 6px;">
                Gonna fight!
            </div>
            <div id="battle_info" style="display: grid; grid-gap: 4px; margin-bottom: 6px;">
                <div>Total Fleets In Battle: ${this.data.battle.total_fleets}</div>
                <div>Total Ships In Battle: ${this.data.battle.total_ships}</div>
                ${captains_html}
                ${ships_html}
            </div>
            <div id="dialog_choices" style="display: grid; grid-auto-flow: row;">
                ${buttons}
            </div>
        </div>
    </div>
</div>`;
                    document.getElementById("ocean_battle").outerHTML = html;
                    dragElement(
                        document.getElementById("ocean_battle"),
                        document.getElementById("ocean-battle-drag-handle"),
                        { useBottomRight: true }
                    );
                },
                takeNPCTurn: function (move_anim_done, attack_anim_done)
                {
                    this.current_world_npc_id = UI_OCEAN_BATTLE.data.battle.turn_order_world_npcs[
                        UI_OCEAN_BATTLE.data.battle.turn_order
                    ];
                    this.current_world_npc = new GAME_DATA_WORLD_NPC(wasm.exports, [
                        this.current_world_npc_id
                    ]);
                    if (UI_OCEAN_BATTLE.data.battle.total_valid_cannon_coords === 0)
                    {
                        attack_anim_done = true;
                    }
                    if (
                        move_anim_done === undefined
                        &&
                        UI_OCEAN_BATTLE.data.battle.total_valid_move_coords > 0
                    )
                    {
                        if (UI_OCEAN_BATTLE.data.original_coords.x === null)
                        {
                            UI_OCEAN_BATTLE.data.original_coords.x = UI_OCEAN_BATTLE.current_world_npc.position_x;
                            UI_OCEAN_BATTLE.data.original_coords.y = UI_OCEAN_BATTLE.current_world_npc.position_y;
                        }
                        var intended_move_x = UI_OCEAN_BATTLE.data.battle.intended_move_coords[0];
                        var intended_move_y = UI_OCEAN_BATTLE.data.battle.intended_move_coords[1];
                        // console.log("Moving ship from/to", {
                        //     start_x: UI_OCEAN_BATTLE.data.original_coords.x,
                        //     start_y: UI_OCEAN_BATTLE.data.original_coords.y,
                        //     end_x: intended_move_x,
                        //     end_y: intended_move_y,
                        //     available_coords: UI_OCEAN_BATTLE.data.battle.valid_move_coords,
                        // });
                        animateOceanBattleMove.reset();
                        animateOceanBattleMove.start.x = UI_OCEAN_BATTLE.data.original_coords.x;
                        animateOceanBattleMove.start.x *= TILE_SIZE_SCALED;
                        animateOceanBattleMove.start.y = UI_OCEAN_BATTLE.data.original_coords.y;
                        animateOceanBattleMove.start.y *= TILE_SIZE_SCALED;
                        animateOceanBattleMove.current.x = animateOceanBattleMove.start.x;
                        animateOceanBattleMove.current.y = animateOceanBattleMove.start.y;
                        animateOceanBattleMove.end.x = intended_move_x;
                        animateOceanBattleMove.end.x *= TILE_SIZE_SCALED;
                        animateOceanBattleMove.end.y = intended_move_y;
                        animateOceanBattleMove.end.y *= TILE_SIZE_SCALED;
                        animateOceanBattleMove.callbacks.push(UI_OCEAN_BATTLE.takeNPCTurn.bind(null, true));
                        animateOceanBattleMove.callbacks.push(function () {
                            UI_OCEAN_BATTLE.current_world_npc.position_x = intended_move_x;
                            UI_OCEAN_BATTLE.current_world_npc.position_y = intended_move_y;
                        }.bind(null));
                        if (uih.animations.indexOf(animateOceanBattleMove) < 0)
                        {
                            uih.animations.push(animateOceanBattleMove);
                        }
                    }
                    else if (
                        attack_anim_done === undefined
                        &&
                        UI_OCEAN_BATTLE.data.battle.total_valid_cannon_coords > 0
                    )
                    {
                        var start_x, start_y;
                        if (!is_sentry(UI_OCEAN_BATTLE.data.battle.intended_move_coords[0]))
                        {
                            start_x = UI_OCEAN_BATTLE.data.battle.intended_move_coords[0];
                            start_y = UI_OCEAN_BATTLE.data.battle.intended_move_coords[1];
                        }
                        else
                        {
                            start_x = UI_OCEAN_BATTLE.current_world_npc.position_x;
                            start_y = UI_OCEAN_BATTLE.current_world_npc.position_y;
                        }
                        var intended_cannon_x = UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[0];
                        var intended_cannon_y = UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[1];
                        animateOceanBattleCannon.reset();
                        animateOceanBattleCannon.start.x = start_x;
                        animateOceanBattleCannon.start.x *= TILE_SIZE_SCALED;
                        animateOceanBattleCannon.start.y = start_y;
                        animateOceanBattleCannon.start.y *= TILE_SIZE_SCALED;
                        animateOceanBattleCannon.current.x = animateOceanBattleCannon.start.x;
                        animateOceanBattleCannon.current.y = animateOceanBattleCannon.start.y;
                        animateOceanBattleCannon.end.x = intended_cannon_x * TILE_SIZE_SCALED;
                        animateOceanBattleCannon.end.y = intended_cannon_y * TILE_SIZE_SCALED;
                        if (UI_OCEAN_BATTLE.data.battle.total_valid_move_coords === 0)
                        {
                            move_anim_done = true;
                        }
                        animateOceanBattleCannon.callbacks.push(UI_OCEAN_BATTLE.takeNPCTurn.bind(null, move_anim_done, true));
                        if (uih.animations.indexOf(animateOceanBattleCannon) < 0)
                        {
                            uih.animations.push(animateOceanBattleCannon);
                        }
                    }
                    else if (
                        attack_anim_done === undefined
                        &&
                        UI_OCEAN_BATTLE.data.battle.total_valid_boarding_coords > 0
                    )
                    {
                        var start_x, start_y;
                        if (!is_sentry(UI_OCEAN_BATTLE.data.battle.intended_move_coords[0]))
                        {
                            start_x = UI_OCEAN_BATTLE.data.battle.intended_move_coords[0];
                            start_y = UI_OCEAN_BATTLE.data.battle.intended_move_coords[1];
                        }
                        else
                        {
                            start_x = UI_OCEAN_BATTLE.current_world_npc.position_x;
                            start_y = UI_OCEAN_BATTLE.current_world_npc.position_y;
                        }
                        var intended_boarding_x = UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[0];
                        var intended_boarding_y = UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[1];
                        animateOceanBattleBoarding.reset();
                        animateOceanBattleBoarding.start.x = start_x * TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.start.y = start_y * TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.current.x = animateOceanBattleBoarding.start.x;
                        animateOceanBattleBoarding.current.y = animateOceanBattleBoarding.start.y;
                        animateOceanBattleBoarding.end.x = intended_boarding_x * TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.end.y = intended_boarding_y * TILE_SIZE_SCALED;
                        if (UI_OCEAN_BATTLE.data.battle.total_valid_move_coords === 0)
                        {
                            move_anim_done = true;
                        }
                        animateOceanBattleBoarding.callbacks.push(UI_OCEAN_BATTLE.takeNPCTurn.bind(null, move_anim_done, true));
                        if (uih.animations.indexOf(animateOceanBattleBoarding) < 0)
                        {
                            uih.animations.push(animateOceanBattleBoarding);
                        }
                    }
                    else if (move_anim_done === true && attack_anim_done === true)
                    {
                        wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("OCEAN_BATTLE_RUN_NPC_TURN"));
                        UI_OCEAN_BATTLE.data.original_coords.x = null;
                        UI_OCEAN_BATTLE.data.original_coords.y = null;
                        UI_OCEAN_BATTLE.render();
                    }
                },
                endTurn: function ()
                {
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("OCEAN_BATTLE_END_TURN"));
                    this.data.original_coords.x = null;
                    this.data.original_coords.y = null;
                    UI_OCEAN_BATTLE.render();
                },
                highlightWorldNPC: function (wnpc_id)
                {
                    uih.highlightNPCID = wnpc_id;
                },
                clearWorldNPCHighlights: function ()
                {
                    uih.highlightNPCID = false;
                },
                highlightValidMoves: function()
                {
                    if (uih.animations.indexOf(animateOceanBattleMoveCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleMoveCoords);
                    }
                },
                moveWorldNPCTo: function (x, y)
                {
                    var wnpcid = this.data.battle.turn_order_world_npcs[this.data.battle.turn_order];
                    if (this.data.original_coords.x === null)
                    {
                        var wnpc = new GAME_DATA_WORLD_NPC(wasm.exports, [wnpcid]);
                        this.data.original_coords.x = wnpc.position_x;
                        this.data.original_coords.y = wnpc.position_y;
                    }
                    wasm.exports.move_world_npc_to(wnpcid, x, y);
                    this.data.battle.intended_move_coords[0] = x;
                    this.data.battle.intended_move_coords[1] = y;
                    document.getElementById("ui_ocean_battle_confirm_move").style.display = "block";
                    document.getElementById("ui_ocean_battle_cancel_move").style.display = "block";
                    if (uih.animations.indexOf(animateOceanBattleMoveIntendedCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleMoveIntendedCoords);
                    }
                },
                endMove: function ()
                {
                    for (var i = (uih.animations.length - 1); i >= 0; --i)
                    {
                        if (
                            uih.animations[i].type
                            &&
                            uih.animations[i].type === "ocean_battle"
                        )
                        {
                            uih.animations.splice(i, 1);
                        }
                    }
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("OCEAN_BATTLE_MOVE"));
                    UI_OCEAN_BATTLE.render();
                },
                confirmMove: function ()
                {
                    this.current_world_npc_id = UI_OCEAN_BATTLE.data.battle.turn_order_world_npcs[
                        UI_OCEAN_BATTLE.data.battle.turn_order
                    ];
                    this.current_world_npc = new GAME_DATA_WORLD_NPC(wasm.exports, [
                        this.current_world_npc_id
                    ]);
                    wasm.exports.move_world_npc_to(
                        this.current_world_npc_id,
                        this.data.original_coords.x,
                        this.data.original_coords.y
                    );
                    var intended_move_x = this.data.battle.intended_move_coords[0];
                    var intended_move_y = this.data.battle.intended_move_coords[1];
                    animateOceanBattleMove.reset();
                    animateOceanBattleMove.start.x = this.data.original_coords.x;
                    animateOceanBattleMove.start.x *= TILE_SIZE_SCALED;
                    animateOceanBattleMove.start.y = this.data.original_coords.y;
                    animateOceanBattleMove.start.y *= TILE_SIZE_SCALED;
                    animateOceanBattleMove.current.x = animateOceanBattleMove.start.x;
                    animateOceanBattleMove.current.y = animateOceanBattleMove.start.y;
                    animateOceanBattleMove.end.x = intended_move_x * TILE_SIZE_SCALED;
                    animateOceanBattleMove.end.y = intended_move_y * TILE_SIZE_SCALED;
                    if (uih.animations.indexOf(animateOceanBattleMove) < 0)
                    {
                        uih.animations.push(animateOceanBattleMove);
                    }
                    animateOceanBattleMove.callbacks.push(UI_OCEAN_BATTLE.endMove.bind(null));
                },
                cancelMove: function ()
                {
                    this.data.battle.intended_move_coords[0] = wasm.exports.get_sentry();
                    this.data.battle.intended_move_coords[1] = wasm.exports.get_sentry();
                    var wnpcid = this.data.battle.turn_order_world_npcs[this.data.battle.turn_order];
                    wasm.exports.move_world_npc_to(
                        wnpcid,
                        this.data.original_coords.x,
                        this.data.original_coords.y
                    );
                    document.getElementById("ui_ocean_battle_confirm_move").style.display = "none";
                    document.getElementById("ui_ocean_battle_cancel_move").style.display = "none";
                    for (var i = (uih.animations.length - 1); i >= 0; --i)
                    {
                        if (
                            uih.animations[i].type
                            &&
                            uih.animations[i].type === "ocean_battle"
                        )
                        {
                            uih.animations.splice(i, 1);
                        }
                    }
                },
                highlightValidCannons: function()
                {
                    if (uih.animations.indexOf(animateOceanBattleCannonCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleCannonCoords);
                    }
                    document.getElementById("ui_ocean_battle_cancel_cannons").style.display = "block";
                },
                setCannonsTo: function(x, y)
                {
                    this.data.battle.intended_cannon_coords[0] = x;
                    this.data.battle.intended_cannon_coords[1] = y;
                    document.getElementById("ui_ocean_battle_confirm_cannons").style.display = "block";
                    document.getElementById("ui_ocean_battle_cancel_cannons").style.display = "block";
                    if (uih.animations.indexOf(animateOceanBattleCannonIntendedCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleCannonIntendedCoords);
                    }
                },
                confirmCannons: function (animation_done)
                {
                    this.current_world_npc_id = UI_OCEAN_BATTLE.data.battle.turn_order_world_npcs[
                        UI_OCEAN_BATTLE.data.battle.turn_order
                    ];
                    this.current_world_npc = new GAME_DATA_WORLD_NPC(wasm.exports, [
                        this.current_world_npc_id
                    ]);
                    if (animation_done === undefined)
                    {
                        var intended_cannon_x = UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[0];
                        var intended_cannon_y = UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[1];
                        animateOceanBattleCannon.reset();
                        animateOceanBattleCannon.start.x = this.current_world_npc.position_x;
                        animateOceanBattleCannon.start.x *= TILE_SIZE_SCALED;
                        animateOceanBattleCannon.start.y = this.current_world_npc.position_y;
                        animateOceanBattleCannon.start.y *= TILE_SIZE_SCALED;
                        animateOceanBattleCannon.current.x = animateOceanBattleCannon.start.x;
                        animateOceanBattleCannon.current.y = animateOceanBattleCannon.start.y;
                        animateOceanBattleCannon.end.x = intended_cannon_x * TILE_SIZE_SCALED;
                        animateOceanBattleCannon.end.y = intended_cannon_y * TILE_SIZE_SCALED;
                        animateOceanBattleCannon.callbacks.push(UI_OCEAN_BATTLE.confirmCannons.bind(null, true));
                        uih.animations.push(animateOceanBattleCannon);
                    }
                    else if (animation_done === true)
                    {
                        // Note: If you're going to splice, do it in reverse so the indexes don't eff you up
                        for (var i = (uih.animations.length - 1); i >= 0; --i)
                        {
                            if (
                                uih.animations[i].type
                                &&
                                uih.animations[i].type === "ocean_battle"
                            )
                            {
                                uih.animations.splice(i, 1);
                            }
                        }
                        wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("OCEAN_BATTLE_FIRE_CANNONS"));
                        UI_OCEAN_BATTLE.render();
                    }
                },
                cancelCannons: function ()
                {
                    this.data.battle.intended_cannon_coords[0] = wasm.exports.get_sentry();
                    this.data.battle.intended_cannon_coords[1] = wasm.exports.get_sentry();
                    document.getElementById("ui_ocean_battle_confirm_cannons").style.display = "none";
                    document.getElementById("ui_ocean_battle_cancel_cannons").style.display = "none";
                    for (var i = (uih.animations.length - 1); i >= 0; --i)
                    {
                        if (
                            uih.animations[i].type
                            &&
                            uih.animations[i].type === "ocean_battle"
                        )
                        {
                            uih.animations.splice(i, 1);
                        }
                    }
                },
                highlightValidBoarding: function()
                {
                    if (uih.animations.indexOf(animateOceanBattleBoardingCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleBoardingCoords);
                    }
                },
                setBoardingTo: function(x, y)
                {
                    this.data.battle.intended_boarding_coords[0] = x;
                    this.data.battle.intended_boarding_coords[1] = y;
                    document.getElementById("ui_ocean_battle_confirm_boarding").style.display = "block";
                    document.getElementById("ui_ocean_battle_cancel_boarding").style.display = "block";
                    if (uih.animations.indexOf(animateOceanBattleBoardingIntendedCoords) < 0)
                    {
                        uih.animations.push(animateOceanBattleBoardingIntendedCoords);
                    }
                },
                confirmBoarding: function (animation_done)
                {
                    this.current_world_npc_id = UI_OCEAN_BATTLE.data.battle.turn_order_world_npcs[
                        UI_OCEAN_BATTLE.data.battle.turn_order
                    ];
                    this.current_world_npc = new GAME_DATA_WORLD_NPC(wasm.exports, [
                        this.current_world_npc_id
                    ]);
                    if (animation_done === undefined)
                    {
                        var intended_boarding_x = UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[0];
                        var intended_boarding_y = UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[1];
                        animateOceanBattleBoarding.reset();
                        animateOceanBattleBoarding.start.x = this.current_world_npc.position_x;
                        animateOceanBattleBoarding.start.x *= TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.start.y = this.current_world_npc.position_y;
                        animateOceanBattleBoarding.start.y *= TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.current.x = animateOceanBattleBoarding.start.x;
                        animateOceanBattleBoarding.current.y = animateOceanBattleBoarding.start.y;
                        animateOceanBattleBoarding.end.x = intended_boarding_x * TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.end.y = intended_boarding_y * TILE_SIZE_SCALED;
                        animateOceanBattleBoarding.callbacks.push(UI_OCEAN_BATTLE.confirmBoarding.bind(null, true));
                        uih.animations.push(animateOceanBattleBoarding);
                    }
                    else if (animation_done === true)
                    {
                        // Note: If you're going to splice, do it in reverse so the indexes don't eff you up
                        for (var i = (uih.animations.length - 1); i >= 0; --i)
                        {
                            if (
                                uih.animations[i].type
                                &&
                                uih.animations[i].type === "ocean_battle"
                            )
                            {
                                uih.animations.splice(i, 1);
                            }
                        }
                        wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("OCEAN_BATTLE_BOARD"));
                        UI_OCEAN_BATTLE.render();
                    }
                },
                cancelBoarding: function ()
                {
                    this.data.battle.intended_boarding_coords[0] = wasm.exports.get_sentry();
                    this.data.battle.intended_boarding_coords[1] = wasm.exports.get_sentry();
                    document.getElementById("ui_ocean_battle_confirm_boarding").style.display = "none";
                    document.getElementById("ui_ocean_battle_cancel_boarding").style.display = "none";
                    for (var i = (uih.animations.length - 1); i >= 0; --i)
                    {
                        if (
                            uih.animations[i].type
                            &&
                            uih.animations[i].type === "ocean_battle"
                        )
                        {
                            uih.animations.splice(i, 1);
                        }
                    }
                },
            }

            var UI_SCENE_SINGLE_DIALOG =
            {
                initialized: false,
                rendered: false,
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.initialized = true;
                        this.rendered = false;
                    }
                },
                render: function ()
                {
                    if (this.rendered) { return; }
                    this.rendered = true;
                    var dialog_id = wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION"));
                    var game_string = GAME_STRINGS[dialog_id];
                    if (!STRINGS[game_string])
                    {
                        console.error(`Could not find string in strings [${game_string}]`);
                    }
                    var html = `
                    <div id="scene_single_dialog" style="max-width: fit-content; position: absolute; top: 0px;">
                        <div class="outer_border">
                            <div class="inner_text">
                                ${STRINGS[game_string]}
                            </div>
                            <div id="dialog_choices">
                                <button class="green" onclick="UI_SCENE_SINGLE_DIALOG.exit();">Ok</button>
                            </div>
                        </div>
                    </div>
                    `;
                    document.getElementById("scene_single_dialog").outerHTML = html;
                },
                exit: function()
                {
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_CONFIRM"));
                    document
                        .getElementById("scene_single_dialog")
                        .outerHTML = `<div id="scene_single_dialog"></div>`;
                    this.initialized = false;
                },
            }

            class UI_SHIPYARD extends HTMLElement
            {
                constructor()
                {
                    super();
                    this.data = {
                        scene: null,
                        ships_prefab: [],
                    };
                    this.initialized = false;
                    this.rendered = false;
                }
                initialize()
                {
                    if (!this.initialized)
                    {
                        this.initialized = true;
                        this.rendered = false;
                        this.data.scene = new GAME_DATA_SCENE_SHIPYARD(wasm.exports);
                        for (var i = 0; i < this.data.scene.ships_prefab.length; ++i)
                        {
                            var ship_id = this.data.scene.ships_prefab[i];
                            if (!is_sentry(ship_id))
                            {
                                this.data.ships_prefab[i] = new GAME_DATA_SHIP(wasm.exports, [ship_id]);
                            }
                        }
                        this.render();
                    }
                }
                render()
                {
                    if (this.rendered) { return; }
                    this.rendered = true;
                    var html = `
                    <div id="shipyard" class="popup topleft">
                        <div class="outer_border">
                            <div class="inner_text">
                                Welcome to the shipyard. How can I help you?
                            </div>
                            <div id="dialog_choices">
                                <button class="positive" onclick="document.querySelector('ui-shipyard').buyUsedShip();">Buy Used Ship</button>
                                <button class="positive">Build New Ship</button>
                                <button class="positive">Remodel</button>
                                <button class="neutral">Sell Ship</button>
                                <button class="negative" onclick="document.querySelector('ui-shipyard').exit();">Cancel</button>
                            </div>
                        </div>
                    </div>
                    `;
                    this.innerHTML = html;
                }
                buyUsedShip()
                {
                    var dialog = `Which ship would you like to buy?`;
                    if (this.data.scene.dialog_id === GAME_STRINGS.indexOf("DIALOG_SHIPYARD_PREFAB_PURCHASE_SUCCESS"))
                    {
                        dialog = `You have purchased a ship!`;
                    }
                    var used_ships_list = ``;
                    for (var i = 0; i < this.data.ships_prefab.length; ++i)
                    {
                        if (this.data.ships_prefab[i] === undefined) { continue; }
                        var ship = this.data.ships_prefab[i];
                        if (is_sentry(ship.id))
                        {
                            continue;
                        }
                        ship = new GAME_DATA_SHIP(wasm.exports, [ship.id]);
                        var base_ship = new GAME_DATA_BASE_SHIP(wasm.exports, [
                            ship.base_ship_id
                        ]);
                        var top_material = new GAME_DATA_SHIP_MATERIAL(
                            wasm.exports,
                            [
                                ship.top_material_id
                            ]
                        );
                        var ship_material = new GAME_DATA_SHIP_MATERIAL(
                            wasm.exports,
                            [
                                ship.ship_material_id
                            ]
                        );
                        var onclick = `
                            document.querySelector('ui-shipyard').buyShip(${i});
                        `;
                        used_ships_list += `
                            <div>${ship.getName()}</div>
                            <div>${ship.price}</div>
                            <div>
                                <button 
                                    onclick="${onclick}"
                                >Buy</button>
                            </div>
                            <div>${top_material.getName()}</div>
                            <div>${ship_material.getName()}</div>
                            <div>${ship.speed}</div>
                            <div>${base_ship.max_capacity}</div>
                            <div>${ship.capacity}</div>
                            <div>${ship.tacking}</div>
                            <div>${ship.power}</div>
                            <div>${ship.durability}</div>
                            <div>${ship.crew_space}</div>
                            <div>${ship.cargo_space}</div>
                            <div>${ship.cannon_space}</div>
                        `;
                    }
                    var html = `
                    <div id="shipyard" class="popup topleft">
                        <div class="outer_border">
                            <div class="inner_text">
                                Which ship would you like to buy?
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(14, max-content); grid-gap: 10px;">
                                <style>.padded_header{ background-color: rgba(30, 30, 30, 0.6); padding: 4px; }</style>
                                <div class="padded_header">Name</div>
                                <div class="padded_header">Price</div>
                                <div>&nbsp;</div>
                                <div class="padded_header">Top Material</div>
                                <div class="padded_header">Material</div>
                                <div class="padded_header">Speed</div>
                                <div class="padded_header">Max Capacity</div>
                                <div class="padded_header">Capacity</div>
                                <div class="padded_header">Tacking</div>
                                <div class="padded_header">Power</div>
                                <div class="padded_header">Durability</div>
                                <div class="padded_header">Crew Space</div>
                                <div class="padded_header">Cargo Space</div>
                                <div class="padded_header">Cannon Space</div>
                                ${used_ships_list}
                            </div>
                            <div id="dialog_choices">
                                <button 
                                    class="negative"
                                    onclick="
                                        document.querySelector('ui-shipyard').rendered = false;
                                        document.querySelector('ui-shipyard').render();
                                    "
                                >Cancel</button>
                            </div>
                        </div>
                    </div>
                    `;
                    this.innerHTML = html;
                }
                buyShip(prefab_ship_id)
                {
                    this.data.scene.buying_prefab_ship_id = prefab_ship_id;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_SHIPYARD_BUY_USED"));
                }
                exit()
                {
                    this.data.ships_prefab = [];
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_EXIT"));
                    this.innerHTML = ``;
                    this.initialized = false;
                }
            }
            customElements.define("ui-shipyard", UI_SHIPYARD);

            var UI_BLACKJACK =
            {
                data: null,
                initialized: false,
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.initialized = true;
                    }
                },
                render: function ()
                {
                    /*
                    <div id="blackjack" style="width: 400px;">
                        <div id="bj_dialog">
                            Dealer says stuff here
                        </div>
                        <div id="bj_bet">
                            Bet <input type="number" id="bet_number" style="width: 60px;" />
                        </div>
                        <div id="bj_table">
                            <div style="display: grid; grid-auto-flow: column;">
                                <div>Player</div>
                                <div style="display: grid; grid-auto-flow: column;">
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                </div>
                            </div>
                            <div style="display: grid; grid-auto-flow: column;">
                                <div>Dealer</div>
                                <div style="display: grid; grid-auto-flow: column;">
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                    <div class="bj_card">K</div>
                                </div>
                            </div>
                        </div>
                        <div class="info" style="display: grid; grid-auto-flow: column;">
                            <div>Player:</div><div>110</div><div>Dealer:</div><div>110</div>
                        </div>
                        <div class="actions">
                            <button class="green">Place Bet</button>
                            <button class="blue">Hit</button>
                            <button class="blue">Stand</button>
                            <button class="red">Cancel</button>
                        </div>
                    </div>*/
                },
                exit: function ()
                {
                },
            }

            var UI_BANK =
            {
                data: {
                    scene: null,
                    bank: null,
                },
                rendered: false,
                initialized: false,
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.data = {
                            scene: new GAME_DATA_SCENE_BANK(wasm.exports),
                            bank: new GAME_DATA_BANK(wasm.exports),
                        };
                        this.initialized = true;
                        this.rendered = false;
                    }
                },
                deposit: function ()
                {
                    var amount = document.getElementById("bank").querySelector("#bank_input_number").value;
                    this.data.bank.to_deposit = amount;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_BANK_DEPOSIT"));
                    if (!is_sentry(this.data.scene.error_code))
                    {
                        // ERROR_BANK_NOT_ENOUGH_DEPOSIT
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_NOT_ENOUGH_WITHDRAW
                        // ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT
                        // ERROR_BANK_PAY_EXISTING_LOAN_FIRST
                        // ERROR_BANK_NOT_ENOUGH_LOAN
                        // ERROR_BANK_TOO_MUCH_LOAN
                        // ERROR_BANK_NO_LOAN
                        // ERROR_BANK_PAY_LOAN_NOT_ENOUGH
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN
                    }
                    // So we can force a one time rerender
                    this.rendered = false;
                    this.render();
                },
                takeLoan: function ()
                {
                    var amount = document.getElementById("bank").querySelector("#bank_input_number").value;
                    this.data.bank.to_loan = amount;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_BANK_TAKE_LOAN"));
                    if (!is_sentry(this.data.scene.error_code))
                    {
                        // ERROR_BANK_NOT_ENOUGH_DEPOSIT
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_NOT_ENOUGH_WITHDRAW
                        // ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT
                        // ERROR_BANK_PAY_EXISTING_LOAN_FIRST
                        // ERROR_BANK_NOT_ENOUGH_LOAN
                        // ERROR_BANK_TOO_MUCH_LOAN
                        // ERROR_BANK_NO_LOAN
                        // ERROR_BANK_PAY_LOAN_NOT_ENOUGH
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN
                    }
                    // So we can force a one time rerender
                    this.rendered = false;
                    this.render();
                },
                payLoan: function ()
                {
                    var amount = document.getElementById("bank").querySelector("#bank_input_number").value;
                    this.data.bank.to_loan = amount;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_BANK_PAY_LOAN"));
                    if (!is_sentry(this.data.scene.error_code))
                    {
                        // ERROR_BANK_NOT_ENOUGH_DEPOSIT
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_NOT_ENOUGH_WITHDRAW
                        // ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT
                        // ERROR_BANK_PAY_EXISTING_LOAN_FIRST
                        // ERROR_BANK_NOT_ENOUGH_LOAN
                        // ERROR_BANK_TOO_MUCH_LOAN
                        // ERROR_BANK_NO_LOAN
                        // ERROR_BANK_PAY_LOAN_NOT_ENOUGH
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN
                    }
                    // So we can force a one time rerender
                    this.rendered = false;
                    this.render();
                },
                withdraw: function ()
                {
                    var amount = document.getElementById("bank").querySelector("#bank_input_number").value;
                    this.data.bank.to_loan = amount;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_BANK_WITHDRAW"));
                    if (!is_sentry(this.data.scene.error_code))
                    {
                        // ERROR_BANK_NOT_ENOUGH_DEPOSIT
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_NOT_ENOUGH_WITHDRAW
                        // ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT
                        // ERROR_BANK_PAY_EXISTING_LOAN_FIRST
                        // ERROR_BANK_NOT_ENOUGH_LOAN
                        // ERROR_BANK_TOO_MUCH_LOAN
                        // ERROR_BANK_NO_LOAN
                        // ERROR_BANK_PAY_LOAN_NOT_ENOUGH
                        // ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD
                        // ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN
                    }
                    // So we can force a one time rerender
                    this.rendered = false;
                    this.render();
                },
                render: function ()
                {
                    if (this.rendered) { return; }
                    this.rendered = true;
                    var html = ``;
                    var dialog_string = GAME_STRINGS[this.data.scene.dialog_id];
                    if (!STRINGS[dialog_string])
                    {
                        console.error(`Missing dialog string for bank [${dialog_string}]`);
                    }
                    var output_string = STRINGS[dialog_string];
                    if (dialog_string === "ACTION_BANK_DEPOSIT_SUCCESS")
                    {
                        output_string = output_string.replace("%d", this.data.bank.deposit_interest_rate);
                    }
                    var outer_border_style = `
                        background: linear-gradient(172deg, #000000, #373737);
                        padding: 4px; border-radius: 4px; max-width: fit-content;
                        display: grid; grid-gap: 10px;
                    `;
                    var inner_text_style = `
                        background: #0c2b6c; padding: 6px; max-width: 300px;
                        max-height: 200px; overflow: auto; border: 1px solid black;`;
                    html += `
                    <div id="bank" style="max-width: fit-content; position: absolute; top: 0px;">
                        <div style="${outer_border_style}">
                            <div id="bank_dialog" style="${inner_text_style}">${output_string}</div>
                            <div id="bank_input">
                                <div>Gold: <input type="number" id="bank_input_number" min="1" max="10000" /></div>
                                <div>Your Gold: <span id="bank_your_gold">${wasm.exports.get_player_gold(0)}</span></div>
                            </div>
                            <div id="bank_info">
                                <div>Current Loan: <span id="bank_current_loan">${this.data.bank.loan_amount}</span></div>
                                <div>Current Deposit: <span id="bank_current_deposit">${this.data.bank.deposit_amount}</span></div>
                            </div>
                            <div id="bank_actions">
                                <button class="green" onclick="UI_BANK.takeLoan();">Take Loan</button>
                                <button class="green" onclick="UI_BANK.deposit();">Deposit</button>
                                <button class="green" onclick="UI_BANK.payLoan();">Pay Loan</button>
                                <button class="green" onclick="UI_BANK.withdraw();">Withdraw</button>
                                <button class="red" onclick="UI_BANK.exit();">Cancel</button>
                            </div>
                        </div>
                    </div>
                    `;
                    document.getElementById("bank").outerHTML = html;
                },
                exit: function ()
                {
                    document.getElementById("bank").outerHTML = `<div id="bank"></div>`;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_EXIT"));
                    this.initialized = false;
                },
            }

            var UI_GENERAL_SHOP = 
            {
                data: {
                    shop: null,
                    inventory: null,
                },
                rendered: false,
                initialized: false,
                dialog: STRINGS["SCENE_GENERAL_SHOP"],
                initialize: function ()
                {
                    if (!this.initialized)
                    {
                        this.data.shop = new GAME_DATA_SCENE_GENERAL_SHOP(wasm.exports);
                        this.data.inventory = new GAME_DATA_INVENTORY(wasm.exports, [
                            this.data.shop.inventory_id
                        ]);
                        this.initialized = true;
                        this.rendered = false;
                    }
                },
                render: function ()
                {
                    if (this.rendered) { return; }
                    this.rendered = true;
                    var html = ``;
                    var outer_border_style = `
                        background: linear-gradient(172deg, #000000, #373737);
                        padding: 4px; border-radius: 4px; max-width: fit-content;
                        display: grid; grid-gap: 10px;
                    `;
                    var inner_text_style = `
                        background: linear-gradient(152deg, black, #4d4d4d); padding: 6px; max-width: 300px;
                        max-height: 200px; overflow: auto; border: 1px solid black;`;
                    var inventory_list_style = `
                        display: grid; grid-template-columns: 1fr 1fr 1fr;
                        grid-gap: 5px; justify-items: center;`;
                    var list_html = ``;
                    for (var d = 0; d < this.data.inventory.total_items; ++d)
                    {
                        if (!is_sentry(this.data.inventory.inventory_items[d]))
                        {
                            var ghi = new GAME_DATA_INVENTORY_ITEM(wasm.exports, [
                                this.data.inventory.inventory_items[d]
                            ]);
                            var name = STRINGS[GAME_STRINGS[ghi.name_id]];
                            list_html += `<div>${name}</div>`;
                            list_html += `<div>
                                <input
                                    class='shop_inventory_item'
                                    type='number'
                                    value='0'
                                    data-price='${ghi.adjusted_price}'
                                    data-id='${d}'
                                    style='width: 40px;'
                                    onclick='UI_GENERAL_SHOP.updateTotalPrice()' /></div>`;
                            list_html += `<div>${ghi.adjusted_price}</div>`;
                        }
                    }
                    html += `
                    <div id="inventory_menu" style="max-width: fit-content; position: absolute; top: 0px;">
                        <div style="${outer_border_style}">
                            <div style="${inner_text_style}">
                                <div style="margin-bottom: 10px;">${this.dialog}</div>
                                <div style="${inventory_list_style}">
                                    ${list_html}
                                    <div>TOTAL</div><div>&nbsp;</div><div><span id="inventory_total_price">0</span></div>
                                    <div><button class="green" onclick="UI_GENERAL_SHOP.buyItems()">Buy</button></div>
                                    <div>&nbsp;</div>
                                    <div><button class="red" onclick="UI_GENERAL_SHOP.cancel()">Cancel</button></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    `;
                    document.getElementById("inventory_menu").outerHTML = html;
                },
                updateTotalPrice: function ()
                {
                    var total_price = 0;
                    var items = document
                        .getElementById("inventory_menu")
                        .querySelectorAll(".shop_inventory_item");
                    for (var i = 0; i < items.length; ++i)
                    {
                        if (items[i] instanceof HTMLElement && items[i].value > 0)
                        {
                            total_price += items[i].value * parseInt(items[i].dataset.price);
                            var id = parseInt(items[i].dataset.id);
                            this.data.shop.chosen_items[id] = items[i].value;
                        }
                    }
                    document.getElementById("inventory_total_price").innerHTML = total_price;
                },
                cancel: function ()
                {
                    document
                        .getElementById("inventory_menu")
                        .outerHTML = `<div id="inventory_menu"></div>`;
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_EXIT"));
                    this.initialized = false;
                },
                buyItems: function ()
                {
                    wasm.exports.current_scene_take_action(GAME_STRINGS.indexOf("ACTION_BUY"));
                    if (this.data.shop.flag_bought == true)
                    {
                        console.log("Successful purchase!");
                    }
                    this.dialog = STRINGS["SCENE_GENERAL_SHOP_THANK_YOU"];
                    this.rendered = false;
                    this.render();
                }
            };

            // gh = GameHelper
            var gh = {
                current: null,
                initialize: function ()
                {
                    this.current = new GAME_CURRENT(wasm.exports);
                    var max = wasm.exports.get_max_worlds();
                    for (var w = 0; w < max; ++w)
                    {
                        WORLD[w] = new GAME_DATA_WORLD(wasm.exports, [w]);
                    }
                    max = wasm.exports.get_max_inventories();
                    for (var i = 0; i < max; ++i)
                    {
                        INVENTORY[i] = new GAME_DATA_INVENTORY(wasm.exports, [i]);
                    }
                    max = wasm.exports.get_max_captains();
                    for (var c = 0; c < max; ++c)
                    {
                        CAPTAIN[c] = new GAME_DATA_CAPTAIN(wasm.exports, [c]);
                    }
                    max = wasm.exports.get_max_base_ships();
                    for (var b = 0; b < max; ++b)
                    {
                        BASE_SHIP[b] = new GAME_DATA_BASE_SHIP(wasm.exports, [b]);
                    }
                    max = wasm.exports.get_max_npcs();
                    for (var n = 0; n < max; ++n)
                    {
                        NPC[n] = new GAME_DATA_NPC(wasm.exports, [n]);
                    }
                    max = wasm.exports.get_max_ship_materials();
                    for (var s = 0; s < max; ++s)
                    {
                        SHIP_MATERIAL[s] = new GAME_DATA_SHIP_MATERIAL(wasm.exports, [s]);
                    }
                    max = wasm.exports.get_max_goods();
                    for (var g = 0; g < max; ++g)
                    {
                        GOOD[g] = new GAME_DATA_GOOD(wasm.exports, [g]);
                    }
                    max = wasm.exports.get_max_armors();
                    for (var a = 0; a < max; ++a)
                    {
                        ARMOR[a] = new GAME_DATA_ARMOR(wasm.exports, [a]);
                    }
                    max = wasm.exports.get_max_weapons();
                    for (var w = 0; w < max; ++w)
                    {
                        WEAPON[w] = new GAME_DATA_WEAPON(wasm.exports, [w]);
                    }
                    max = wasm.exports.get_max_special_items();
                    for (var si = 0; si < max; ++si)
                    {
                        SPECIAL_ITEM[si] = new GAME_DATA_SPECIAL_ITEM(wasm.exports, [si]);
                    }
                    max = wasm.exports.get_max_figureheads();
                    for (var f = 0; f < max; ++f)
                    {
                        FIGUREHEAD[f] = new GAME_DATA_FIGUREHEAD(wasm.exports, [f]);
                    }
                    max = wasm.exports.get_max_cannons();
                    for (var c = 0; c < max; ++c)
                    {
                        CANNON[c] = new GAME_DATA_CANNON(wasm.exports, [c]);
                    }
                    max = wasm.exports.get_max_fleets();
                    for (var f = 0; f < max; ++f)
                    {
                        FLEET[f] = new GAME_DATA_FLEET(wasm.exports, [f]);
                    }
                    PLAYER.updateData();
                },

                shouldRedrawEverything: function ()
                {
                    gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_EVERYTHING");
                },

                shouldUpdate: function (what)
                {
                    var everything = GAME_STRINGS.indexOf("UPDATED_STATE_EVERYTHING");
                    var scene = GAME_STRINGS.indexOf("UPDATED_STATE_SCENE");
                    var world = GAME_STRINGS.indexOf("UPDATED_STATE_WORLD");
                    if (gh.current.updated_state === everything)
                    {
                        return true;
                    }
                    if (what === "scene" && gh.current.updated_state === scene)
                    {
                        return true;
                    }
                    if (what === "world" && gh.current.updated_state === world)
                    {
                        return true;
                    }
                    return false;
                },

                getCurrentWorldName: function ()
                {
                    // TODO: Stop creating new views
                    var current = new GAME_CURRENT(wasm.exports);
                    // TODO: This is a weird way to get world name
                    return UNDERSTRINGS[GAME_STRINGS[current.world_name]];
                },

                // EDITOR
                editor:
                {
                    layer_strings: [],
                    active_layer_id: null,
                    active_layer_name_id: null,
                    current_wasm_value: null,
                    current_atlas_x: null,
                    current_atlas_y: null,
                    previous_wasm_value: null,
                    previous_atlas_x: null,
                    previous_atlas_y: null,
                    mode: null,
                },
                editorUpdateAtlasPreview: function ()
                {
                    var atlas_x = parseInt(document.getElementById("atlas_asset_x").value);
                    var atlas_y = parseInt(document.getElementById("atlas_asset_y").value);
                    atlas_x *= TILE_SIZE_SCALED;
                    atlas_y *= TILE_SIZE_SCALED;
                    var atlas_preview_element = document.getElementById("atlas_preview");
                    if (atlas_preview_element instanceof HTMLElement)
                    {
                        var style = `
                            background-image: var(--atlas-image);
                            background-position: -${atlas_x} -${atlas_y};
                            background-size: ${ATLAS_IMAGE_SIZE.x / 2}px ${ATLAS_IMAGE_SIZE.y / 2}px;
                            width: 32px; height: 32px;
                        `;
                        atlas_preview_element.setAttribute("style", style);
                    }
                    else
                    {
                        console.error("No atlas preview element found");
                    }
                },
                editorSetModeToPull: function ()
                {
                    this.editor.mode = null;
                    document.getElementById("pull_layer_value").classList.remove("active");
                    document.getElementById("set_layer_value").classList.remove("active");
                    document.getElementById("pull_layer_value").classList.add("active");
                    this.editor.mode = "pull";
                },
                editorSetModeToSet: function ()
                {
                    this.editor.mode = null;
                    document.getElementById("pull_layer_value").classList.remove("active");
                    document.getElementById("set_layer_value").classList.remove("active");
                    document.getElementById("set_layer_value").classList.add("active");
                    this.editor.mode = "set";
                },
                editorSetLayerActiveID: function (name_id, id)
                {
                    this.editor.active_layer_id = id;
                    this.editor.active_layer_name_id = name_id;
                    var editor_layer_buttons = document.querySelectorAll(".editor_layer");
                    for (var e = 0; e < editor_layer_buttons.length; ++e)
                    {
                        if (editor_layer_buttons[e] instanceof HTMLElement)
                        {
                            editor_layer_buttons[e].classList.remove("active");
                        }
                    }
                    document.getElementById("editor_layer_" + id).classList.add("active");
                },
                editorGetLayers: function ()
                {
                    document.getElementById("layers_list").innerHTML = '';
                    var total_layers = WORLD[gh.current.world].total_layers;
                    this.editor.layer_strings = [];
                    this.editor.active_layer_id = null;
                    this.editor.active_layer_name_id = null;
                    this.editor.current_wasm_value = null;
                    this.editor.current_atlas_x = null;
                    this.editor.current_atlas_y = null;
                    this.editor.previous_wasm_value = null;
                    this.editor.previous_atlas_x = null;
                    this.editor.previous_atlas_y = null;
                    this.editor.mode = null;
                    for (var t = 0; t < total_layers; ++t)
                    {
                        var layer_id = WORLD[gh.current.world].layers[t];
                        var layer = new GAME_DATA_LAYER(wasm.exports, [layer_id]);
                        var name_id = GAME_STRINGS[layer.name_id];
                        var name = STRINGS[name_id];
                        this.editor.layer_strings.push({
                            layer_id,
                            name_id: layer.name_id,
                            name
                        });
                        document.getElementById("layers_list").innerHTML += "<button class='editor_layer' id='editor_layer_" + layer_id + "' onclick='gh.editorSetLayerActiveID(" + layer.name_id + ", " + layer_id + ")'>" + name + "</button>";
                    }
                    document.getElementById("pull_layer_value").classList.remove("active");
                    document.getElementById("set_layer_value").classList.remove("active");
                    console.log(this.editor.layer_strings);
                },
                editorSetLayerCoordinatesValue: function(layer_id, x, y, value)
                {
                    var original_value = wasm.exports.layer_get_value(layer_id, x, y);
                    // UNDO_COUNTER = 0 (actually equal to undo array.length - 1)
                    // [layer_id, x, y, original_value, updated_value]
                    // If you go backwards into the undo array and then make a NEW change, release everything in undo array from current UNDO_COUNTER to end of array
                    // REDO_COUNTER = UNDO_COUNTER + 1 -> reapply updated_value
                    // TODO: store original value in an array of changes so we can undo and redo
                    LAYER_COORDINATES_VALUE_HISTORY[LAYER_COORDINATES_VALUE_UNDO_COUNTER] = [
                        layer_id,
                        x, y,
                        original_value,
                        value
                    ];
                    ++LAYER_COORDINATES_VALUE_UNDO_COUNTER;
                    wasm.exports.layer_set_value(layer_id, x, y, value);
                },
                editorSetLayerCoordinatesValueUndo: function ()
                {
                    --LAYER_COORDINATES_VALUE_UNDO_COUNTER;
                    if (LAYER_COORDINATES_VALUE_UNDO_COUNTER < 0)
                    {
                        LAYER_COORDINATES_VALUE_UNDO_COUNTER = 0;
                    }
                    var data = LAYER_COORDINATES_VALUE_HISTORY[LAYER_COORDINATES_VALUE_UNDO_COUNTER];
                    wasm.exports.add_value_to_global_world_data(data[0], data[1], data[2], data[3]);
                    wasm.exports.should_redraw_everything();
                    // force_redraw = true;
                },
                editorSetLayerCoordinatesValueRedo: function ()
                {
                    if (LAYER_COORDINATES_VALUE_UNDO_COUNTER < LAYER_COORDINATES_VALUE_HISTORY.length)
                    {
                        var data = LAYER_COORDINATES_VALUE_HISTORY[LAYER_COORDINATES_VALUE_UNDO_COUNTER];
                        wasm.exports.add_value_to_global_world_data(data[0], data[1], data[2], data[4]);
                        wasm.exports.should_redraw_everything();
                        force_redraw = true;
                        --LAYER_COORDINATES_VALUE_UNDO_COUNTER;
                    }
                },
                editorHide: function ()
                {
                    document.getElementById("meta-game").style.display = "none";
                }
            }

            var animateOcean = {
                current_x: 0,
                max_x: 7,
                current_frame: 0,
                render_always: true,
                frame_rate: 2000,
                render: function ()
                {
                    ++this.current_frame;
                    if (this.current_frame > this.frame_rate)
                    {
                        this.current_frame = 0;
                        ++this.current_x;
                        if (this.current_x > this.max_x)
                        {
                            this.current_x = 0;
                        }
                    }
                },
                render_ocean_bg_tile: function(value)
                {
                    var lam = LAYER_ATLAS_MAP[
                        UNDERSTRINGS[
                            GAME_STRINGS[gh.current.world_name]
                        ]
                    ];
                    var atlas_x = lam["background_layer"][value][0];
                    var atlas_y = lam["background_layer"][value][1];
                    atlas_x += this.current_x;
                    atlas_x *= TILE_SIZE_SCALED;
                    atlas_y *= TILE_SIZE_SCALED;
                    var style = ``;
                    style += `position: absolute;`;
                    style += ` background-image: var(--atlas-image);`;
                    style += ` background-position: -${atlas_x} -${atlas_y};`;
                    style += `
                        background-size:
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    style += ` width: ${TILE_SIZE_SCALED}px;`;
                    style += ` height: ${TILE_SIZE_SCALED}px;`;
                    var html = `
                        <div class="ocean_bg_tile" style="${style}"></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleCannon = {
                type: "ocean_battle",
                start: {x: 0, y: 0},
                current: {x: 0, y: 0},
                end: {x: 0, y: 0},
                animated: false,
                current_frame: 0,
                frame_rate: 1,
                move_by: 8,
                render_always: true,
                cannon_tile: null,
                callbacks: [],
                reset: function ()
                {
                    if (this.cannon_tile !== null)
                    {
                        this.cannon_tile.remove();
                        this.cannon_tile = null;
                    }
                    this.start = {x: 0, y: 0};
                    this.current = {x: 0, y: 0};
                    this.end = {x: 0, y: 0};
                    this.animated = false;
                    this.callbacks = [];
                },
                render: function ()
                {
                    if (this.cannon_tile === null)
                    {
                        this.cannon_tile = document.createElement('div');
                        this.cannon_tile.id = "cannon_tile";
                        this.cannon_tile.style.position = "absolute";
                        this.cannon_tile.style.zIndex = "100";
                        this.cannon_tile.style.width = TILE_SIZE_SCALED + "px";
                        this.cannon_tile.style.height = TILE_SIZE_SCALED + "px";
                        this.cannon_tile.style.backgroundImage = "var(--atlas-image)";
                        this.cannon_tile.style.backgroundPosition = `-${17 * TILE_SIZE_SCALED} -${2 * TILE_SIZE_SCALED}`;
                        // TODO: Remove magic numbers on bg atlas size
                        this.cannon_tile.style.backgroundSize = `${ATLAS_IMAGE_SIZE.x / 2}px ${ATLAS_IMAGE_SIZE.y / 2}px`;
                        document.body.appendChild(this.cannon_tile);
                        this.current.x = this.start.x;
                        this.current.y = this.start.y;
                        this.cannon_tile.style.top = this.current.x + "px";
                        this.cannon_tile.style.left = this.current.y + "px";
                    }

                    ++this.current_frame;
                    if (this.current_frame > this.frame_rate)
                    {
                        this.current_frame = 0;
                        if (this.end.x > this.start.x)
                        {
                            this.current.x += this.move_by;
                            if (this.current.x > this.end.x) {
                                this.current.x = this.end.x;
                            }
                        }
                        else
                        {
                            this.current.x -= this.move_by;
                            if (this.current.x < this.end.x)
                            {
                                this.current.x = this.end.x;
                            }
                        }
                        this.cannon_tile.style.left = this.current.x + "px";
                        if (this.end.y > this.start.y)
                        {
                            this.current.y += this.move_by;
                            if (this.current.y > this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        else
                        {
                            this.current.y -= this.move_by;
                            if (this.current.y < this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        this.cannon_tile.style.top = this.current.y + "px";
                        if (
                            this.current.x == this.end.x
                            &&
                            this.current.y == this.end.y
                        ) {
                            this.cannon_tile.remove();
                            this.animated = true;
                            uih.animations.splice(uih.animations.indexOf(animateOceanBattleCannon), 1);
                            for (var ca = 0; ca < this.callbacks.length; ++ca)
                            {
                                this.callbacks[ca]();
                            }
                        }
                    }
                }
            };
            var animateOceanBattleCannonCoords = {
                type: "ocean_battle",
                render_always: false,
                add_to_viewport_world_tile: true,
                is_valid: function (x, y)
                {
                    var valid = false;
                    var coords = UI_OCEAN_BATTLE.data.battle.valid_cannon_coords;
                    for (var i = 0; i < coords.length; i += 2)
                    {
                        var valid_x = coords[i];
                        var valid_y = coords[i + 1];
                        if (valid_x === x && valid_y === y)
                        {
                            valid = true;
                            break;
                        }
                    }
                    return valid;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-cannon-coord`;
                    var onmousedown = `
                    UI_OCEAN_BATTLE.setCannonsTo(
                        ${world_x},
                        ${world_y}
                    );
                    `;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${18 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        onmousedown="${onmousedown}"
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleCannonIntendedCoords = {
                type: "ocean_battle",
                render_always: false,
                add_to_viewport_world_tile: true,
                is_valid: function (x, y)
                {
                    if (
                        x === UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[0]
                        &&
                        y === UI_OCEAN_BATTLE.data.battle.intended_cannon_coords[1]
                    )
                    {
                        return true;
                    }
                    return false;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-intended-boarding-coord`;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${20 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleMoveCoords = {
                type: "ocean_battle",
                render_always: false,
                add_to_viewport_world_tile: true,
                zIndex: 4,
                is_valid: function (x, y)
                {
                    var valid = false;
                    var coords = UI_OCEAN_BATTLE.data.battle.valid_move_coords;
                    for (var i = 0; i < coords.length; i += 2)
                    {
                        var valid_x = coords[i];
                        var valid_y = coords[i + 1];
                        if (valid_x === x && valid_y === y)
                        {
                            valid = true;
                            break;
                        }
                    }
                    return valid;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-move-coord`;
                    var onmousedown = `
                    UI_OCEAN_BATTLE.moveWorldNPCTo(
                        ${world_x},
                        ${world_y}
                    );
                    `;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${19 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        onmousedown="${onmousedown}"
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleMoveIntendedCoords = {
                name: "intended_move",
                type: "ocean_battle",
                add_to_viewport_world_tile: true,
                render_always: false,
                is_valid: function (x, y)
                {
                    if (
                        x === UI_OCEAN_BATTLE.data.battle.intended_move_coords[0]
                        &&
                        y === UI_OCEAN_BATTLE.data.battle.intended_move_coords[1]
                    )
                    {
                        return true;
                    }
                    return false;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-intended-move-coord`;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${24 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleMove = {
                type: "ocean_battle",
                name: "ocean_battle_move",
                render_always: true,
                start: {x: 0, y: 0},
                current: {x: 0, y: 0},
                end: {x: 0, y: 0},
                animated: false,
                animating: false,
                current_frame: 0,
                frame_rate: 1,
                move_by: 2,
                callbacks: [],
                reset: function ()
                {
                    this.start = {x: 0, y: 0};
                    this.current = {x: 0, y: 0};
                    this.end = {x: 0, y: 0};
                    this.animated = false;
                    this.callbacks = [];
                },
                render: function ()
                {
                    ++this.current_frame;
                    this.animating = true;
                    if (this.current_frame > this.frame_rate)
                    {
                        this.current_frame = 0;
                        if (this.end.x > this.start.x)
                        {
                            this.current.x += this.move_by;
                            if (this.current.x > this.end.x) {
                                this.current.x = this.end.x;
                            }
                        }
                        else
                        {
                            this.current.x -= this.move_by;
                            if (this.current.x < this.end.x)
                            {
                                this.current.x = this.end.x;
                            }
                        }
                        if (this.end.y > this.start.y)
                        {
                            this.current.y += this.move_by;
                            if (this.current.y > this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        else
                        {
                            this.current.y -= this.move_by;
                            if (this.current.y < this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        if (
                            this.current.x == this.end.x
                            &&
                            this.current.y == this.end.y
                        ) {
                            this.animating = false;
                            this.animated = true;
                            uih.animations.splice(uih.animations.indexOf(animateOceanBattleMove), 1);
                            for (var ca = 0; ca < this.callbacks.length; ++ca)
                            {
                                this.callbacks[ca]();
                            }
                        }
                    }
                }
            };
            var animateOceanBattleBoardingCoords = {
                type: "ocean_battle",
                render_always: false,
                add_to_viewport_world_tile: true,
                is_valid: function (x, y)
                {
                    var valid = false;
                    var coords = UI_OCEAN_BATTLE.data.battle.valid_boarding_coords;
                    for (var i = 0; i < coords.length; i += 2)
                    {
                        var valid_x = coords[i];
                        var valid_y = coords[i + 1];
                        if (valid_x === x && valid_y === y)
                        {
                            valid = true;
                            break;
                        }
                    }
                    return valid;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-boarding-coord`;
                    var onmousedown = `
                    UI_OCEAN_BATTLE.setBoardingTo(
                        ${world_x},
                        ${world_y}
                    );
                    `;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${18 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        onmousedown="${onmousedown}"
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleBoardingIntendedCoords = {
                type: "ocean_battle",
                render_always: false,
                add_to_viewport_world_tile: true,
                is_valid: function (x, y)
                {
                    if (
                        x === UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[0]
                        &&
                        y === UI_OCEAN_BATTLE.data.battle.intended_boarding_coords[1]
                    )
                    {
                        return true;
                    }
                    return false;
                },
                render_html: function (world_x, world_y)
                {
                    var classes = `ocean-battle-intended-boarding-coord`;
                    var style = `
                        cursor: pointer;
                        position: absolute;
                        z-index: 7;
                        width: ${TILE_SIZE_SCALED}px;
                        height: ${TILE_SIZE_SCALED}px;
                        background-image: var(--atlas-image);
                        background-position: 
                            -${20 * TILE_SIZE_SCALED}
                            -${3 * TILE_SIZE_SCALED};
                        background-size: 
                            ${ATLAS_IMAGE_SIZE.x / 2}px
                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                    `;
                    var html = `
                    <div
                        class="${classes}"
                        style="${style}"
                    ></div>
                    `;
                    return html;
                }
            };
            var animateOceanBattleBoarding = {
                type: "ocean_battle",
                start: {x: 0, y: 0},
                current: {x: 0, y: 0},
                end: {x: 0, y: 0},
                animated: false,
                current_frame: 0,
                frame_rate: 1,
                move_by: 2,
                render_always: true,
                boarding_tile: null,
                callbacks: [],
                reset: function ()
                {
                    if (this.boarding_tile !== null)
                    {
                        this.boarding_tile.remove();
                        this.boarding_tile = null;
                    }
                    this.start = {x: 0, y: 0};
                    this.current = {x: 0, y: 0};
                    this.end = {x: 0, y: 0};
                    this.animated = false;
                    this.callbacks = [];
                },
                render: function ()
                {
                    if (this.boarding_tile === null)
                    {
                        this.boarding_tile = document.createElement('div');
                        this.boarding_tile.id = "boarding_tile";
                        this.boarding_tile.style.position = "absolute";
                        this.boarding_tile.style.zIndex = "100";
                        this.boarding_tile.style.width = TILE_SIZE_SCALED + "px";
                        this.boarding_tile.style.height = TILE_SIZE_SCALED + "px";
                        this.boarding_tile.style.backgroundImage = "var(--atlas-image)";
                        this.boarding_tile.style.backgroundPosition = `-${15 * TILE_SIZE_SCALED} -${2 * TILE_SIZE_SCALED}`;
                        // TODO: Remove magic numbers on bg atlas size
                        this.boarding_tile.style.backgroundSize = `${ATLAS_IMAGE_SIZE.x / 2}px ${ATLAS_IMAGE_SIZE.y / 2}px`;
                        document.body.appendChild(this.boarding_tile);
                        this.current.x = this.start.x;
                        this.current.y = this.start.y;
                        this.boarding_tile.style.top = this.current.x + "px";
                        this.boarding_tile.style.left = this.current.y + "px";
                    }

                    ++this.current_frame;
                    if (this.current_frame > this.frame_rate)
                    {
                        this.current_frame = 0;
                        if (this.end.x > this.start.x)
                        {
                            this.current.x += this.move_by;
                            if (this.current.x > this.end.x) {
                                this.current.x = this.end.x;
                            }
                        }
                        else
                        {
                            this.current.x -= this.move_by;
                            if (this.current.x < this.end.x)
                            {
                                this.current.x = this.end.x;
                            }
                        }
                        this.boarding_tile.style.left = this.current.x + "px";
                        if (this.end.y > this.start.y)
                        {
                            this.current.y += this.move_by;
                            if (this.current.y > this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        else
                        {
                            this.current.y -= this.move_by;
                            if (this.current.y < this.end.y)
                            {
                                this.current.y = this.end.y;
                            }
                        }
                        this.boarding_tile.style.top = this.current.y + "px";
                        if (
                            this.current.x == this.end.x
                            &&
                            this.current.y == this.end.y
                        ) {
                            this.boarding_tile.remove();
                            this.animated = true;
                            uih.animations.splice(uih.animations.indexOf(animateOceanBattleBoarding), 1);
                            for (var ca = 0; ca < this.callbacks.length; ++ca)
                            {
                                this.callbacks[ca]();
                            }
                        }
                    }
                }
            };

            var animateBattleShip = {
                start: {x: 0, y: 3},
                end: {x: 15, y: 3},
                current: {x: 0, y: 3},
                current_frame: 0,
                frame_rate: 20,
                render: function ()
                {
                    ++this.current_frame;
                    if (this.current_frame >= this.frame_rate)
                    {
                        ++this.current.x;
                        if (this.current.x > this.end.x)
                        {
                            this.current.x = this.start.x;
                        }
                        this.current_frame = 0;
                    }
                }
            };

            // uih = UIHelper
            var uih = {
                highlightNPCID: null,
                animations: [],
                getViewport: function ()
                {
                    return document.getElementById("viewport");
                },
                updateLayers: function ()
                {
                    var total_layers = wasm.exports.get_storage_layer_total_used_slots();
                    var slots = game_get_storage_layer_used_slots(wasm.exports);
                    LAYER = [];
                    for (var t = 0; t < total_layers; ++t)
                    {
                        var layer_id = slots[t];
                        LAYER.push(new GAME_DATA_LAYER(wasm.exports, [layer_id]));
                    }
                },
                updatedRender: function ()
                {
                    this.updateLayers();
                    var html = ``;
                    var total_layers = wasm.exports.get_storage_layer_total_used_slots();
                    var bg_layer_id = null;
                    var layer_one_id = null;
                    var layer_two_id = null;
                    for (var t = 0; t < total_layers; ++t)
                    {
                        if (LAYER[t].name_id === GAME_STRINGS.indexOf("LAYER_BACKGROUND"))
                        {
                            bg_layer_id = t;
                        }
                        if (LAYER[t].name_id === GAME_STRINGS.indexOf("LAYER_ONE"))
                        {
                            layer_one_id = t;
                        }
                        if (LAYER[t].name_id === GAME_STRINGS.indexOf("LAYER_TWO"))
                        {
                            layer_two_id = t;
                        }
                    }
                    var total_world_npcs = wasm.exports.get_storage_world_npc_total_used_slots();
                    var npcs_slots = game_get_storage_npc_used_slots(wasm.exports);
                    // TODO: This is super wasteful. Only get world npcs if world npcs have actually changed
                    var world_npcs = [];
                    for (var n = 0; n < total_world_npcs; ++n)
                    {
                        world_npcs.push(new GAME_DATA_WORLD_NPC(wasm.exports, [n]));
                        var last_index = world_npcs.length - 1;
                        world_npcs[last_index].name = UNDERSTRINGS[
                            GAME_STRINGS[world_npcs[last_index].name_id]
                        ];
                        world_npcs[last_index].type = GAME_STRINGS[
                            world_npcs[last_index].type_id
                        ];
                    }

                    var cached_lam = LAYER_ATLAS_MAP[
                        UNDERSTRINGS[
                            GAME_STRINGS[gh.current.world_name]
                        ]
                    ];
                    var value;
                    var style, onmousedown, onmousemove = "";
                    var viewport_style = `
                        display: grid;
                        grid-template-rows: repeat(${VIEWPORT.height}, 1fr);
                        grid-template-columns: repeat(${VIEWPORT.width}, 1fr);
                        width: ${VIEWPORT.width * TILE_SIZE_SCALED}px;
                        height: ${VIEWPORT.height * TILE_SIZE_SCALED}px;
                        zoom: 1.5;`;
                    if (should3d)
                    {
                        viewport_style += ` margin-left: 60px;`;
                        // Note: Holy shit... this was way faster. Eff. I have a lot of refactoring to do now
                        viewport_style += ` 
                            transform:
                                perspective(1000px)
                                rotateX(${degy}deg)
                                rotateY(${degx}deg)
                                rotateZ(0deg);
                            transform-style: preserve-3d;
                            will-change: transform;`;
                    }
                    var viewport_html = `
                    <div
                        id="viewport"
                        style="${viewport_style}"
                        onmousedown="console.log(event);"
                    >
                    `;
                    for (var vy = 0; vy < VIEWPORT.height; ++vy)
                    {
                        for (var vx = 0; vx < VIEWPORT.width; ++vx)
                        {
                            var world_x = CAMERA.offset.x + vx;
                            var world_y = CAMERA.offset.y + vy;

                            style = `
                                width: ${TILE_SIZE_SCALED}px;
                                height: ${TILE_SIZE_SCALED}px;
                                mix-blend-mode: normal;`;
                            if (should3d)
                            {
                                style += ` 
                                    transform-style: preserve-3d;
                                    will-change: transform;
                                    backface-visibility: hidden;`;
                            }
                            onmousedown += ` viewportMouseDown(${world_x}, ${world_y});`;
                            onmousemove += ` viewportMouseMove(${vx}, ${vy}, ${world_x}, ${world_y});`;

                            html += `<div
                                class="tile_element"
                                data-world-x="${world_x}"
                                data-world-y="${world_y}"
                                data-viewport-x="${vx}"
                                data-viewport-y="${vy}"
                                style="${style}"
                                onmousedown="${onmousedown}"
                                onmousemove="${onmousemove}"
                            >`;

                            value = get_layer_value(
                                LAYER[bg_layer_id],
                                world_x,
                                world_y
                            );
                            if (
                                value !== undefined
                                &&
                                !is_sentry(value)
                                &&
                                cached_lam["background_layer"][value]
                            )
                            {
                                html += animateOcean.render_ocean_bg_tile(value);
                            }

                            value = get_layer_value(LAYER[layer_one_id], world_x, world_y);
                            if (
                                value !== undefined
                                &&
                                !is_sentry(value)
                                &&
                                cached_lam["layer_one"][value]
                            )
                            {
                                var atlas_x = cached_lam["layer_one"][value][0];
                                var atlas_y = cached_lam["layer_one"][value][1];
                                atlas_x *= TILE_SIZE_SCALED;
                                atlas_y *= TILE_SIZE_SCALED;
                                style = `
                                    background-image: var(--atlas-image);
                                    background-position: -${atlas_x} -${atlas_y};
                                    position: absolute;
                                    background-size: 
                                        ${ATLAS_IMAGE_SIZE.x / 2}px
                                        ${ATLAS_IMAGE_SIZE.y / 2}px;
                                    width: ${TILE_SIZE_SCALED}px;
                                    height: ${TILE_SIZE_SCALED}px;
                                `;
                                if ((value == 0 || value == 1) && should3d)
                                {
                                    style += ` 
                                        transform-style: preserve-3d;
                                        transform: 
                                            rotateX(-90deg)
                                            translateZ(48px)
                                            translateY(-32px);
                                    `;
                                }
                                if ((value == 2 || value == 3) && should3d)
                                {
                                    style += ` 
                                        transform-style: preserve-3d;
                                        transform: 
                                            rotateX(-90deg)
                                            translateZ(16px)
                                            translateY(-16px);
                                    `;
                                }
                                html += `<div
                                    data-layer-id="${layer_one_id}"
                                    data-layer="layer_one"
                                    style="${style}"></div>`;
                            }

                            value = get_layer_value(
                                LAYER[layer_two_id],
                                world_x,
                                world_y
                            );
                            if (
                                value !== undefined
                                &&
                                !is_sentry(value)
                                &&
                                cached_lam["layer_two"][value]
                            )
                            {
                                var atlas_x = cached_lam["layer_two"][value][0];
                                var atlas_y = cached_lam["layer_two"][value][1];
                                atlas_x *= TILE_SIZE_SCALED;
                                atlas_y *= TILE_SIZE_SCALED;
                                style = `
                                    background-image: var(--atlas-image);
                                    background-position: -${atlas_x} -${atlas_y};
                                    position: absolute;
                                    background-size: 
                                        ${ATLAS_IMAGE_SIZE.x / 2}px
                                        ${ATLAS_IMAGE_SIZE.y / 2}px;
                                    width: ${TILE_SIZE_SCALED}px;
                                    height: ${TILE_SIZE_SCALED}px;`;
                                if (value === 4 && should3d)
                                {
                                    style += ` 
                                        transform-style: preserve-3d;
                                        transform: 
                                            rotateX(-90deg)
                                            translateZ(16px)
                                            translateY(-16px);`;
                                }
                                html += `<div
                                    class="atlas"
                                    data-layer-id="${layer_two_id}"
                                    data-layer="layer_two"
                                    style="${style}"></div>`;
                            }

                            for (var a = 0; a < uih.animations.length; ++a)
                            {
                                var anim = uih.animations[a];
                                if (
                                    anim.add_to_viewport_world_tile
                                    &&
                                    anim.is_valid(world_x, world_y)
                                )
                                {
                                    html += anim.render_html(world_x, world_y);
                                }
                            }

                            // NPCS
                            for (var n = 0; n < world_npcs.length; ++n)
                            {
                                if (
                                    world_npcs[n].position_x === world_x
                                    &&
                                    world_npcs[n].position_y === world_y
                                )
                                {
                                    var atlas_x, atlas_y = null;
                                    var wnpc_name = world_npcs[n].name;
                                    var wnpc_type = world_npcs[n].type;
                                    if (cached_lam["npc_layer"][wnpc_name])
                                    {
                                        atlas_x = cached_lam["npc_layer"][wnpc_name][0];
                                        atlas_y = cached_lam["npc_layer"][wnpc_name][1];
                                    }
                                    if (cached_lam["npc_layer"][n])
                                    {
                                        atlas_x = cached_lam["npc_layer"][n][0];
                                        atlas_y = cached_lam["npc_layer"][n][1];
                                    }
                                    if (wnpc_type === "NPC_TYPE_SHIP")
                                    {
                                        if (cached_lam["npc_layer"]["ship_" + wnpc_name])
                                        {
                                            // atlas_x = cached_lam["npc_layer"]["ship_" + wnpc_name][0];
                                            // atlas_y = cached_lam["npc_layer"]["ship_" + wnpc_name][1];
                                            atlas_x = animateBattleShip.current.x;
                                            atlas_y = animateBattleShip.current.y;
                                            animateBattleShip.render();
                                        }
                                    }
                                    if (atlas_x === null || atlas_y === null)
                                    {
                                        console.error(
                                            "Could not place NPC for some reason",
                                            {n, npc: world_npcs[n], wnpc_name, wnpc_type}
                                        );
                                        continue;
                                    }
                                    atlas_x *= TILE_SIZE_SCALED;
                                    atlas_y *= TILE_SIZE_SCALED;
                                    style = `
                                        background-image: var(--atlas-image);
                                        background-position: -${atlas_x} -${atlas_y};
                                        position: absolute;
                                        background-size: 
                                            ${ATLAS_IMAGE_SIZE.x / 2}px
                                            ${ATLAS_IMAGE_SIZE.y / 2}px;
                                        width: ${TILE_SIZE_SCALED}px;
                                        height: ${TILE_SIZE_SCALED}px;`;
                                    if (world_npcs[n].id === uih.highlightNPCID)
                                    {
                                        style += ` background-color: rgba(0, 0, 255, 0.2);`;
                                    }
                                    if (should3d)
                                    {
                                        style += ` 
                                        transform: 
                                            rotateX(90deg)
                                            rotateZ(180deg)
                                            rotateY(180deg)
                                            translate3d(0px, -16px, 0px);`;
                                        style += ` transform-style: preserve-3d;`;
                                        style += ` will-change: transform;`;
                                        style += ` backface-visibility: hidden;`;
                                    }
                                    if (
                                        this.animations.indexOf(animateOceanBattleMove) >= 0
                                        &&
                                        UI_OCEAN_BATTLE.current_world_npc.id === n
                                    )
                                    {
                                        style += ` left: ${animateOceanBattleMove.current.x}px;`;
                                        style += ` top: ${animateOceanBattleMove.current.y}px;`;
                                        style += ` z-index: 101;`;
                                    }
                                    html += `<div
                                        class="layer-npc_layer"
                                        data-npc-id="${n}"
                                        style="${style}"
                                        ></div>`;
                                }
                            }

                            // entities?
                            // blocks?

                            html += `</div>`;
                        }
                    }
                    viewport_html += `${html}`;
                    viewport_html += `</div>`;
                    return viewport_html;
                },
                updateRootProperties()
                {
                    // :root update
                    var de = document.documentElement;
                    de.style.setProperty("--atlas-width", TILE_SIZE_SCALED + "px");
                    de.style.setProperty("--atlas-height", TILE_SIZE_SCALED + "px");
                    de.style.setProperty("--tile-scaled", TILE_SIZE_SCALED + "px");
                    de.style.setProperty("--viewport-width", VIEWPORT.width);
                    de.style.setProperty("--viewport-height", VIEWPORT.height);
                },
                initialize: function ()
                {
                    dragElement(
                        document.getElementById("meta-game"),
                        document.getElementById("meta-game-drag-handle"),
                        { useBottomRight: true },
                    );

                    wasm.exports.tick();
                    uih.updateLayers();
                    uih.getViewport().outerHTML = uih.updatedRender();

                    // By default add ocean animation
                    // TODO: In the future, only add ocean animation when ocean is the background
                    this.animations.push(animateOcean);
                },
            };

            var force_redraw = false;
            // var rotateX = 67
            var RAF = {
                fps: 60,
                interval: 1000,
                last_time: 0,
                is_paused: false,
                last_log_time: 0,
                log_interval: 0,
                fps_value: 0,
                last_fps_time: 0,
                frame_count: 0,
                initialize: function ()
                {
                    RAF.interval = RAF.interval / RAF.fps;
                },
                animate: function(current_time)
                {
                    requestAnimationFrame(RAF.animate);

                    if (!RAF.is_paused)
                    {
                        // Calculate time elapsed since last frame
                        var delta_time = current_time - RAF.last_time;

                        // Only update if enough time has passed
                        if (delta_time >= RAF.interval)
                        {
                            // Update last time, accounting for any extra time
                            RAF.last_time = current_time - (delta_time % RAF.interval);

                            RAF.update(delta_time, current_time);
                            RAF.render();
                            wasm.exports.tick();

                            ++RAF.frame_count;
                        }
                    }

                    // Calculate FPS every second
                    if (current_time - RAF.last_fps_time >= 1000)
                    {
                        RAF.fps_value = Math.round(
                            (RAF.frame_count * 1000) / (current_time - RAF.last_fps_time)
                        );
                        RAF.frame_count = 0;
                        RAF.last_fps_time = current_time;
                    }
                },
                update: function(delta_time, current_time)
                {
                    if (current_time - RAF.last_log_time >= RAF.log_interval)
                    {
                        RAF.last_log_time = current_time;
                    }
                    // wasm.tick
                },
                can_tick: true,
                render: function ()
                {
                    if (!wasm) { console.error("NO WASM"); return; }
                    if (gh.current.game_mode === GAME_STRINGS.indexOf("GAME_MODE_IN_PLAYER_MENU"))
                    {
                        // Note: This essentially disables rendering because of "shouldUpdate" function
                        // gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_NOTHING");
                        UI_PLAYER_MENU.initialize();
                        UI_PLAYER_MENU.render();
                    }
                    else if (gh.current.game_mode === GAME_STRINGS.indexOf("GAME_MODE_IN_SCENE"))
                    {
                        scene_name = GAME_STRINGS[gh.current.scene];
                        // if (!gh.shouldUpdate("scene")) { return; }
                        if (
                            scene_name === "SCENE_NPC_RVICE"
                            ||
                            scene_name === "SCENE_NPC_LAFOLIE"
                            ||
                            scene_name === "SCENE_NPC_NAKOR"
                            ||
                            scene_name === "SCENE_NPC_TRAVIS"
                            ||
                            scene_name === "SCENE_NPC_LOLLER"
                        )
                        {
                            // Note: This essentially disables rendering because of "shouldUpdate" function
                            // gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_NOTHING");
                            UI_SCENE_SINGLE_DIALOG.initialize();
                            UI_SCENE_SINGLE_DIALOG.render();
                        }
                        else if (scene_name === "SCENE_GENERAL_SHOP")
                        {
                            // Note: This essentially disables rendering because of "shouldUpdate" function
                            // gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_NOTHING");
                            UI_GENERAL_SHOP.initialize();
                            UI_GENERAL_SHOP.render();
                        }
                        else if (scene_name === "SCENE_BANK")
                        {
                            // Note: This essentially disables rendering because of "shouldUpdate" function
                            // gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_NOTHING");
                            UI_BANK.initialize();
                            UI_BANK.render();
                        }
                        else if (scene_name === "SCENE_OCEAN_BATTLE")
                        {
                            // Note: This essentially disables rendering because of "shouldUpdate" function
                            // gh.current.updated_state = GAME_STRINGS.indexOf("UPDATED_STATE_NOTHING");
                            UI_OCEAN_BATTLE.initialize();
                        }
                        else if (scene_name === "SCENE_SHIPYARD")
                        {
                            document.querySelector("ui-shipyard").initialize();
                        }
                    }
                    else
                    {
                        if (PLAYER.previous_world_npc_id !== PLAYER.captain.world_npc_id)
                        {
                            PLAYER.world_npc = new GAME_DATA_WORLD_NPC(wasm.exports, [PLAYER.captain.world_npc_id]);
                            PLAYER.previous_world_npc_id = PLAYER.captain.world_npc_id;
                        }
                        if (!is_sentry(PLAYER.world_npc.position_x))
                        {
                            if (
                                (PLAYER.world_npc.position_x - CAMERA.offset.x) > (VIEWPORT.width / 2)
                                &&
                                (CAMERA.offset.x + VIEWPORT.width) < WORLD[gh.current.world].width
                            )
                            {
                                CAMERA.moveRight();
                            }
                            else if (
                                (PLAYER.world_npc.position_x - CAMERA.offset.x) < (VIEWPORT.width / 2)
                                &&
                                CAMERA.offset.x > 0
                            )
                            {
                                CAMERA.moveLeft();
                            }
                            if (
                                (PLAYER.world_npc.position_y - CAMERA.offset.y) > (VIEWPORT.height / 2)
                                &&
                                (CAMERA.offset.y + VIEWPORT.height) < WORLD[gh.current.world].height
                            )
                            {
                                CAMERA.moveDown();
                            }
                            else if (
                                (PLAYER.world_npc.position_y - CAMERA.offset.y) < (VIEWPORT.height / 2)
                                &&
                                CAMERA.offset.y > 0
                            )
                            {
                                CAMERA.moveUp();
                            }
                        }
                    }
                    var fragment = document.createDocumentFragment();
                    var viewport = document.createElement('div');
                    viewport.id = 'viewport';
                    viewport.innerHTML = uih.updatedRender();
                    fragment.appendChild(viewport);
                    uih.getViewport().replaceWith(fragment);
                    for (var a = 0; a < uih.animations.length; ++a)
                    {
                        if (uih.animations[a].render_always)
                        {
                            uih.animations[a].render();
                        }
                    }
                },
                togglePause: function ()
                {
                    RAF.is_paused = !RAF.is_paused
                    console.log(RAF.is_paused ? 'RAF paused' : 'RAF resumed')
                }
            }

            window.addEventListener('load', function ()
            {
                RAF.initialize();
                var multiplayer = URLPARAMS.get('is_multiplayer');
                if (multiplayer === 1 || multiplayer === true || multiplayer === "true" || multiplayer === "1")
                {
                    // TOOD: This
                }

                var base64 = true;
                if (base64)
                {
                    var bytes = Uint8Array.from(atob(wasmBase64), c => c.charCodeAt(0));
                    WebAssembly.instantiate(bytes, importObject).then(results => {
                        var instance = results.instance;
                        wasm = instance;

                        // NOTE: This is how you call a function that's not exported. JS calls WASM functions through the indirect function table.
                        // console.log(wasm);
                        // console.log(wasm.exports.__indirect_function_table);
                        // console.log(wasm.exports.__indirect_function_table.get(1)());

                        console.log("Starting memory:", formatMemorySize(wasm.exports.memory.buffer.byteLength));
                        console.log("Pages:", wasm.exports.memory.buffer.byteLength / 65536);

                        start_game();
                    });
                }
                else
                {
                    fetch('wasm_game.wasm')
                        .then(function(response) { return response.arrayBuffer() })
                        .then(function(bytes) { return WebAssembly.instantiate(bytes, importObject) })
                        .then(function(results) {
                            var instance = results.instance;
                            wasm = instance;

                            console.log("Starting memory:", formatMemorySize(wasm.exports.memory.buffer.byteLength));
                            console.log("Pages:", wasm.exports.memory.buffer.byteLength / 65536);

                            start_game();
                        });
                }
            });

            var should3d = false;
            function toggleShouldThreeD()
            {
                document.body.classList.toggle("should_3d");
                should3d = !should3d;
            }

            function viewportMouseDown(world_x, world_y)
            {
                // TODO: If debug mode is on for the entire game
                if (gh.editor.mode === "pull")
                {
                    // we need to pull atlas_asset_x && atlas_asset_y
                    for (var i = 0; i < LAYER.length; ++i)
                    {
                        if (LAYER[i].name_id === gh.editor.active_layer_name_id)
                        {
                            var value = get_layer_value(LAYER[i], world_x, world_y);
                            document.getElementById("wasm_value").value = value;
                            var name_id = GAME_STRINGS[LAYER[i].name_id];
                            var layer_name = "layer_" + UNDERSTRINGS[name_id];
                            if (
                                LAYER_ATLAS_MAP[gh.getCurrentWorldName()]
                                &&
                                LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name]
                                &&
                                LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name][value]
                            )
                            {
                                document.getElementById("atlas_asset_x").value = LAYER_ATLAS_MAP[
                                    gh.getCurrentWorldName()
                                ][layer_name][value][0];
                                document.getElementById("atlas_asset_y").value = LAYER_ATLAS_MAP[
                                    gh.getCurrentWorldName()
                                ][layer_name][value][1];
                                gh.editorUpdateAtlasPreview();
                            }
                            break;
                        }
                    }
                }
                if (gh.editor.mode === "set")
                {
                    var wasm_value = parseInt(document.getElementById("wasm_value").value);
                    var atlas_x = parseInt(document.getElementById("atlas_asset_x").value);
                    var atlas_y = parseInt(document.getElementById("atlas_asset_y").value);
                    var layer_id = gh.editor.active_layer_id;
                    gh.editorSetLayerCoordinatesValue(layer_id, world_x, world_y, wasm_value);
                    if (!LAYER_ATLAS_MAP[gh.getCurrentWorldName()])
                    {
                        LAYER_ATLAS_MAP[gh.getCurrentWorldName()] = [];
                    }
                    if (!LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name])
                    {
                        LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name] = [];
                    }
                    if (!LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name][wasm_value])
                    {
                        LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name][wasm_value] = [];
                    }
                    LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name][wasm_value][0] = atlas_x;
                    LAYER_ATLAS_MAP[gh.getCurrentWorldName()][layer_name][wasm_value][1] = atlas_y;
                }
            }

            function viewportMouseMove(viewport_x, viewport_y, world_x, world_y)
            {
                document.getElementById("debug_viewport_x").innerHTML = "Viewport X: " + viewport_x;
                document.getElementById("debug_viewport_y").innerHTML = "Viewport Y: " + viewport_y;
                document.getElementById("debug_world_x").innerHTML = "World X: " + world_x;
                document.getElementById("debug_world_y").innerHTML = "World Y: " + world_y;
                var layer_value_el = document.getElementById("debug_layer_value");
                layer_value_el.innerHTML = "";
                for (var i = 0; i < LAYER.length; ++i)
                {
                    var name_id = GAME_STRINGS[LAYER[i].name_id];
                    var name = STRINGS[name_id];
                    var value = get_layer_value(LAYER[i], world_x, world_y);
                    layer_value_el.innerHTML += `<div>Layer ${name}: ${value}</div>`;
                }
            }

            var game_mode;
            var TILE_SIZE = 16;
            var TILE_SCALE = 2;
            var TILE_SIZE_SCALED = TILE_SIZE * TILE_SCALE;
            var degx = 0;
            var degy = 65;
            function start_game()
            {
                console.log('Starting game here');

                VIEWPORT.width = 12;
                VIEWPORT.height = 12;
                uih.updateRootProperties();
                wasm.exports.initialize_game();
                console.log("Current memory:", formatMemorySize(wasm.exports.memory.buffer.byteLength));
                gh.initialize();
                if (gh.current.game_mode == GAME_STRINGS.indexOf("GAME_MODE_EMPTY"))
                {
                    uih.initialize();
                    console.log("GAME IS EMPTY. STARTING RAF");
                    requestAnimationFrame(RAF.animate);
                }

                var ctrl_down = false;
                document.addEventListener('mousemove', function (e)
                {
                    if (should3d && ctrl_down)
                    {
                        degx += e.movementX;
                        degy += e.movementY;
                    }
                });

                document.addEventListener('keydown', function (e)
                {
                    switch (e.code)
                    {
                        case "ControlLeft":
                            ctrl_down = true;
                            break;
                        case "KeyA":
                            wasm.exports.user_input_left();
                            break;
                        case "KeyD":
                            wasm.exports.user_input_right();
                            break;
                        case "KeyW":
                            wasm.exports.user_input_up();
                            break;
                        case "KeyS":
                            wasm.exports.user_input_down();
                            break;
                    }
                });

                document.addEventListener('keyup', function (e)
                {
                    if (IS_MULTIPLAYER && e.target.matches("#multiplayer-chat-message-input"))
                    {
                        ctrl_down = false;
                        return;
                    }
                    var should_redraw = true;
                    switch (e.code)
                    {
                        case "ControlLeft":
                            ctrl_down = false;
                            should_redraw = false;
                            break;
                        case "KeyZ":
                            wasm.exports.user_input_a();
                            break;
                        case "KeyX":
                            wasm.exports.user_input_b();
                            break;
                        case "KeyC":
                            wasm.exports.user_input_x();
                            break;
                        case "KeyV":
                            wasm.exports.user_input_y();
                            break;
                        // case "KeyA":
                        //     wasm.exports.user_input_left();
                        //     break;
                        // case "KeyD":
                        //     wasm.exports.user_input_right();
                        //     break;
                        // case "KeyW":
                        //     wasm.exports.user_input_up();
                        //     break;
                        // case "KeyS":
                        //     wasm.exports.user_input_down();
                        //     break;
                        case "KeyQ":
                            wasm.exports.user_input_left_bumper();
                            break;
                        case "KeyE":
                            wasm.exports.user_input_right_bumper();
                            break;
                        case "KeyT":
                            wasm.exports.user_input_start();
                            break;
                        case "KeyG":
                            wasm.exports.user_input_select();
                            break;
                        case "KeyI":
                            // TODO: These won't work because we update the viewport every frame
                            // Do a forced camera move and then add a reset button of some kind
                            CAMERA.moveUp();
                            break;
                        case "KeyK":
                            CAMERA.moveDown();
                            break;
                        case "KeyJ":
                            CAMERA.moveLeft();
                            break;
                        case "KeyL":
                            CAMERA.moveRight();
                            break;
                        case "KeyM":
                            document.getElementById("meta-game").style.display = "block";
                            break;
                        case "KeyP":
                            RAF.togglePause();
                            break;
                        default:
                            should_redraw = false;
                            break;
                    }
                    if (should_redraw)
                    {
                        gh.shouldRedrawEverything();
                    }
                })
            }

            var debug_blocks = false;
            function toggleBlocks()
            {
                debug_blocks = !debug_blocks;
            }
            var debug_entities = false;
            function toggleEntities()
            {
                debug_entities = !debug_entities;
            }
        </script>
    </head>
    <body style="padding: 0px; margin: 0px;">
        <div id="viewport" style="display: none;"></div>

        <div class="popup" id="meta-game">
            <div class="grid">
                <div id="meta-game-drag-handle" class="drag-bar svg svg-handle-bar-white"></div>
                <div id="meta-content">
                    <button id="help" onclick="uih.toggleHelp();">Help</button>
                    <button id="debug" onclick="wasm.exports.test();">DEBUG</button>
                    <button id="should3d" onclick="toggleShouldThreeD();">3D</button>
                    <button id="toggle_blocks" onclick="toggleBlocks();">Toggle Blocks</button>
                    <button id="toggle_entities" onclick="toggleEntities();">Toggle Entities</button>
                    <button id="raf_toggle_pause" onclick="RAF.togglePause();">Pause Unpause Anims</button>
                    <button id="editor_hide" onclick="gh.editorHide()">Hide</button>
                    <button id="load_athens" onclick="wasm.exports.generate_world(GAME_STRINGS.indexOf('WORLD_ATHENS'))">Load Athens</button>
                    <div>
                        <div id="debug_viewport_x">Viewport X: 0</div>
                        <div id="debug_viewport_y">Viewport Y: 0</div>
                    </div>
                    <div>
                        <div id="debug_world_x">World X: 0</div>
                        <div id="debug_world_y">World Y: 0</div>
                        <div id="debug_layer_value">Layer Value: 0</div>
                    </div>
                    <button id="pull_layer_value" onclick="gh.editorSetModeToPull();">Pull Value</button>
                    <button id="set_layer_value" onclick="gh.editorSetModeToSet();">Set Value</button>
                    <div id="layers">
                        <div>Layers</div>
                        <button id="get_layers" onclick="gh.editorGetLayers();">Get Layers</button>
                        <div id="layers_list" style="display: grid; grid-auto-flow: row;"></div>
                    </div>
                    <div id="atlas_assets">
                        <div>Atlas</div>
                        <div style="display: grid; grid-auto-flow: column; align-items: center; margin-bottom: 10px;">
                            <div>V:</div>
                            <input type="number" id="wasm_value" style="width: 80px;" />
                        </div>
                        <div id="atlas_asset" style="display: grid; grid-gap: 10px;">
                            <div style="display: grid; grid-auto-flow: column; align-items: center;">
                                <div>X:</div>
                                <div><input type="number" value="0" id="atlas_asset_x" style="width: 80px;" onchange="gh.editorUpdateAtlasPreview()" /></div>
                            </div>
                            <div style="display: grid; grid-auto-flow: column; align-items: center;">
                                <div>Y:</div>
                                <div><input type="number" value="1" id="atlas_asset_y" style="width: 80px;" onchange="gh.editorUpdateAtlasPreview()" /></div>
                            </div>
                            <div id="atlas_preview"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <dialog id="help_dialog" class="popup">
            <header>Help</header>
            <p>TODO: Mouse (not currently working)</p>
            <p>Keyboard</p>
            <table>
                <tr>
                    <td>Key</td>
                    <td>Action</td>
                </tr>
                <tr>
                    <td>W</td>
                    <td>Up</td>
                </tr>
                <tr>
                    <td>S</td>
                    <td>Down</td>
                </tr>
                <tr>
                    <td>A</td>
                    <td>Left</td>
                </tr>
                <tr>
                    <td>D</td>
                    <td>Right</td>
                </tr>
                <tr>
                    <td>Z</td>
                    <td>A/Confirm</td>
                </tr>
                <tr>
                    <td>X</td>
                    <td>B/Back</td>
                </tr>
                <tr>
                    <td>I</td>
                    <td>Move Camera Up</td>
                </tr>
                <tr>
                    <td>K</td>
                    <td>Move Camera Down</td>
                </tr>
                <tr>
                    <td>J</td>
                    <td>Move Camera Left</td>
                </tr>
                <tr>
                    <td>L</td>
                    <td>Move Camera Right</td>
                </tr>
            </table>
            <p>If you toggle 3D mode on, just hold down the Left CTRL key and drag the mouse around the screen. The entire world will rotate in 3D.</p>
            <form method="dialog">
                <button>ok</button>
            </form>
        </dialog>
        <div id="inventory_menu"></div>
        <div id="player_menu"></div>
        <div id="scene_single_dialog"></div>
        <div id="bank"></div>
        <div id="blackjack"></div>
        <ui-shipyard></ui-shipyard>
        <div id="ocean_battle"></div>
    </body>
</html>
