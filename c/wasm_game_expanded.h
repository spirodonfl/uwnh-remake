# 1 "wasm_game.h"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 361 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "wasm_game.h" 2
# 1 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdint.h" 1 3
# 52 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 464 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 465 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdint.h" 2 3
# 2 "wasm_game.h" 2
# 1 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 1 3
# 35 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 46 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 3
typedef long unsigned int size_t;
# 74 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 3
typedef int wchar_t;
# 102 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 3
# 1 "/usr/lib/llvm-14/lib/clang/14.0.0/include/__stddef_max_align_t.h" 1 3
# 19 "/usr/lib/llvm-14/lib/clang/14.0.0/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 103 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stddef.h" 2 3
# 3 "wasm_game.h" 2
# 1 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdarg.h" 1 3
# 14 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdarg.h" 3
typedef __builtin_va_list va_list;
# 32 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 4 "wasm_game.h" 2
# 1 "/usr/lib/llvm-14/lib/clang/14.0.0/include/stdbool.h" 1 3
# 5 "wasm_game.h" 2
# 15 "wasm_game.h"
typedef uint32_t u32;
typedef uint32_t u8;

void console_log(const char* message);
unsigned long my_strlen(const char* str)
{
    unsigned long len = 0;
    while (str[len] != '\0') len++;
    return len;
}
u32 my_strcmp(const char* str1, const char* str2)
{

    if (!str1 || !str2) return -1;


    while (*str1 && *str2) {
        if (*str1 != *str2) {
            break;
        }
        str1++;
        str2++;
    }


    return (u32)((unsigned char)*str1 - (unsigned char)*str2);
}
u32 my_floor(u32 x, u32 multiple)
{
    return x - (x % multiple);
}
u32 my_floor_percentage(u32 value, u32 percentage)
{
    return (value * percentage) / 100;
}


u32 get_sentry()
{
    return (4294967295U);
}
extern void js_console_log(void* ptr, u32 len);
extern void js_output_string_buffer(void* ptr, uint32_t len);
extern void js_output_array_buffer(void* ptr, uint32_t len);
void console_log(const char* message)
{
    if (message != ((void*)0))
    {
        js_console_log((void*)message, (u32)(sizeof(char) * my_strlen(message)));
    }
}

typedef union {
    int i;
    const char* s;
    void* p;
} FormatArg;
FormatArg args[100];
char* string_format(const char* format, FormatArg* args, int arg_count) {
    static char local_buffer[1024];


    for (u32 i = 0; i < 1024; i++) {
        local_buffer[i] = '\0';
    }

    u32 pos = 0;
    const char* p = format;
    int current_arg = 0;

    while (*p && pos < 1024 - 1) {
        if (*p != '%') {
            local_buffer[pos++] = *p++;
            continue;
        }

        p++;
        if (current_arg >= arg_count) break;

        switch (*p) {
            case 'd': {
                int val = args[current_arg++].i;
                if (val < 0) {
                    local_buffer[pos++] = '-';
                    val = -val;
                }

                char temp[12];
                u32 temp_pos = 0;

                if (val == 0) {
                    temp[temp_pos++] = '0';
                } else {
                    while (val > 0 && temp_pos < 11) {
                        temp[temp_pos++] = '0' + (val % 10);
                        val /= 10;
                    }
                    for (u32 i = 0; i < temp_pos / 2; i++) {
                        char t = temp[i];
                        temp[i] = temp[temp_pos - 1 - i];
                        temp[temp_pos - 1 - i] = t;
                    }
                }

                for (u32 i = 0; i < temp_pos; i++) {
                    local_buffer[pos++] = temp[i];
                }
                break;
            }
            case 's': {
                const char* str = args[current_arg++].s;
                if (str) {
                    while (*str && pos < 1024 - 1) {
                        local_buffer[pos++] = *str++;
                    }
                }
                break;
            }
        }
        p++;
    }

    local_buffer[pos] = '\0';
    return local_buffer;
}
void console_log_format(const char* format, FormatArg* args, int arg_count) {
    char* formatted = string_format(format, args, arg_count);
    console_log(formatted);
}

u32 max(u32 a, u32 b)
{
    return a > b ? a : b;
}
# 295 "wasm_game.h"
u32 get_max_npcs() { return 100; }

u32 get_max_weapons() { return 100; }

u32 get_max_armors() { return 100; }

u32 get_max_general_items() { return 100; }

u32 get_max_special_items() { return 100; }


u32 get_max_inventories() { return 100; }





u32 get_max_fleets() { return 100; }

u32 get_max_fleet_ships() { return 100; }


u32 get_max_cannons() { return 100; }

u32 get_max_figureheads() { return 100; }

u32 get_max_worlds() { return 100; }

u32 get_max_layers() { return 10; }

u32 get_max_world_npcs() { return 1000; }


u32 get_max_ships() { return 100; }

u32 get_max_ship_materials() { return 100; }

u32 get_max_base_ships() { return 100; }


u32 get_max_captains() { return 100; }






u32 get_max_goods() { return 100; }
# 355 "wasm_game.h"
u32 get_player_npc_id(u32 player_id);

void move_player_left(u32 player_id);
void move_player_right(u32 player_id);
void move_player_up(u32 player_id);
void move_player_down(u32 player_id);

void handle_input(u32 input);

u32 get_player_in_world(u32 player_id);
u32 get_player_in_world_x(u32 player_id);
u32 get_player_in_world_y(u32 player_id);

void fake_ocean_battle();
u32 scene_blackjack(u32 action);
u32 scene_general_shop(u32 action);
u32 scene_goods_shop(u32 action);
u32 scene_ocean_battle(u32 action);
u32 scene_shipyard(u32 action);
u32 scene_dockyard(u32 action);
u32 scene_npc_rvice(u32 action);
u32 scene_npc_lafolie(u32 action);
u32 scene_npc_nakor(u32 action);
u32 scene_npc_travis(u32 action);
u32 scene_npc_loller(u32 action);
u32 scene_bank(u32 action);
u32 scene_test(u32 action);

void generate_world(u32 world_name_id);

void update_npc_layer(u32 world_npc_id);

void test();




enum UserInput
{
    USER_INPUT_A,
    USER_INPUT_B,
    USER_INPUT_X,
    USER_INPUT_Y,
    USER_INPUT_UP,
    USER_INPUT_DOWN,
    USER_INPUT_LEFT,
    USER_INPUT_RIGHT,
    USER_INPUT_START,
    USER_INPUT_SELECT,
    USER_INPUT_LEFT_BUMPER,
    USER_INPUT_RIGHT_BUMPER,
    USER_INPUT_CUSTOM_NUMBER,
    USER_INPUT_CUSTOM_STRING,
};


typedef struct __attribute__((packed))
{

    u32 id;
    u32 flags[10];
    u32 strings[10];

    u32 actions[10];


    u32 action_flags[10];
    u32 error_code;
} DATA_SCENE;


typedef struct __attribute__((packed))
{
    u32 id;
    u32 dialog_id;
    u32 flag_initialized;
    u32 flag_confirmed;
    u32 previous_game_mode;
    u32 error_code;
} DATA_SCENE_SINGLE_DIALOG;
DATA_SCENE_SINGLE_DIALOG Scene_Single_Dialog;
u32* get_data_scene_single_dialog_ptr()
{ return (u32*)&Scene_Single_Dialog; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 flag_confirmed;
    u32 flag_bought;
    u32 previous_game_mode;
    u32 inventory_id;
    u32 chosen_items[100];
    u32 error_code;
} DATA_SCENE_GENERAL_SHOP;
DATA_SCENE_GENERAL_SHOP Scene_General_Shop;
u32* get_data_scene_general_shop_ptr()
{ return (u32*)&Scene_General_Shop; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 flag_confirmed;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;
} DATA_SCENE_BLACKJACK;
DATA_SCENE_BLACKJACK Scene_Blackjack;
u32* get_data_scene_blackjack_ptr()
{ return (u32*)&Scene_Blackjack; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;
} DATA_SCENE_BANK;
DATA_SCENE_BANK Scene_Bank;
u32* get_data_scene_bank_ptr()
{ return (u32*)&Scene_Bank; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;
    u32 inventory_id;
    u32 loading_fleet_ships[(100 * 20)];
    u32 loading_qty[(100 * 20)];
    u32 intended_good_id;
    u32 intended_good_qty;
} DATA_SCENE_GOODS_SHOP;
DATA_SCENE_GOODS_SHOP Scene_Goods_Shop;
u32* get_data_scene_goods_shop_ptr()
{ return (u32*)&Scene_Goods_Shop; }
void clear_scene_goods_shop()
{
    Scene_Goods_Shop.flag_initialized = 0;
    Scene_Goods_Shop.error_code = (4294967295U);
    Scene_Goods_Shop.dialog_id = (4294967295U);
    Scene_Goods_Shop.inventory_id = (4294967295U);
    Scene_Goods_Shop.intended_good_id = (4294967295U);
    Scene_Goods_Shop.intended_good_qty = (4294967295U);
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        Scene_Goods_Shop.loading_fleet_ships[i] = (4294967295U);
        Scene_Goods_Shop.loading_qty[i] = 0;
    }
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;
} DATA_SCENE_TEST;
DATA_SCENE_TEST Scene_Test;
u32* get_data_scene_test_ptr()
{ return (u32*)&Scene_Test; }


typedef struct __attribute__((packed))
{
    u32 deposit_interest_rate;
    u32 loan_interest_rate;
    u32 deposit_amount;
    u32 loan_amount;
    u32 deposit_max_amount;
    u32 loan_max_amount;
    u32 to_deposit;
    u32 to_loan;
    u32 to_pay_loan;
    u32 to_withdraw;
} DATA_BANK;
DATA_BANK bank;
u32* get_data_bank_ptr()
{ return (u32*)&bank; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 type_id;
    u32 name_id;
} DATA_NPC;

u32 storage_npc_used_slots[100];
u32* get_storage_npc_used_slots_ptr()
{ return (u32*)&storage_npc_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_NPC data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_NPC; STORAGE_DATA_NPC storage_npc; u32 find_next_storage_npc_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_npc.used[i] == 0) { storage_npc.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_npc_next_open_slot() { return storage_npc.next_open_slot; } u32 get_storage_npc_total_used_slots() { return storage_npc.count; } void update_storage_npc_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_npc.used[i] == 1) { storage_npc_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_npc_used_slots[usi] = (4294967295U); } ++usi; } storage_npc.count = total; } u32 pull_storage_npc_next_open_slot() { u32 current_count = storage_npc.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "npc" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_npc.next_open_slot; storage_npc.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_npc.data[current_open_slot]; u32 count = (sizeof(*&storage_npc.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_npc.count; storage_npc.data[current_open_slot].id = current_open_slot; find_next_storage_npc_open_slot(); update_storage_npc_used_slots(); return current_open_slot; } u32* get_data_npc_ptr(u32 id) { return (u32*)&storage_npc.data[id]; } DATA_NPC* get_data_npc(u32 id) { return &storage_npc.data[id]; } DATA_NPC* pull_data_npc() { u32 new_id = pull_storage_npc_next_open_slot(); return &storage_npc.data[new_id]; } void free_storage_npc_slot(u32 id) { if (storage_npc.used[id] == 1) { storage_npc.used[id] = 0; } update_storage_npc_used_slots(); find_next_storage_npc_open_slot(); }
u32 find_storage_npc_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_npc.used[i] == 1 && storage_npc.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_npc(u32 id, DATA_NPC* source)
{
    storage_npc.data[id].id = id;
    source->id = id;
    storage_npc.data[id].name_id = source->name_id;
    storage_npc.data[id].type_id = source->type_id;
}
u32 add_storage_npc(DATA_NPC* source, _Bool force_clear) { u32 new_id = pull_storage_npc_next_open_slot(); assign_storage_npc(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
} DATA_GENERAL_ITEM;

u32 storage_general_item_used_slots[100];
u32* get_storage_general_item_used_slots_ptr()
{ return (u32*)&storage_general_item_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_GENERAL_ITEM data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_GENERAL_ITEM; STORAGE_DATA_GENERAL_ITEM storage_general_item; u32 find_next_storage_general_item_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_general_item.used[i] == 0) { storage_general_item.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_general_item_next_open_slot() { return storage_general_item.next_open_slot; } u32 get_storage_general_item_total_used_slots() { return storage_general_item.count; } void update_storage_general_item_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_general_item.used[i] == 1) { storage_general_item_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_general_item_used_slots[usi] = (4294967295U); } ++usi; } storage_general_item.count = total; } u32 pull_storage_general_item_next_open_slot() { u32 current_count = storage_general_item.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "general_item" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_general_item.next_open_slot; storage_general_item.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_general_item.data[current_open_slot]; u32 count = (sizeof(*&storage_general_item.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_general_item.count; storage_general_item.data[current_open_slot].id = current_open_slot; find_next_storage_general_item_open_slot(); update_storage_general_item_used_slots(); return current_open_slot; } u32* get_data_general_item_ptr(u32 id) { return (u32*)&storage_general_item.data[id]; } DATA_GENERAL_ITEM* get_data_general_item(u32 id) { return &storage_general_item.data[id]; } DATA_GENERAL_ITEM* pull_data_general_item() { u32 new_id = pull_storage_general_item_next_open_slot(); return &storage_general_item.data[new_id]; } void free_storage_general_item_slot(u32 id) { if (storage_general_item.used[id] == 1) { storage_general_item.used[id] = 0; } update_storage_general_item_used_slots(); find_next_storage_general_item_open_slot(); }
u32 find_storage_general_item_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_general_item.used[i] == 1 && storage_general_item.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_general_item(u32 id, DATA_GENERAL_ITEM* source)
{
    storage_general_item.data[id].id = id;
    source->id = id;
    storage_general_item.data[id].name_id = source->name_id;
    storage_general_item.data[id].base_price = source->base_price;
}
u32 add_storage_general_item(DATA_GENERAL_ITEM* source, _Bool force_clear) { u32 new_id = pull_storage_general_item_next_open_slot(); assign_storage_general_item(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 top_material_id;
    u32 base_price;

    u32 max_capacity;

    u32 tacking;

    u32 power;

    u32 speed;

    u32 durability;
} DATA_BASE_SHIP;

u32 storage_base_ship_used_slots[100];
u32* get_storage_base_ship_used_slots_ptr()
{ return (u32*)&storage_base_ship_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_BASE_SHIP data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_BASE_SHIP; STORAGE_DATA_BASE_SHIP storage_base_ship; u32 find_next_storage_base_ship_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_base_ship.used[i] == 0) { storage_base_ship.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_base_ship_next_open_slot() { return storage_base_ship.next_open_slot; } u32 get_storage_base_ship_total_used_slots() { return storage_base_ship.count; } void update_storage_base_ship_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_base_ship.used[i] == 1) { storage_base_ship_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_base_ship_used_slots[usi] = (4294967295U); } ++usi; } storage_base_ship.count = total; } u32 pull_storage_base_ship_next_open_slot() { u32 current_count = storage_base_ship.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "base_ship" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_base_ship.next_open_slot; storage_base_ship.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_base_ship.data[current_open_slot]; u32 count = (sizeof(*&storage_base_ship.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_base_ship.count; storage_base_ship.data[current_open_slot].id = current_open_slot; find_next_storage_base_ship_open_slot(); update_storage_base_ship_used_slots(); return current_open_slot; } u32* get_data_base_ship_ptr(u32 id) { return (u32*)&storage_base_ship.data[id]; } DATA_BASE_SHIP* get_data_base_ship(u32 id) { return &storage_base_ship.data[id]; } DATA_BASE_SHIP* pull_data_base_ship() { u32 new_id = pull_storage_base_ship_next_open_slot(); return &storage_base_ship.data[new_id]; } void free_storage_base_ship_slot(u32 id) { if (storage_base_ship.used[id] == 1) { storage_base_ship.used[id] = 0; } update_storage_base_ship_used_slots(); find_next_storage_base_ship_open_slot(); }
u32 find_storage_base_ship_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_base_ship.used[i] == 1 && storage_base_ship.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_base_ship(u32 id, DATA_BASE_SHIP* source)
{
    storage_base_ship.data[id].id = id;
    storage_base_ship.data[id].name_id = source->name_id;
    storage_base_ship.data[id].top_material_id = source->top_material_id;
    storage_base_ship.data[id].base_price = source->base_price;
    storage_base_ship.data[id].max_capacity = source->max_capacity;
    storage_base_ship.data[id].tacking = source->tacking;
    storage_base_ship.data[id].power = source->power;
    storage_base_ship.data[id].speed = source->speed;
    storage_base_ship.data[id].durability = source->durability;
}
u32 add_storage_base_ship(DATA_BASE_SHIP* source, _Bool force_clear) { u32 new_id = pull_storage_base_ship_next_open_slot(); assign_storage_base_ship(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }

typedef struct __attribute__((packed))
{
    u32 good_id;
    u32 name_id;
    u32 some_other_id;
} DATA_TEST;


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_ship_id;
    u32 price;
    u32 material_id;
    u32 capacity;
    u32 tacking;
    u32 power;
    u32 speed;
    u32 durability;
    u32 crew;
    u32 crew_space;
    u32 cargo_space;
    u32 cannon_space;

    u32 cannons;

    u32 cannon_type_id;
    u32 cargo_goods[1000];
    u32 cargo_goods_qty[1000];
    u32 total_cargo_goods;
    u32 figurehead_id;
    DATA_TEST test[10];
} DATA_SHIP;

u32 storage_ship_used_slots[100];
u32* get_storage_ship_used_slots_ptr()
{ return (u32*)&storage_ship_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_SHIP data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_SHIP; STORAGE_DATA_SHIP storage_ship; u32 find_next_storage_ship_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_ship.used[i] == 0) { storage_ship.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_ship_next_open_slot() { return storage_ship.next_open_slot; } u32 get_storage_ship_total_used_slots() { return storage_ship.count; } void update_storage_ship_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_ship.used[i] == 1) { storage_ship_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_ship_used_slots[usi] = (4294967295U); } ++usi; } storage_ship.count = total; } u32 pull_storage_ship_next_open_slot() { u32 current_count = storage_ship.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "ship" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_ship.next_open_slot; storage_ship.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_ship.data[current_open_slot]; u32 count = (sizeof(*&storage_ship.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_ship.count; storage_ship.data[current_open_slot].id = current_open_slot; find_next_storage_ship_open_slot(); update_storage_ship_used_slots(); return current_open_slot; } u32* get_data_ship_ptr(u32 id) { return (u32*)&storage_ship.data[id]; } DATA_SHIP* get_data_ship(u32 id) { return &storage_ship.data[id]; } DATA_SHIP* pull_data_ship() { u32 new_id = pull_storage_ship_next_open_slot(); return &storage_ship.data[new_id]; } void free_storage_ship_slot(u32 id) { if (storage_ship.used[id] == 1) { storage_ship.used[id] = 0; } update_storage_ship_used_slots(); find_next_storage_ship_open_slot(); }
u32 find_storage_ship_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_ship.used[i] == 1 && storage_ship.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_ship(u32 id, DATA_SHIP* source)
{
    storage_ship.data[id].id = id;
    storage_ship.data[id].name_id = source->name_id;
    storage_ship.data[id].base_ship_id = source->base_ship_id;
    storage_ship.data[id].price = source->price;
    storage_ship.data[id].material_id = source->material_id;
    storage_ship.data[id].capacity = source->capacity;
    storage_ship.data[id].tacking = source->tacking;
    storage_ship.data[id].power = source->power;
    storage_ship.data[id].speed = source->speed;
    storage_ship.data[id].crew = source->crew;
    storage_ship.data[id].cannons = source->cannons;
    storage_ship.data[id].cannon_type_id = source->cannon_type_id;
    storage_ship.data[id].durability = source->durability;
    storage_ship.data[id].total_cargo_goods = source->total_cargo_goods;
    storage_ship.data[id].figurehead_id = source->figurehead_id;
    for (u32 i = 0; i < 1000; ++i)
    {
        storage_ship.data[id].cargo_goods[i] = source->cargo_goods[i];
    }
    for (u32 i = 0; i < 1000; ++i)
    {
        storage_ship.data[id].cargo_goods_qty[i] = source->cargo_goods_qty[i];
    }
}
u32 add_storage_ship(DATA_SHIP* source, _Bool force_clear) { u32 new_id = pull_storage_ship_next_open_slot(); assign_storage_ship(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
    u32 mod_power;
    u32 mod_capacity;
    u32 mod_tacking;
    u32 mod_speed;
    u32 mod_durability;
} DATA_SHIP_MATERIAL;

u32 storage_ship_material_used_slots[100];
u32* get_storage_ship_material_used_slots_ptr()
{ return (u32*)&storage_ship_material_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_SHIP_MATERIAL data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_SHIP_MATERIAL; STORAGE_DATA_SHIP_MATERIAL storage_ship_material; u32 find_next_storage_ship_material_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_ship_material.used[i] == 0) { storage_ship_material.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_ship_material_next_open_slot() { return storage_ship_material.next_open_slot; } u32 get_storage_ship_material_total_used_slots() { return storage_ship_material.count; } void update_storage_ship_material_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_ship_material.used[i] == 1) { storage_ship_material_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_ship_material_used_slots[usi] = (4294967295U); } ++usi; } storage_ship_material.count = total; } u32 pull_storage_ship_material_next_open_slot() { u32 current_count = storage_ship_material.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "ship_material" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_ship_material.next_open_slot; storage_ship_material.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_ship_material.data[current_open_slot]; u32 count = (sizeof(*&storage_ship_material.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_ship_material.count; storage_ship_material.data[current_open_slot].id = current_open_slot; find_next_storage_ship_material_open_slot(); update_storage_ship_material_used_slots(); return current_open_slot; } u32* get_data_ship_material_ptr(u32 id) { return (u32*)&storage_ship_material.data[id]; } DATA_SHIP_MATERIAL* get_data_ship_material(u32 id) { return &storage_ship_material.data[id]; } DATA_SHIP_MATERIAL* pull_data_ship_material() { u32 new_id = pull_storage_ship_material_next_open_slot(); return &storage_ship_material.data[new_id]; } void free_storage_ship_material_slot(u32 id) { if (storage_ship_material.used[id] == 1) { storage_ship_material.used[id] = 0; } update_storage_ship_material_used_slots(); find_next_storage_ship_material_open_slot(); }
u32 find_storage_ship_material_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_ship_material.used[i] == 1 && storage_ship_material.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_ship_material(u32 id, DATA_SHIP_MATERIAL* source)
{
    storage_ship_material.data[id].id = id;
    storage_ship_material.data[id].name_id = source->name_id;
    storage_ship_material.data[id].base_price = source->base_price;
    storage_ship_material.data[id].mod_power = source->mod_power;
    storage_ship_material.data[id].mod_capacity = source->mod_capacity;
    storage_ship_material.data[id].mod_tacking = source->mod_tacking;
    storage_ship_material.data[id].mod_speed = source->mod_speed;
    storage_ship_material.data[id].mod_durability = source->mod_durability;
}
u32 add_storage_ship_material(DATA_SHIP_MATERIAL* source, _Bool force_clear) { u32 new_id = pull_storage_ship_material_next_open_slot(); assign_storage_ship_material(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
void clear_ship_material(u32 id)
{
    storage_ship_material.data[id].name_id = (4294967295U);
    storage_ship_material.data[id].base_price = (4294967295U);
    storage_ship_material.data[id].mod_power = (4294967295U);
    storage_ship_material.data[id].mod_capacity = (4294967295U);
    storage_ship_material.data[id].mod_tacking = (4294967295U);
    storage_ship_material.data[id].mod_speed = (4294967295U);
    storage_ship_material.data[id].mod_durability = (4294967295U);
    free_storage_ship_material_slot(id);
}
void clear_all_ship_materials()
{
    for (u32 i = 0; i < 100; ++i)
    {
        clear_ship_material(i);
    }
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
} DATA_GOOD;

u32 storage_good_used_slots[100];
u32* get_storage_good_used_slots_ptr()
{ return (u32*)&storage_good_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_GOOD data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_GOOD; STORAGE_DATA_GOOD storage_good; u32 find_next_storage_good_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_good.used[i] == 0) { storage_good.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_good_next_open_slot() { return storage_good.next_open_slot; } u32 get_storage_good_total_used_slots() { return storage_good.count; } void update_storage_good_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_good.used[i] == 1) { storage_good_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_good_used_slots[usi] = (4294967295U); } ++usi; } storage_good.count = total; } u32 pull_storage_good_next_open_slot() { u32 current_count = storage_good.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "good" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_good.next_open_slot; storage_good.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_good.data[current_open_slot]; u32 count = (sizeof(*&storage_good.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_good.count; storage_good.data[current_open_slot].id = current_open_slot; find_next_storage_good_open_slot(); update_storage_good_used_slots(); return current_open_slot; } u32* get_data_good_ptr(u32 id) { return (u32*)&storage_good.data[id]; } DATA_GOOD* get_data_good(u32 id) { return &storage_good.data[id]; } DATA_GOOD* pull_data_good() { u32 new_id = pull_storage_good_next_open_slot(); return &storage_good.data[new_id]; } void free_storage_good_slot(u32 id) { if (storage_good.used[id] == 1) { storage_good.used[id] = 0; } update_storage_good_used_slots(); find_next_storage_good_open_slot(); }
u32 find_storage_good_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_good.used[i] == 1 && storage_good.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_good(u32 id, DATA_GOOD* source)
{
    storage_good.data[id].id = id;
    source->id = id;
    storage_good.data[id].name_id = source->name_id;
    storage_good.data[id].base_price = source->base_price;
}
u32 add_storage_good(DATA_GOOD* source, _Bool force_clear) { u32 new_id = pull_storage_good_next_open_slot(); assign_storage_good(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
    u32 power;
} DATA_WEAPON;

u32 storage_weapon_used_slots[100];
u32* get_storage_weapon_used_slots_ptr()
{ return (u32*)&storage_weapon_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_WEAPON data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_WEAPON; STORAGE_DATA_WEAPON storage_weapon; u32 find_next_storage_weapon_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_weapon.used[i] == 0) { storage_weapon.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_weapon_next_open_slot() { return storage_weapon.next_open_slot; } u32 get_storage_weapon_total_used_slots() { return storage_weapon.count; } void update_storage_weapon_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_weapon.used[i] == 1) { storage_weapon_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_weapon_used_slots[usi] = (4294967295U); } ++usi; } storage_weapon.count = total; } u32 pull_storage_weapon_next_open_slot() { u32 current_count = storage_weapon.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "weapon" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_weapon.next_open_slot; storage_weapon.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_weapon.data[current_open_slot]; u32 count = (sizeof(*&storage_weapon.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_weapon.count; storage_weapon.data[current_open_slot].id = current_open_slot; find_next_storage_weapon_open_slot(); update_storage_weapon_used_slots(); return current_open_slot; } u32* get_data_weapon_ptr(u32 id) { return (u32*)&storage_weapon.data[id]; } DATA_WEAPON* get_data_weapon(u32 id) { return &storage_weapon.data[id]; } DATA_WEAPON* pull_data_weapon() { u32 new_id = pull_storage_weapon_next_open_slot(); return &storage_weapon.data[new_id]; } void free_storage_weapon_slot(u32 id) { if (storage_weapon.used[id] == 1) { storage_weapon.used[id] = 0; } update_storage_weapon_used_slots(); find_next_storage_weapon_open_slot(); }
u32 find_storage_weapon_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_weapon.used[i] == 1 && storage_weapon.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
    u32 defense;
} DATA_ARMOR;

u32 storage_armor_used_slots[100];
u32* get_storage_armor_used_slots_ptr()
{ return (u32*)&storage_armor_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_ARMOR data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_ARMOR; STORAGE_DATA_ARMOR storage_armor; u32 find_next_storage_armor_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_armor.used[i] == 0) { storage_armor.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_armor_next_open_slot() { return storage_armor.next_open_slot; } u32 get_storage_armor_total_used_slots() { return storage_armor.count; } void update_storage_armor_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_armor.used[i] == 1) { storage_armor_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_armor_used_slots[usi] = (4294967295U); } ++usi; } storage_armor.count = total; } u32 pull_storage_armor_next_open_slot() { u32 current_count = storage_armor.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "armor" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_armor.next_open_slot; storage_armor.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_armor.data[current_open_slot]; u32 count = (sizeof(*&storage_armor.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_armor.count; storage_armor.data[current_open_slot].id = current_open_slot; find_next_storage_armor_open_slot(); update_storage_armor_used_slots(); return current_open_slot; } u32* get_data_armor_ptr(u32 id) { return (u32*)&storage_armor.data[id]; } DATA_ARMOR* get_data_armor(u32 id) { return &storage_armor.data[id]; } DATA_ARMOR* pull_data_armor() { u32 new_id = pull_storage_armor_next_open_slot(); return &storage_armor.data[new_id]; } void free_storage_armor_slot(u32 id) { if (storage_armor.used[id] == 1) { storage_armor.used[id] = 0; } update_storage_armor_used_slots(); find_next_storage_armor_open_slot(); }
u32 find_storage_armor_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_armor.used[i] == 1 && storage_armor.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
} DATA_SPECIAL_ITEM;

u32 storage_special_item_used_slots[100];
u32* get_storage_special_item_used_slots_ptr()
{ return (u32*)&storage_special_item_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_SPECIAL_ITEM data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_SPECIAL_ITEM; STORAGE_DATA_SPECIAL_ITEM storage_special_item; u32 find_next_storage_special_item_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_special_item.used[i] == 0) { storage_special_item.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_special_item_next_open_slot() { return storage_special_item.next_open_slot; } u32 get_storage_special_item_total_used_slots() { return storage_special_item.count; } void update_storage_special_item_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_special_item.used[i] == 1) { storage_special_item_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_special_item_used_slots[usi] = (4294967295U); } ++usi; } storage_special_item.count = total; } u32 pull_storage_special_item_next_open_slot() { u32 current_count = storage_special_item.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "special_item" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_special_item.next_open_slot; storage_special_item.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_special_item.data[current_open_slot]; u32 count = (sizeof(*&storage_special_item.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_special_item.count; storage_special_item.data[current_open_slot].id = current_open_slot; find_next_storage_special_item_open_slot(); update_storage_special_item_used_slots(); return current_open_slot; } u32* get_data_special_item_ptr(u32 id) { return (u32*)&storage_special_item.data[id]; } DATA_SPECIAL_ITEM* get_data_special_item(u32 id) { return &storage_special_item.data[id]; } DATA_SPECIAL_ITEM* pull_data_special_item() { u32 new_id = pull_storage_special_item_next_open_slot(); return &storage_special_item.data[new_id]; } void free_storage_special_item_slot(u32 id) { if (storage_special_item.used[id] == 1) { storage_special_item.used[id] = 0; } update_storage_special_item_used_slots(); find_next_storage_special_item_open_slot(); }
u32 find_storage_special_item_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_special_item.used[i] == 1 && storage_special_item.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 width;
    u32 height;
    u32 total_npcs;
    u32 total_captains;
    u32 total_layers;
    u32 layers[10];
} DATA_WORLD;

u32 storage_world_used_slots[100];
u32* get_storage_world_used_slots_ptr()
{ return (u32*)&storage_world_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_WORLD data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_WORLD; STORAGE_DATA_WORLD storage_world; u32 find_next_storage_world_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_world.used[i] == 0) { storage_world.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_world_next_open_slot() { return storage_world.next_open_slot; } u32 get_storage_world_total_used_slots() { return storage_world.count; } void update_storage_world_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_world.used[i] == 1) { storage_world_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_world_used_slots[usi] = (4294967295U); } ++usi; } storage_world.count = total; } u32 pull_storage_world_next_open_slot() { u32 current_count = storage_world.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "world" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_world.next_open_slot; storage_world.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_world.data[current_open_slot]; u32 count = (sizeof(*&storage_world.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_world.count; storage_world.data[current_open_slot].id = current_open_slot; find_next_storage_world_open_slot(); update_storage_world_used_slots(); return current_open_slot; } u32* get_data_world_ptr(u32 id) { return (u32*)&storage_world.data[id]; } DATA_WORLD* get_data_world(u32 id) { return &storage_world.data[id]; } DATA_WORLD* pull_data_world() { u32 new_id = pull_storage_world_next_open_slot(); return &storage_world.data[new_id]; } void free_storage_world_slot(u32 id) { if (storage_world.used[id] == 1) { storage_world.used[id] = 0; } update_storage_world_used_slots(); find_next_storage_world_open_slot(); }
u32 find_storage_world_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_world.used[i] == 1 && storage_world.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void add_layer_to_world(u32 layer_id, u32 world_id)
{
    u32 current_i = storage_world.data[world_id].total_layers;
    storage_world.data[world_id].layers[current_i] = layer_id;
    ++storage_world.data[world_id].total_layers;
}
void assign_storage_world(u32 id, DATA_WORLD* source)
{
    storage_world.data[id].id = id;
    storage_world.data[id].name_id = source->name_id;
    storage_world.data[id].width = source->width;
    storage_world.data[id].height = source->height;
    storage_world.data[id].total_npcs = source->total_npcs;
    storage_world.data[id].total_captains = source->total_captains;
    storage_world.data[id].total_layers = source->total_layers;
    for (u32 i = 0; i < 10; ++i)
    {
        storage_world.data[id].layers[i] = source->layers[i];
    }
}
u32 add_storage_world(DATA_WORLD* source, _Bool force_clear) { u32 new_id = pull_storage_world_next_open_slot(); assign_storage_world(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 npc_id;
    u32 position_x;
    u32 position_y;
    u32 direction;
    u32 is_interactable;
    u32 is_captain;
    u32 interaction_scene;
    u32 is_player;
    u32 inventory_id;
    u32 entity_id;
    u32 captain_id;
    u32 type_id;
} DATA_WORLD_NPC;

u32 storage_world_npc_used_slots[1000];
u32* get_storage_world_npc_used_slots_ptr()
{ return (u32*)&storage_world_npc_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_WORLD_NPC data[1000]; _Bool used[1000]; u32 count; u32 next_open_slot; } STORAGE_DATA_WORLD_NPC; STORAGE_DATA_WORLD_NPC storage_world_npc; u32 find_next_storage_world_npc_open_slot() { for (u32 i = 0; i < 1000; ++i) { if (storage_world_npc.used[i] == 0) { storage_world_npc.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_world_npc_next_open_slot() { return storage_world_npc.next_open_slot; } u32 get_storage_world_npc_total_used_slots() { return storage_world_npc.count; } void update_storage_world_npc_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 1000; ++i) { if (storage_world_npc.used[i] == 1) { storage_world_npc_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_world_npc_used_slots[usi] = (4294967295U); } ++usi; } storage_world_npc.count = total; } u32 pull_storage_world_npc_next_open_slot() { u32 current_count = storage_world_npc.count; if (current_count + 1 >= 1000) { console_log("[E] No more room left in " "world_npc" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_world_npc.next_open_slot; storage_world_npc.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_world_npc.data[current_open_slot]; u32 count = (sizeof(*&storage_world_npc.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_world_npc.count; storage_world_npc.data[current_open_slot].id = current_open_slot; find_next_storage_world_npc_open_slot(); update_storage_world_npc_used_slots(); return current_open_slot; } u32* get_data_world_npc_ptr(u32 id) { return (u32*)&storage_world_npc.data[id]; } DATA_WORLD_NPC* get_data_world_npc(u32 id) { return &storage_world_npc.data[id]; } DATA_WORLD_NPC* pull_data_world_npc() { u32 new_id = pull_storage_world_npc_next_open_slot(); return &storage_world_npc.data[new_id]; } void free_storage_world_npc_slot(u32 id) { if (storage_world_npc.used[id] == 1) { storage_world_npc.used[id] = 0; } update_storage_world_npc_used_slots(); find_next_storage_world_npc_open_slot(); }
u32 find_storage_world_npc_by_name_id(u32 name_id) { for (u32 i = 0; i < 1000; ++i) { if ( storage_world_npc.used[i] == 1 && storage_world_npc.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void clear_all_world_npcs()
{
    for (u32 i = 0; i < 1000; ++i)
    {
        free_storage_world_npc_slot(i);
    }
}
void assign_storage_world_npc(u32 id, DATA_WORLD_NPC* source)
{
    storage_world_npc.data[id].id = id;
    source->id = id;
    storage_world_npc.data[id].name_id = source->name_id;
    storage_world_npc.data[id].npc_id = source->npc_id;
    storage_world_npc.data[id].position_x = source->position_x;
    storage_world_npc.data[id].position_y = source->position_y;
    storage_world_npc.data[id].direction = source->direction;
    storage_world_npc.data[id].is_interactable = source->is_interactable;
    storage_world_npc.data[id].is_captain = source->is_captain;
    storage_world_npc.data[id].interaction_scene = source->interaction_scene;
    storage_world_npc.data[id].is_player = source->is_player;
    storage_world_npc.data[id].inventory_id = source->inventory_id;
    storage_world_npc.data[id].entity_id = source->entity_id;
    storage_world_npc.data[id].captain_id = source->captain_id;
    storage_world_npc.data[id].type_id = source->type_id;
}
u32 add_storage_world_npc(DATA_WORLD_NPC* source, _Bool force_clear) { u32 new_id = pull_storage_world_npc_next_open_slot(); assign_storage_world_npc(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 npc_id;
    u32 world_npc_id;
    u32 in_world;
    u32 global_position_x;
    u32 global_position_y;
    u32 in_port;
    u32 on_land;
    u32 in_ocean;
    u32 sailing;
    u32 gold;
    u32 inventory_id;
    u32 player_id;
    u32 general_of_fleet_id;
    u32 stats_id;
    u32 skills[20];
    u32 test_for_pointer[20];
} DATA_CAPTAIN;

u32 storage_captain_used_slots[100];
u32* get_storage_captain_used_slots_ptr()
{ return (u32*)&storage_captain_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_CAPTAIN data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_CAPTAIN; STORAGE_DATA_CAPTAIN storage_captain; u32 find_next_storage_captain_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_captain.used[i] == 0) { storage_captain.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_captain_next_open_slot() { return storage_captain.next_open_slot; } u32 get_storage_captain_total_used_slots() { return storage_captain.count; } void update_storage_captain_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_captain.used[i] == 1) { storage_captain_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_captain_used_slots[usi] = (4294967295U); } ++usi; } storage_captain.count = total; } u32 pull_storage_captain_next_open_slot() { u32 current_count = storage_captain.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "captain" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_captain.next_open_slot; storage_captain.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_captain.data[current_open_slot]; u32 count = (sizeof(*&storage_captain.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_captain.count; storage_captain.data[current_open_slot].id = current_open_slot; find_next_storage_captain_open_slot(); update_storage_captain_used_slots(); return current_open_slot; } u32* get_data_captain_ptr(u32 id) { return (u32*)&storage_captain.data[id]; } DATA_CAPTAIN* get_data_captain(u32 id) { return &storage_captain.data[id]; } DATA_CAPTAIN* pull_data_captain() { u32 new_id = pull_storage_captain_next_open_slot(); return &storage_captain.data[new_id]; } void free_storage_captain_slot(u32 id) { if (storage_captain.used[id] == 1) { storage_captain.used[id] = 0; } update_storage_captain_used_slots(); find_next_storage_captain_open_slot(); }
u32 find_storage_captain_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_captain.used[i] == 1 && storage_captain.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_captain(u32 id, DATA_CAPTAIN* source)
{
    storage_captain.data[id].id = id;
    source->id = id;
    storage_captain.data[id].name_id = source->name_id;
    storage_captain.data[id].npc_id = source->npc_id;
    storage_captain.data[id].world_npc_id = source->world_npc_id;
    storage_captain.data[id].in_world = source->in_world;
    storage_captain.data[id].global_position_x = source->global_position_x;
    storage_captain.data[id].global_position_y = source->global_position_y;
    storage_captain.data[id].in_port = source->in_port;
    storage_captain.data[id].on_land = source->on_land;
    storage_captain.data[id].in_ocean = source->in_ocean;
    storage_captain.data[id].sailing = source->sailing;
    storage_captain.data[id].gold = source->gold;
    storage_captain.data[id].inventory_id = source->inventory_id;
    storage_captain.data[id].player_id = source->player_id;
    storage_captain.data[id].stats_id = source->stats_id;
    storage_captain.data[id].general_of_fleet_id = source->general_of_fleet_id;
    for (u32 i = 0; i < 20; ++i)
    {
        storage_captain.data[id].skills[i] = source->skills[i];
    }
}
u32 add_storage_captain(DATA_CAPTAIN* source, _Bool force_clear) { u32 new_id = pull_storage_captain_next_open_slot(); assign_storage_captain(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }





typedef struct __attribute__((packed))
{
    DATA_CAPTAIN* some_ref;
} SOME_REF;
SOME_REF some_ref;
void do_what_now()
{
    some_ref.some_ref = &storage_captain.data[0];
}
u32* say_what_now()
{
    args[0].i = (sizeof(DATA_CAPTAIN) / sizeof(u32));
    args[1].i = (sizeof(storage_captain.data[0].test_for_pointer) / sizeof(u32));
    args[2].i = (sizeof(storage_captain.data[0].world_npc_id) / sizeof(u32));

    char* test_str =
        "STRUCT_DATA_CAPTAIN->"
        "{\"struct_size\":%d,\"ptr_test\":%d,\"wnpcid\":%d}";
    console_log_format(test_str, args, 3);
    return (u32*)some_ref.some_ref;
}



typedef struct __attribute__((packed))
{

    u32 is_block;
    u32 id;
    u32 name_id;
    u32 width;
    u32 height;
    u32 same_value;
    u32 specific_coordinates_size;
    u32 data[(100 * 100)];
} DATA_LAYER;

u32 storage_layer_used_slots[1000];
u32* get_storage_layer_used_slots_ptr()
{ return (u32*)&storage_layer_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_LAYER data[10]; _Bool used[10]; u32 count; u32 next_open_slot; } STORAGE_DATA_LAYER; STORAGE_DATA_LAYER storage_layer; u32 find_next_storage_layer_open_slot() { for (u32 i = 0; i < 10; ++i) { if (storage_layer.used[i] == 0) { storage_layer.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_layer_next_open_slot() { return storage_layer.next_open_slot; } u32 get_storage_layer_total_used_slots() { return storage_layer.count; } void update_storage_layer_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 10; ++i) { if (storage_layer.used[i] == 1) { storage_layer_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_layer_used_slots[usi] = (4294967295U); } ++usi; } storage_layer.count = total; } u32 pull_storage_layer_next_open_slot() { u32 current_count = storage_layer.count; if (current_count + 1 >= 10) { console_log("[E] No more room left in " "layer" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_layer.next_open_slot; storage_layer.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_layer.data[current_open_slot]; u32 count = (sizeof(*&storage_layer.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_layer.count; storage_layer.data[current_open_slot].id = current_open_slot; find_next_storage_layer_open_slot(); update_storage_layer_used_slots(); return current_open_slot; } u32* get_data_layer_ptr(u32 id) { return (u32*)&storage_layer.data[id]; } DATA_LAYER* get_data_layer(u32 id) { return &storage_layer.data[id]; } DATA_LAYER* pull_data_layer() { u32 new_id = pull_storage_layer_next_open_slot(); return &storage_layer.data[new_id]; } void free_storage_layer_slot(u32 id) { if (storage_layer.used[id] == 1) { storage_layer.used[id] = 0; } update_storage_layer_used_slots(); find_next_storage_layer_open_slot(); }
u32 find_storage_layer_by_name_id(u32 name_id) { for (u32 i = 0; i < 10; ++i) { if ( storage_layer.used[i] == 1 && storage_layer.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void clear_layer(u32 id)
{
    for (u32 i = 0; i < (100 * 100); ++i)
    {
        storage_layer.data[id].data[i] = (4294967295U);
    }
    free_storage_layer_slot(id);
}
void clear_all_layers()
{
    for (u32 l = 0; l < 10; ++l)
    {
        clear_layer(l);
    }
}
void layer_set_value(u32 id, u32 x, u32 y, u32 value)
{
    if (storage_layer.used[id] == 0)
    {
        console_log("[E] Tried to get layer not currently in use");
        return;
    }
    u32 layer_width = storage_layer.data[id].width;
    u32 layer_height = storage_layer.data[id].height;
    if (x > layer_width)
    {
        console_log("[E] Tried to get layer coordinate greater than width");
        return;
    }
    if (y > layer_height)
    {
        console_log("[E] Tried to get layer coordinate greater than height");
        return;
    }
    u32 offset = (y * layer_width) + x;
    storage_layer.data[id].data[offset] = value;
}
u32 layer_get_value(u32 id, u32 x, u32 y)
{
    if (storage_layer.used[id] == 0)
    {
        console_log("[E] Tried to get layer not currently in use");
        return (4294967295U);
    }
    u32 layer_width = storage_layer.data[id].width;
    u32 layer_height = storage_layer.data[id].height;
    if (x > layer_width)
    {
        console_log("[E] Tried to get layer coordinate greater than width");
        return (4294967295U);
    }
    if (y > layer_height)
    {
        console_log("[E] Tried to get layer coordinate greater than height");
        return (4294967295U);
    }
    u32 offset = (y * layer_width) + x;
    return storage_layer.data[id].data[offset];
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 number_held;
    u32 adjusted_price;
    u32 type;
    u32 type_reference;
    u32 inventory_id;
} DATA_INVENTORY_ITEM;

u32 storage_inventory_item_used_slots[1000];
u32* get_storage_inventory_item_used_slots_ptr()
{ return (u32*)&storage_inventory_item_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_INVENTORY_ITEM data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_INVENTORY_ITEM; STORAGE_DATA_INVENTORY_ITEM storage_inventory_item; u32 find_next_storage_inventory_item_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_inventory_item.used[i] == 0) { storage_inventory_item.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_inventory_item_next_open_slot() { return storage_inventory_item.next_open_slot; } u32 get_storage_inventory_item_total_used_slots() { return storage_inventory_item.count; } void update_storage_inventory_item_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_inventory_item.used[i] == 1) { storage_inventory_item_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_inventory_item_used_slots[usi] = (4294967295U); } ++usi; } storage_inventory_item.count = total; } u32 pull_storage_inventory_item_next_open_slot() { u32 current_count = storage_inventory_item.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "inventory_item" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_inventory_item.next_open_slot; storage_inventory_item.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_inventory_item.data[current_open_slot]; u32 count = (sizeof(*&storage_inventory_item.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_inventory_item.count; storage_inventory_item.data[current_open_slot].id = current_open_slot; find_next_storage_inventory_item_open_slot(); update_storage_inventory_item_used_slots(); return current_open_slot; } u32* get_data_inventory_item_ptr(u32 id) { return (u32*)&storage_inventory_item.data[id]; } DATA_INVENTORY_ITEM* get_data_inventory_item(u32 id) { return &storage_inventory_item.data[id]; } DATA_INVENTORY_ITEM* pull_data_inventory_item() { u32 new_id = pull_storage_inventory_item_next_open_slot(); return &storage_inventory_item.data[new_id]; } void free_storage_inventory_item_slot(u32 id) { if (storage_inventory_item.used[id] == 1) { storage_inventory_item.used[id] = 0; } update_storage_inventory_item_used_slots(); find_next_storage_inventory_item_open_slot(); }
u32 find_storage_inventory_item_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_inventory_item.used[i] == 1 && storage_inventory_item.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void clear_inventory_items_by_inventory_id(u32 inventory_id)
{
    for (u32 i = 0; i < 100; ++i)
    {
        if (storage_inventory_item.data[i].inventory_id == inventory_id)
        {
            free_storage_inventory_item_slot(i);
        }
    }
}
u32 inventory_items_by_inventory_id[100];
void get_inventory_items_by_inventory_id(u32 inventory_id)
{
    u32 lookup_i = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        if (storage_inventory_item.data[i].inventory_id == inventory_id)
        {
            inventory_items_by_inventory_id[lookup_i] = storage_inventory_item.data[i].id;
            ++lookup_i;
        }
    }
}
_Bool is_in_inventory(u32 inventory_id, u32 item_id)
{
    get_inventory_items_by_inventory_id(inventory_id);
    for (u32 i = 0; i < 100; ++i)
    {
        if (inventory_items_by_inventory_id[i] == (4294967295U)) { continue; }
        if (inventory_items_by_inventory_id[i] == item_id)
        {
            return 1;
        }
    }
    return 0;
}

typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 total_items;
    u32 inventory_items[100];
} DATA_INVENTORY;

u32 storage_inventory_used_slots[1000];
u32* get_storage_inventory_used_slots_ptr()
{ return (u32*)&storage_inventory_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_INVENTORY data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_INVENTORY; STORAGE_DATA_INVENTORY storage_inventory; u32 find_next_storage_inventory_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_inventory.used[i] == 0) { storage_inventory.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_inventory_next_open_slot() { return storage_inventory.next_open_slot; } u32 get_storage_inventory_total_used_slots() { return storage_inventory.count; } void update_storage_inventory_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_inventory.used[i] == 1) { storage_inventory_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_inventory_used_slots[usi] = (4294967295U); } ++usi; } storage_inventory.count = total; } u32 pull_storage_inventory_next_open_slot() { u32 current_count = storage_inventory.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "inventory" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_inventory.next_open_slot; storage_inventory.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_inventory.data[current_open_slot]; u32 count = (sizeof(*&storage_inventory.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_inventory.count; storage_inventory.data[current_open_slot].id = current_open_slot; find_next_storage_inventory_open_slot(); update_storage_inventory_used_slots(); return current_open_slot; } u32* get_data_inventory_ptr(u32 id) { return (u32*)&storage_inventory.data[id]; } DATA_INVENTORY* get_data_inventory(u32 id) { return &storage_inventory.data[id]; } DATA_INVENTORY* pull_data_inventory() { u32 new_id = pull_storage_inventory_next_open_slot(); return &storage_inventory.data[new_id]; } void free_storage_inventory_slot(u32 id) { if (storage_inventory.used[id] == 1) { storage_inventory.used[id] = 0; } update_storage_inventory_used_slots(); find_next_storage_inventory_open_slot(); }
u32 find_storage_inventory_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_inventory.used[i] == 1 && storage_inventory.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void update_inventory_items(u32 inventory_id)
{
    u32 total_items = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        if (
            storage_inventory_item.used[i] == 1
            &&
            storage_inventory_item.data[i].inventory_id == inventory_id
        )
        {
            storage_inventory.data[inventory_id].inventory_items[total_items] = storage_inventory_item.data[i].id;
            ++total_items;
        }
        else
        {
            storage_inventory.data[inventory_id].inventory_items[i] = (4294967295U);
        }
    }
    storage_inventory.data[inventory_id].total_items = total_items;
}
void add_item_to_inventory(u32 item_id, u32 inventory_id)
{
    storage_inventory_item.data[item_id].inventory_id = inventory_id;
    update_inventory_items(inventory_id);
}
void assign_storage_inventory(u32 id, DATA_INVENTORY* source)
{
    storage_inventory.data[id].id = id;
    source->id = id;
    storage_inventory.data[id].name_id = source->name_id;
    storage_inventory.data[id].total_items = source->total_items;
    for (u32 i = 0; i < 100; ++i)
    {
        storage_inventory.data[id].inventory_items[i] = source->inventory_items[i];
    }
}
u32 add_storage_inventory(DATA_INVENTORY* source, _Bool force_clear) { u32 new_id = pull_storage_inventory_next_open_slot(); assign_storage_inventory(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 global_location_x;
    u32 global_location_y;
    u32 overall_investment_level;
    u32 market_investment_level;
    u32 shipyard_investment_level;
    u32 base_trade_tax;
} DATA_PORT;

u32 storage_port_used_slots[100];
u32* get_storage_port_used_slots_ptr()
{ return (u32*)&storage_port_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_PORT data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_PORT; STORAGE_DATA_PORT storage_port; u32 find_next_storage_port_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_port.used[i] == 0) { storage_port.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_port_next_open_slot() { return storage_port.next_open_slot; } u32 get_storage_port_total_used_slots() { return storage_port.count; } void update_storage_port_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_port.used[i] == 1) { storage_port_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_port_used_slots[usi] = (4294967295U); } ++usi; } storage_port.count = total; } u32 pull_storage_port_next_open_slot() { u32 current_count = storage_port.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "port" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_port.next_open_slot; storage_port.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_port.data[current_open_slot]; u32 count = (sizeof(*&storage_port.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_port.count; storage_port.data[current_open_slot].id = current_open_slot; find_next_storage_port_open_slot(); update_storage_port_used_slots(); return current_open_slot; } u32* get_data_port_ptr(u32 id) { return (u32*)&storage_port.data[id]; } DATA_PORT* get_data_port(u32 id) { return &storage_port.data[id]; } DATA_PORT* pull_data_port() { u32 new_id = pull_storage_port_next_open_slot(); return &storage_port.data[new_id]; } void free_storage_port_slot(u32 id) { if (storage_port.used[id] == 1) { storage_port.used[id] = 0; } update_storage_port_used_slots(); find_next_storage_port_open_slot(); }
u32 find_storage_port_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_port.used[i] == 1 && storage_port.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;


    u32 ships_prefab[10];
    u32 buying_prefab_ship_id;

    u32 new_ship;
    u32 to_invest;
    u32 remodel_ship_id;
    u32 remodel_space_price;
    u32 remodel_material_price;
    u32 remodel_cannon_price;
    u32 remodel_figurehead_price;
} DATA_SCENE_SHIPYARD;
DATA_SCENE_SHIPYARD Scene_Shipyard;
u32* get_data_scene_shipyard_ptr()
{ return (u32*)&Scene_Shipyard; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 flag_initialized;
    u32 previous_game_mode;
    u32 error_code;
    u32 dialog_id;
    u32 purchase_food;
    u32 purchase_water;
    u32 purchase_cannonballs;
    u32 price_food;
    u32 price_water;
    u32 price_cannonballs;
    u32 purchase_for_ship_id;
} DATA_SCENE_DOCKYARD;
DATA_SCENE_DOCKYARD Scene_Dockyard;
u32* get_data_scene_dockyard_ptr()
{ return (u32*)&Scene_Dockyard; }
void clear_scene_dockyard()
{
    Scene_Dockyard.purchase_food = 0;
    Scene_Dockyard.purchase_water = 0;
    Scene_Dockyard.purchase_cannonballs = 0;
    Scene_Dockyard.price_food = 0;
    Scene_Dockyard.price_water = 0;
    Scene_Dockyard.price_cannonballs = 0;
    Scene_Dockyard.purchase_for_ship_id = (4294967295U);
}



typedef struct __attribute__((packed))
{
    u32 capacity;
    u32 tacking;
    u32 power;
    u32 speed;
    u32 durability;
    u32 material_id;
    u32 cargo_space;
    u32 cannon_space;
    u32 crew_space;
    u32 cannon_type_id;
    u32 figurehead_id;
    u32 space_price;
    u32 material_price;
    u32 cannon_price;
    u32 figurehead_price;
    u32 total_price;
} DATA_REMODEL_SHIP;
DATA_REMODEL_SHIP Remodel_Ship;
u32* get_data_remodel_ship_ptr()
{ return (u32*)&Remodel_Ship; }
void clear_remodel_ship()
{
    Remodel_Ship.material_id = (4294967295U);
    Remodel_Ship.cargo_space = (4294967295U);
    Remodel_Ship.cannon_space = (4294967295U);
    Remodel_Ship.crew_space = (4294967295U);
    Remodel_Ship.cannon_type_id = (4294967295U);
    Remodel_Ship.figurehead_id = (4294967295U);
    Remodel_Ship.space_price = 0;
    Remodel_Ship.material_price = 0;
    Remodel_Ship.cannon_price = 0;
    Remodel_Ship.figurehead_price = 0;
    Remodel_Ship.total_price = (4294967295U);
}
void calculate_remodel_ship()
{
    Remodel_Ship.total_price = 0;
    Remodel_Ship.total_price += Remodel_Ship.space_price;
    Remodel_Ship.total_price += Remodel_Ship.material_price;
    Remodel_Ship.total_price += Remodel_Ship.cannon_price;
    Remodel_Ship.total_price += Remodel_Ship.figurehead_price;
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 type_id;
    u32 material_id;
    u32 cargo;
    u32 cannons;
    u32 crew;
    u32 cannon_type_id;
    u32 figurehead_id;
} DATA_NEW_SHIP;

u32 storage_new_ship_used_slots[100];

u32* get_storage_new_ship_used_slots_ptr()
{ return (u32*)&storage_new_ship_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_NEW_SHIP data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_NEW_SHIP; STORAGE_DATA_NEW_SHIP storage_new_ship; u32 find_next_storage_new_ship_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_new_ship.used[i] == 0) { storage_new_ship.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_new_ship_next_open_slot() { return storage_new_ship.next_open_slot; } u32 get_storage_new_ship_total_used_slots() { return storage_new_ship.count; } void update_storage_new_ship_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_new_ship.used[i] == 1) { storage_new_ship_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_new_ship_used_slots[usi] = (4294967295U); } ++usi; } storage_new_ship.count = total; } u32 pull_storage_new_ship_next_open_slot() { u32 current_count = storage_new_ship.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "new_ship" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_new_ship.next_open_slot; storage_new_ship.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_new_ship.data[current_open_slot]; u32 count = (sizeof(*&storage_new_ship.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_new_ship.count; storage_new_ship.data[current_open_slot].id = current_open_slot; find_next_storage_new_ship_open_slot(); update_storage_new_ship_used_slots(); return current_open_slot; } u32* get_data_new_ship_ptr(u32 id) { return (u32*)&storage_new_ship.data[id]; } DATA_NEW_SHIP* get_data_new_ship(u32 id) { return &storage_new_ship.data[id]; } DATA_NEW_SHIP* pull_data_new_ship() { u32 new_id = pull_storage_new_ship_next_open_slot(); return &storage_new_ship.data[new_id]; } void free_storage_new_ship_slot(u32 id) { if (storage_new_ship.used[id] == 1) { storage_new_ship.used[id] = 0; } update_storage_new_ship_used_slots(); find_next_storage_new_ship_open_slot(); }
u32 find_storage_new_ship_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_new_ship.used[i] == 1 && storage_new_ship.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 battle_level;
    u32 navigation_level;
    u32 leadership;
    u32 seamanship;
    u32 knowledge;
    u32 intuition;
    u32 courage;
    u32 swordsmanship;
    u32 charm;
    u32 luck;
} DATA_STATS;

u32 storage_stats_used_slots[100];
u32* get_storage_stats_used_slots_ptr()
{ return (u32*)&storage_stats_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_STATS data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_STATS; STORAGE_DATA_STATS storage_stats; u32 find_next_storage_stats_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_stats.used[i] == 0) { storage_stats.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_stats_next_open_slot() { return storage_stats.next_open_slot; } u32 get_storage_stats_total_used_slots() { return storage_stats.count; } void update_storage_stats_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_stats.used[i] == 1) { storage_stats_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_stats_used_slots[usi] = (4294967295U); } ++usi; } storage_stats.count = total; } u32 pull_storage_stats_next_open_slot() { u32 current_count = storage_stats.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "stats" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_stats.next_open_slot; storage_stats.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_stats.data[current_open_slot]; u32 count = (sizeof(*&storage_stats.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_stats.count; storage_stats.data[current_open_slot].id = current_open_slot; find_next_storage_stats_open_slot(); update_storage_stats_used_slots(); return current_open_slot; } u32* get_data_stats_ptr(u32 id) { return (u32*)&storage_stats.data[id]; } DATA_STATS* get_data_stats(u32 id) { return &storage_stats.data[id]; } DATA_STATS* pull_data_stats() { u32 new_id = pull_storage_stats_next_open_slot(); return &storage_stats.data[new_id]; } void free_storage_stats_slot(u32 id) { if (storage_stats.used[id] == 1) { storage_stats.used[id] = 0; } update_storage_stats_used_slots(); find_next_storage_stats_open_slot(); }
u32 find_storage_stats_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_stats.used[i] == 1 && storage_stats.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_stats(u32 id, DATA_STATS* source)
{
    storage_stats.data[id].id = id;
    source->id = id;
    storage_stats.data[id].name_id = source->name_id;
    storage_stats.data[id].battle_level = source->battle_level;
    storage_stats.data[id].navigation_level = source->navigation_level;
    storage_stats.data[id].leadership = source->leadership;
    storage_stats.data[id].seamanship = source->seamanship;
    storage_stats.data[id].knowledge = source->knowledge;
    storage_stats.data[id].intuition = source->intuition;
    storage_stats.data[id].courage = source->courage;
    storage_stats.data[id].swordsmanship = source->swordsmanship;
    storage_stats.data[id].charm = source->charm;
    storage_stats.data[id].luck = source->luck;
}
u32 add_storage_stats(DATA_STATS* source, _Bool force_clear) { u32 new_id = pull_storage_stats_next_open_slot(); assign_storage_stats(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
void default_stats(DATA_STATS* source)
{
    source->battle_level = 0;
    source->navigation_level = 0;
    source->leadership = 0;
    source->seamanship = 0;
    source->knowledge = 0;
    source->intuition = 0;
    source->courage = 0;
    source->swordsmanship = 0;
    source->charm = 0;
    source->luck = 0;
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 stats_requirements_id;
} DATA_SKILL;

u32 storage_skill_used_slots[100];
u32* get_storage_skill_used_slots_ptr()
{ return (u32*)&storage_skill_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_SKILL data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_SKILL; STORAGE_DATA_SKILL storage_skill; u32 find_next_storage_skill_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_skill.used[i] == 0) { storage_skill.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_skill_next_open_slot() { return storage_skill.next_open_slot; } u32 get_storage_skill_total_used_slots() { return storage_skill.count; } void update_storage_skill_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_skill.used[i] == 1) { storage_skill_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_skill_used_slots[usi] = (4294967295U); } ++usi; } storage_skill.count = total; } u32 pull_storage_skill_next_open_slot() { u32 current_count = storage_skill.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "skill" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_skill.next_open_slot; storage_skill.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_skill.data[current_open_slot]; u32 count = (sizeof(*&storage_skill.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_skill.count; storage_skill.data[current_open_slot].id = current_open_slot; find_next_storage_skill_open_slot(); update_storage_skill_used_slots(); return current_open_slot; } u32* get_data_skill_ptr(u32 id) { return (u32*)&storage_skill.data[id]; } DATA_SKILL* get_data_skill(u32 id) { return &storage_skill.data[id]; } DATA_SKILL* pull_data_skill() { u32 new_id = pull_storage_skill_next_open_slot(); return &storage_skill.data[new_id]; } void free_storage_skill_slot(u32 id) { if (storage_skill.used[id] == 1) { storage_skill.used[id] = 0; } update_storage_skill_used_slots(); find_next_storage_skill_open_slot(); }
u32 find_storage_skill_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_skill.used[i] == 1 && storage_skill.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_skill(u32 id, DATA_SKILL* source)
{
    storage_skill.data[id].id = id;
    source->id = id;
    storage_skill.data[id].stats_requirements_id = source->stats_requirements_id;
}
u32 add_storage_skill(DATA_SKILL* source, _Bool force_clear) { u32 new_id = pull_storage_skill_next_open_slot(); assign_storage_skill(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 is_interactable;
    u32 is_solid;
    u32 interaction_on_step_over;
    u32 interaction_scene;
    u32 position_x;
    u32 position_y;
} DATA_ENTITY;

u32 storage_entity_used_slots[100];
u32* get_storage_entity_used_slots_ptr()
{ return (u32*)&storage_entity_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_ENTITY data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_ENTITY; STORAGE_DATA_ENTITY storage_entity; u32 find_next_storage_entity_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_entity.used[i] == 0) { storage_entity.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_entity_next_open_slot() { return storage_entity.next_open_slot; } u32 get_storage_entity_total_used_slots() { return storage_entity.count; } void update_storage_entity_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_entity.used[i] == 1) { storage_entity_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_entity_used_slots[usi] = (4294967295U); } ++usi; } storage_entity.count = total; } u32 pull_storage_entity_next_open_slot() { u32 current_count = storage_entity.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "entity" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_entity.next_open_slot; storage_entity.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_entity.data[current_open_slot]; u32 count = (sizeof(*&storage_entity.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_entity.count; storage_entity.data[current_open_slot].id = current_open_slot; find_next_storage_entity_open_slot(); update_storage_entity_used_slots(); return current_open_slot; } u32* get_data_entity_ptr(u32 id) { return (u32*)&storage_entity.data[id]; } DATA_ENTITY* get_data_entity(u32 id) { return &storage_entity.data[id]; } DATA_ENTITY* pull_data_entity() { u32 new_id = pull_storage_entity_next_open_slot(); return &storage_entity.data[new_id]; } void free_storage_entity_slot(u32 id) { if (storage_entity.used[id] == 1) { storage_entity.used[id] = 0; } update_storage_entity_used_slots(); find_next_storage_entity_open_slot(); }
u32 find_storage_entity_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_entity.used[i] == 1 && storage_entity.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_entity(u32 id, DATA_ENTITY* source)
{
    storage_entity.data[id].id = id;
    storage_entity.data[id].name_id = source->name_id;
    storage_entity.data[id].is_interactable = source->is_interactable;
    storage_entity.data[id].is_solid = source->is_solid;
    storage_entity.data[id].interaction_on_step_over = source->interaction_on_step_over;
    storage_entity.data[id].interaction_scene = source->interaction_scene;
    storage_entity.data[id].position_x = source->position_x;
    storage_entity.data[id].position_y = source->position_y;
}
u32 add_storage_entity(DATA_ENTITY* source, _Bool force_clear) { u32 new_id = pull_storage_entity_next_open_slot(); assign_storage_entity(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
void clear_all_entities()
{
    for (u32 i = 0; i < 100; ++i)
    {
        free_storage_entity_slot(i);
    }
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 total_ships;
    u32 total_captains;
    u32 first_mate_id;
    u32 accountant_id;
    u32 navigator_id;
    u32 general_id;
    u32 captain_ids[100];
    u32 ship_ids[100];
} DATA_FLEET;

u32 storage_fleet_used_slots[100];
u32* get_storage_fleet_used_slots_ptr()
{ return (u32*)&storage_fleet_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_FLEET data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_FLEET; STORAGE_DATA_FLEET storage_fleet; u32 find_next_storage_fleet_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_fleet.used[i] == 0) { storage_fleet.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_fleet_next_open_slot() { return storage_fleet.next_open_slot; } u32 get_storage_fleet_total_used_slots() { return storage_fleet.count; } void update_storage_fleet_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_fleet.used[i] == 1) { storage_fleet_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_fleet_used_slots[usi] = (4294967295U); } ++usi; } storage_fleet.count = total; } u32 pull_storage_fleet_next_open_slot() { u32 current_count = storage_fleet.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "fleet" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_fleet.next_open_slot; storage_fleet.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_fleet.data[current_open_slot]; u32 count = (sizeof(*&storage_fleet.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_fleet.count; storage_fleet.data[current_open_slot].id = current_open_slot; find_next_storage_fleet_open_slot(); update_storage_fleet_used_slots(); return current_open_slot; } u32* get_data_fleet_ptr(u32 id) { return (u32*)&storage_fleet.data[id]; } DATA_FLEET* get_data_fleet(u32 id) { return &storage_fleet.data[id]; } DATA_FLEET* pull_data_fleet() { u32 new_id = pull_storage_fleet_next_open_slot(); return &storage_fleet.data[new_id]; } void free_storage_fleet_slot(u32 id) { if (storage_fleet.used[id] == 1) { storage_fleet.used[id] = 0; } update_storage_fleet_used_slots(); find_next_storage_fleet_open_slot(); }
u32 find_storage_fleet_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_fleet.used[i] == 1 && storage_fleet.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_fleet(u32 id, DATA_FLEET* source)
{
    storage_fleet.data[id].id = id;
    storage_fleet.data[id].name_id = source->name_id;
    storage_fleet.data[id].total_ships = source->total_ships;
    storage_fleet.data[id].total_captains = source->total_captains;
    storage_fleet.data[id].first_mate_id = source->first_mate_id;
    storage_fleet.data[id].accountant_id = source->accountant_id;
    storage_fleet.data[id].navigator_id = source->navigator_id;
    storage_fleet.data[id].general_id = source->general_id;
    for (u32 i = 0; i < 100; ++i)
    {
        storage_fleet.data[id].ship_ids[i] = source->ship_ids[i];
    }
    for (u32 i = 0; i < 100; ++i)
    {
        storage_fleet.data[id].captain_ids[i] = source->captain_ids[i];
    }
}
u32 add_storage_fleet(DATA_FLEET* source, _Bool force_clear) { u32 new_id = pull_storage_fleet_next_open_slot(); assign_storage_fleet(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 ship_id;
    u32 fleet_id;
    u32 captain_id;
    u32 is_flagship;
} DATA_FLEET_SHIP;

u32 storage_fleet_ship_used_slots[100];
u32* get_storage_fleet_ship_used_slots_ptr()
{ return (u32*)&storage_fleet_ship_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_FLEET_SHIP data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_FLEET_SHIP; STORAGE_DATA_FLEET_SHIP storage_fleet_ship; u32 find_next_storage_fleet_ship_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_fleet_ship.used[i] == 0) { storage_fleet_ship.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_fleet_ship_next_open_slot() { return storage_fleet_ship.next_open_slot; } u32 get_storage_fleet_ship_total_used_slots() { return storage_fleet_ship.count; } void update_storage_fleet_ship_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_fleet_ship.used[i] == 1) { storage_fleet_ship_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_fleet_ship_used_slots[usi] = (4294967295U); } ++usi; } storage_fleet_ship.count = total; } u32 pull_storage_fleet_ship_next_open_slot() { u32 current_count = storage_fleet_ship.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "fleet_ship" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_fleet_ship.next_open_slot; storage_fleet_ship.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_fleet_ship.data[current_open_slot]; u32 count = (sizeof(*&storage_fleet_ship.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_fleet_ship.count; storage_fleet_ship.data[current_open_slot].id = current_open_slot; find_next_storage_fleet_ship_open_slot(); update_storage_fleet_ship_used_slots(); return current_open_slot; } u32* get_data_fleet_ship_ptr(u32 id) { return (u32*)&storage_fleet_ship.data[id]; } DATA_FLEET_SHIP* get_data_fleet_ship(u32 id) { return &storage_fleet_ship.data[id]; } DATA_FLEET_SHIP* pull_data_fleet_ship() { u32 new_id = pull_storage_fleet_ship_next_open_slot(); return &storage_fleet_ship.data[new_id]; } void free_storage_fleet_ship_slot(u32 id) { if (storage_fleet_ship.used[id] == 1) { storage_fleet_ship.used[id] = 0; } update_storage_fleet_ship_used_slots(); find_next_storage_fleet_ship_open_slot(); }
u32 find_storage_fleet_ship_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_fleet_ship.used[i] == 1 && storage_fleet_ship.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_fleet_ship(u32 id, DATA_FLEET_SHIP* source)
{
    storage_fleet_ship.data[id].id = id;
    storage_fleet_ship.data[id].name_id = source->name_id;
    storage_fleet_ship.data[id].ship_id = source->ship_id;
    storage_fleet_ship.data[id].fleet_id = source->fleet_id;
    storage_fleet_ship.data[id].captain_id = source->captain_id;
    storage_fleet_ship.data[id].is_flagship = source->is_flagship;
}
u32 add_storage_fleet_ship(DATA_FLEET_SHIP* source, _Bool force_clear) { u32 new_id = pull_storage_fleet_ship_next_open_slot(); assign_storage_fleet_ship(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
_Bool add_fleet_ship_to_fleet(u32 fleet_ship_id, u32 fleet_id)
{
    _Bool added = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        if (storage_fleet.data[fleet_id].ship_ids[i] != (4294967295U))
        {
            continue;
        }
        added = 1;
        storage_fleet.data[fleet_id].ship_ids[i] = fleet_ship_id;

        storage_fleet_ship.data[fleet_ship_id].fleet_id = fleet_id;
        break;
    }
    return added;
}
DATA_SHIP* get_ship_from_fleet_ship(u32 fleet_ship_id)
{
    u32 ship_id = storage_fleet_ship.data[fleet_ship_id].ship_id;
    return get_data_ship(ship_id);
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 captain_id;
    u32 fleet_id;
} DATA_FLEET_CAPTAIN;

u32 storage_fleet_captain_used_slots[100];
u32* get_storage_fleet_captain_used_slots_ptr()
{ return (u32*)&storage_fleet_captain_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_FLEET_CAPTAIN data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_FLEET_CAPTAIN; STORAGE_DATA_FLEET_CAPTAIN storage_fleet_captain; u32 find_next_storage_fleet_captain_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_fleet_captain.used[i] == 0) { storage_fleet_captain.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_fleet_captain_next_open_slot() { return storage_fleet_captain.next_open_slot; } u32 get_storage_fleet_captain_total_used_slots() { return storage_fleet_captain.count; } void update_storage_fleet_captain_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_fleet_captain.used[i] == 1) { storage_fleet_captain_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_fleet_captain_used_slots[usi] = (4294967295U); } ++usi; } storage_fleet_captain.count = total; } u32 pull_storage_fleet_captain_next_open_slot() { u32 current_count = storage_fleet_captain.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "fleet_captain" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_fleet_captain.next_open_slot; storage_fleet_captain.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_fleet_captain.data[current_open_slot]; u32 count = (sizeof(*&storage_fleet_captain.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_fleet_captain.count; storage_fleet_captain.data[current_open_slot].id = current_open_slot; find_next_storage_fleet_captain_open_slot(); update_storage_fleet_captain_used_slots(); return current_open_slot; } u32* get_data_fleet_captain_ptr(u32 id) { return (u32*)&storage_fleet_captain.data[id]; } DATA_FLEET_CAPTAIN* get_data_fleet_captain(u32 id) { return &storage_fleet_captain.data[id]; } DATA_FLEET_CAPTAIN* pull_data_fleet_captain() { u32 new_id = pull_storage_fleet_captain_next_open_slot(); return &storage_fleet_captain.data[new_id]; } void free_storage_fleet_captain_slot(u32 id) { if (storage_fleet_captain.used[id] == 1) { storage_fleet_captain.used[id] = 0; } update_storage_fleet_captain_used_slots(); find_next_storage_fleet_captain_open_slot(); }
u32 find_storage_fleet_captain_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_fleet_captain.used[i] == 1 && storage_fleet_captain.data[i].name_id == name_id ) { return i; } } return (4294967295U); }


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 range;
    u32 power;
    u32 base_price;
} DATA_CANNON;

u32 storage_cannon_used_slots[100];
u32* get_storage_cannon_used_slots_ptr()
{ return (u32*)&storage_cannon_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_CANNON data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_CANNON; STORAGE_DATA_CANNON storage_cannon; u32 find_next_storage_cannon_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_cannon.used[i] == 0) { storage_cannon.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_cannon_next_open_slot() { return storage_cannon.next_open_slot; } u32 get_storage_cannon_total_used_slots() { return storage_cannon.count; } void update_storage_cannon_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_cannon.used[i] == 1) { storage_cannon_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_cannon_used_slots[usi] = (4294967295U); } ++usi; } storage_cannon.count = total; } u32 pull_storage_cannon_next_open_slot() { u32 current_count = storage_cannon.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "cannon" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_cannon.next_open_slot; storage_cannon.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_cannon.data[current_open_slot]; u32 count = (sizeof(*&storage_cannon.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_cannon.count; storage_cannon.data[current_open_slot].id = current_open_slot; find_next_storage_cannon_open_slot(); update_storage_cannon_used_slots(); return current_open_slot; } u32* get_data_cannon_ptr(u32 id) { return (u32*)&storage_cannon.data[id]; } DATA_CANNON* get_data_cannon(u32 id) { return &storage_cannon.data[id]; } DATA_CANNON* pull_data_cannon() { u32 new_id = pull_storage_cannon_next_open_slot(); return &storage_cannon.data[new_id]; } void free_storage_cannon_slot(u32 id) { if (storage_cannon.used[id] == 1) { storage_cannon.used[id] = 0; } update_storage_cannon_used_slots(); find_next_storage_cannon_open_slot(); }
u32 find_storage_cannon_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_cannon.used[i] == 1 && storage_cannon.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_cannon(u32 id, DATA_CANNON* source)
{
    storage_cannon.data[id].id = id;
    storage_cannon.data[id].name_id = source->name_id;
    storage_cannon.data[id].range = source->range;
    storage_cannon.data[id].power = source->power;
    storage_cannon.data[id].base_price = source->base_price;
}
u32 add_storage_cannon(DATA_CANNON* source, _Bool force_clear) { u32 new_id = pull_storage_cannon_next_open_slot(); assign_storage_cannon(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
void clear_cannon(u32 id)
{
    storage_cannon.data[id].name_id = (4294967295U);
    storage_cannon.data[id].range = (4294967295U);
    storage_cannon.data[id].power = (4294967295U);
    storage_cannon.data[id].base_price = (4294967295U);
    free_storage_cannon_slot(id);
}
void clear_all_cannons()
{
    for (u32 i = 0; i < 100; ++i)
    {
        clear_cannon(i);
    }
}


typedef struct __attribute__((packed))
{
    u32 id;
    u32 name_id;
    u32 base_price;
} DATA_FIGUREHEAD;

u32 storage_figurehead_used_slots[100];
u32* get_storage_figurehead_used_slots_ptr()
{ return (u32*)&storage_figurehead_used_slots[0]; }
typedef struct __attribute__((packed)) { DATA_FIGUREHEAD data[100]; _Bool used[100]; u32 count; u32 next_open_slot; } STORAGE_DATA_FIGUREHEAD; STORAGE_DATA_FIGUREHEAD storage_figurehead; u32 find_next_storage_figurehead_open_slot() { for (u32 i = 0; i < 100; ++i) { if (storage_figurehead.used[i] == 0) { storage_figurehead.next_open_slot = i; return i; } } return (4294967295U); } u32 get_storage_figurehead_next_open_slot() { return storage_figurehead.next_open_slot; } u32 get_storage_figurehead_total_used_slots() { return storage_figurehead.count; } void update_storage_figurehead_used_slots() { u32 usi = 0; u32 total = 0; u32 open_slot = (4294967295U); for (u32 i = 0; i < 100; ++i) { if (storage_figurehead.used[i] == 1) { storage_figurehead_used_slots[usi] = i; ++total; } else { if (open_slot == (4294967295U)) { open_slot = i; } storage_figurehead_used_slots[usi] = (4294967295U); } ++usi; } storage_figurehead.count = total; } u32 pull_storage_figurehead_next_open_slot() { u32 current_count = storage_figurehead.count; if (current_count + 1 >= 100) { console_log("[E] No more room left in " "figurehead" " to add a new entry"); return (4294967295U); } u32 current_open_slot = storage_figurehead.next_open_slot; storage_figurehead.used[current_open_slot] = 1; do { u32 *ptr = (u32 *)&storage_figurehead.data[current_open_slot]; u32 count = (sizeof(*&storage_figurehead.data[current_open_slot]) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); ++storage_figurehead.count; storage_figurehead.data[current_open_slot].id = current_open_slot; find_next_storage_figurehead_open_slot(); update_storage_figurehead_used_slots(); return current_open_slot; } u32* get_data_figurehead_ptr(u32 id) { return (u32*)&storage_figurehead.data[id]; } DATA_FIGUREHEAD* get_data_figurehead(u32 id) { return &storage_figurehead.data[id]; } DATA_FIGUREHEAD* pull_data_figurehead() { u32 new_id = pull_storage_figurehead_next_open_slot(); return &storage_figurehead.data[new_id]; } void free_storage_figurehead_slot(u32 id) { if (storage_figurehead.used[id] == 1) { storage_figurehead.used[id] = 0; } update_storage_figurehead_used_slots(); find_next_storage_figurehead_open_slot(); }
u32 find_storage_figurehead_by_name_id(u32 name_id) { for (u32 i = 0; i < 100; ++i) { if ( storage_figurehead.used[i] == 1 && storage_figurehead.data[i].name_id == name_id ) { return i; } } return (4294967295U); }
void assign_storage_figurehead(u32 id, DATA_FIGUREHEAD* source)
{
    storage_figurehead.data[id].id = id;
    storage_figurehead.data[id].name_id = source->name_id;
    storage_figurehead.data[id].base_price = source->base_price;
}
u32 add_storage_figurehead(DATA_FIGUREHEAD* source, _Bool force_clear) { u32 new_id = pull_storage_figurehead_next_open_slot(); assign_storage_figurehead(new_id, source); source->id = new_id; if (force_clear) { do { u32 *ptr = (u32 *)source; u32 count = (sizeof(*source) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0); } return new_id; }
void clear_figurehead(u32 id)
{
    storage_figurehead.data[id].name_id = (4294967295U);
    storage_figurehead.data[id].base_price = (4294967295U);
    free_storage_figurehead_slot(id);
}
void clear_all_figureheads()
{
    for (u32 i = 0; i < 100; ++i)
    {
        clear_figurehead(i);
    }
}





typedef struct __attribute__((packed))
{

    u32 minute;

    u32 hour;

    u32 day;

    u32 month;

    u32 year;

    u32 total_days;

    u32 is_night;

    u32 ticks_counter;
} DATA_GAME_TIME;
DATA_GAME_TIME Game_Time;
u32* get_data_game_time_ptr()
{ return (u32*)&Game_Time; }
# 1635 "wasm_game.h"
const u32 DAYS_PER_MONTH[12] = {
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
};
void initialize_game_time()
{
    Game_Time.minute = 0;
    Game_Time.hour = 8;
    Game_Time.day = 1;
    Game_Time.month = 1;
    Game_Time.year = 1500;
    Game_Time.total_days = 0;
    Game_Time.is_night = 0;
    Game_Time.ticks_counter = 0;
}
_Bool is_leap_year(u32 year)
{

    return year % 4 == 0;
}
void update_game_time()
{
    Game_Time.ticks_counter++;

    if (Game_Time.ticks_counter >= 60)
    {
        Game_Time.ticks_counter = 0;
        Game_Time.minute++;

        if (Game_Time.minute >= 60)
        {
            Game_Time.minute = 0;
            Game_Time.hour++;


            if (Game_Time.hour == 6)
                Game_Time.is_night = 0;
            else if (Game_Time.hour == 18)
                Game_Time.is_night = 1;

            if (Game_Time.hour >= 24)
            {
                Game_Time.hour = 0;
                Game_Time.day++;
                Game_Time.total_days++;

                u32 max_days = DAYS_PER_MONTH[Game_Time.month - 1];
                if (Game_Time.month == 2 && is_leap_year(Game_Time.year))
                    max_days++;

                if (Game_Time.day > max_days)
                {
                    Game_Time.day = 1;
                    Game_Time.month++;

                    if (Game_Time.month > 12)
                    {
                        Game_Time.month = 1;
                        Game_Time.year++;
                    }
                }
            }
        }
    }
}

_Bool is_currently_night()
{
    return Game_Time.is_night == 1;
}

u32 get_current_season()
{
    return ((Game_Time.month - 1) / 3) + 1;
}

u32 get_days_elapsed()
{
    return Game_Time.total_days;
}




enum GameStrings
{
    EMPTY,


    ACTION, ACTION_CONFIRM, ACTION_BUY, ACTION_SELL, ACTION_EXIT, ACTION_SETUP,
    ACTION_NEXT,


    ACTION_DEALER_TURN, ACTION_PLAYER_HIT, ACTION_PLAYER_STAND, ACTION_PLACE_BET,


    ACTION_BANK_DEPOSIT, ACTION_BANK_WITHDRAW, ACTION_BANK_PAY_LOAN,
    ACTION_BANK_TAKE_LOAN, ACTION_BANK_DEPOSIT_SUCCESS,
    ACTION_BANK_WITHDRAW_SUCCESS, ACTION_BANK_TAKE_LOAN_SUCCESS,
    ACTION_BANK_PAY_LOAN_SUCCESS,


    ACTION_SHIPYARD_BUY_USED,
    ACTION_SHIPYARD_REMODEL_SHIP,
    ACTION_SHIPYARD_REMODEL_SHIP_MATERIAL,
    ACTION_SHIPYARD_REMODEL_SHIP_FIGUREHEAD,
    ACTION_SHIPYARD_REMODEL_SHIP_CANNON_TYPE,
    ACTION_SHIPYARD_REMODEL_SHIP_SPACE,


    ACTION_DOCKYARD_PURCHASE,
    ACTION_DOCKYARD_SET_SAIL,


    ACTION_GOODS_SHOP_BUY, ACTION_GOODS_SHOP_SELL,


    DIALOG_NPC_RVICE, DIALOG_NPC_LAFOLIE, DIALOG_NPC_NAKOR,
    DIALOG_NPC_TRAVIS, DIALOG_NPC_LOLLER,

    DIALOG_BLACKJACK_WELCOME,

    DIALOG_BANK_WELCOME,

    DIALOG_SHIPYARD_WELCOME,
    DIALOG_SHIPYARD_PREFAB_PURCHASE_SUCCESS,
    DIALOG_SHIPYARD_REMODEL_SUCCESS,

    DIALOG_DOCKYARD_WELCOME,
    DIALOG_DOCKYARD_SUPPLIES_LOADED,

    DIALOG_GOODS_SHOP_WELCOME,
    DIALOG_GOODS_SHOP_PURCHASED_GOODS,

    DIALOG_TEST_ONE, DIALOG_TEST_TWO, DIALOG_TEST_THREE,


    SCENE_BLACKJACK, SCENE_GENERAL_SHOP, SCENE_DOCKYARD, SCENE_OCEAN_BATTLE,
    SCENE_OCEAN_FAKE_BATTLE, SCENE_SHIPYARD,
    SCENE_BANK, SCENE_NPC_RVICE, SCENE_NPC_LAFOLIE, SCENE_NPC_NAKOR,
    SCENE_NPC_TRAVIS, SCENE_NPC_LOLLER, SCENE_GOODS_SHOP,
    SCENE_TEST,


    INVENTORY_ATHENS_GENERAL_SHOP, INVENTORY_PLAYER_ONE,
    INVENTORY_PLAYER_TWO, INVENTORY_PLAYER_THREE,
    INVENTORY_PLAYER_FOUR, INVENTORY_PLAYER_FIVE, INVENTORY_NPC_LOLLER,
    INVENTORY_NPC_RVICE, INVENTORY_NPC_LAFOLIE, INVENTORY_NPC_NAKOR,
    INVENTORY_NPC_TRAVIS, INVENTORY_NPC_BLACKBEARD, INVENTORY_NPC_DAVEY_JONES,
    INVENTORY_ATHENS_GOODS_SHOP,


    INVENTORY_TYPE_GOOD, INVENTORY_TYPE_ARMOR, INVENTORY_TYPE_WEAPON,
    INVENTORY_TYPE_GENERAL_ITEM, INVENTORY_TYPE_CANNON,
    INVENTORY_TYPE_BASE_SHIP, INVENTORY_TYPE_SHIP,


    ITEM_TELESCOPE, ITEM_QUADRANT, ITEM_THEODOLITE, ITEM_SEXTANT,


    GOOD_CLOVE, GOOD_CINNAMON, GOOD_PEPPER, GOOD_NUTMEG, GOOD_PIMENTO,
    GOOD_GINGER, GOOD_VANILLA, GOOD_TEA, GOOD_COFFEE, GOOD_CACAO, GOOD_SUGAR,
    GOOD_CHEESE, GOOD_FISH, GOOD_GRAIN, GOOD_OLIVE_OIL, GOOD_RAISINS,
    GOOD_ROCK_SALT, GOOD_SILK, GOOD_COTTON, GOOD_WOOL, GOOD_FLAX,
    GOOD_COTTON_CLOTH, GOOD_SILK_CLOTH, GOOD_WOOL_CLOTH, GOOD_VELVET,
    GOOD_LINEN_CLOTH, GOOD_CORAL, GOOD_AMBER, GOOD_IVORY, GOOD_PEARL,
    GOOD_TORTOISE_SHELL, GOOD_GOLD, GOOD_SILVER, GOOD_COPPER_ORE,
    GOOD_TIN_ORE, GOOD_IRON_ORE, GOOD_ART, GOOD_CARPET, GOOD_MUSK,
    GOOD_PERFUME, GOOD_GLASS_BEADS, GOOD_DYE, GOOD_PORCELAIN, GOOD_GLASSWARE,
    GOOD_ARMS, GOOD_WOOD, GOOD_CANNONBALLS, GOOD_FOOD, GOOD_WATER,


    LAYER_BACKGROUND, LAYER_NPC, LAYER_ENTITY, LAYER_ONE, LAYER_TWO, LAYER_BLOCK,


    NPC_TRAVIS, NPC_LAFOLIE, NPC_LOLLER, NPC_NAKOR, NPC_RVICE,
    NPC_BANK_TELLER, NPC_PLAYER_ONE, NPC_PLAYER_TWO, NPC_PLAYER_THREE,
    NPC_PLAYER_FOUR, NPC_PLAYER_FIVE, NPC_SHIPYARD_OWNER,
    NPC_GENERAL_SHOP_OWNER, NPC_BLACKJACK_PLAYER, NPC_OCEAN_BATTLE,
    NPC_EMPTY, NPC_BLACKBEARD, NPC_DAVEY_JONES, NPC_KRAKEN, NPC_SHIP,
    NPC_DOCKYARD_OWNER, NPC_GOODS_SHOP_OWNER,


    NPC_TYPE_HUMAN, NPC_TYPE_SHIP, NPC_TYPE_MONSTER,


    WORLD_DINGUS_LAND, WORLD_ATHENS, WORLD_GLOBE_1,


    BASE_SHIP_BALSA, BASE_SHIP_HANSA_COG, BASE_SHIP_LIGHT_GALLEY,
    BASE_SHIP_TALLETTE, BASE_SHIP_KANSEN, BASE_SHIP_CARAVELA_LATINA,
    BASE_SHIP_CARAVELA_REDONDA, BASE_SHIP_DHOW, BASE_SHIP_JUNK,
    BASE_SHIP_BRIGANTINE, BASE_SHIP_ATAKABUNE, BASE_SHIP_FLEMISH_GALLEON,
    BASE_SHIP_NAO, BASE_SHIP_XEBEC,
    BASE_SHIP_VENETIAN_GALEASS, BASE_SHIP_PINNACE,
    BASE_SHIP_CARRACK, BASE_SHIP_LA_REALE, BASE_SHIP_BUSS,
    BASE_SHIP_GALLEON, BASE_SHIP_SLOOP, BASE_SHIP_TEKKOUSEN,
    BASE_SHIP_FRIGATE, BASE_SHIP_BARGE, BASE_SHIP_FULL_RIGGED_SHIP,


    UPDATED_STATE_NOTHING, UPDATED_STATE_EVERYTHING, UPDATED_STATE_WORLD,
    UPDATED_STATE_NPCS, UPDATED_STATE_PLAYER, UPDATED_STATE_SCENE,


    DIRECTION_UP, DIRECTION_DOWN, DIRECTION_LEFT, DIRECTION_RIGHT,


    GAME_MODE_EMPTY,
    GAME_MODE_IN_SCENE,
    GAME_MODE_IN_OCEAN_BATTLE,
    GAME_MODE_IN_PORT,
    GAME_MODE_ON_LAND,
    GAME_MODE_IN_PLAYER_MENU,
    GAME_MODE_SAILING,


    ERROR_GENERAL, ERROR_NOT_CORRECT_SCENE, ERROR_NOT_ENOUGH_GOLD,


    ERROR_BLACKJACK_GAME_OVER, ERROR_BLACKJACK_BET_NOT_RIGHT,
    ERROR_BLACKJACK_DEALER_ALREADY_ACTIONED,
    ERROR_BLACKJACK_PLAYER_ALREADY_ACTIONED,
    ERROR_BLACKJACK_GAME_ALREADY_STARTED,


    ERROR_BANK_NOT_ENOUGH_DEPOSIT,
    ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD,
    ERROR_BANK_NOT_ENOUGH_WITHDRAW,
    ERROR_BANK_PAY_EXISTING_LOAN_FIRST,
    ERROR_BANK_NOT_ENOUGH_LOAN,
    ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT,
    ERROR_BANK_TOO_MUCH_LOAN,
    ERROR_BANK_NO_LOAN,
    ERROR_BANK_PAY_LOAN_NOT_ENOUGH,
    ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN,


    ERROR_SHIPYARD_NO_SHIP_SELECTED,
    ERROR_SHIPYARD_NOT_ENOUGH_GOLD,
    ERROR_SHIPYARD_FLEET_FULL,
    ERROR_SHIPYARD_EMPTY_PREFAB_SLOT,
    ERROR_SHIPYARD_REMODEL_SPACE_GREATER_THAN_REMODEL_CAPACITY,
    ERROR_SHIPYARD_REMODEL_SPACE_GREATER_THAN_SHIP_CAPACITY,
    ERROR_SHIPYARD_NO_SPACE_REMODEL_VALUES,


    ERROR_DOCKYARD_NOT_ENOUGH_GOLD,
    ERROR_DOCKYARD_SHIP_NOT_ENOUGH_CARGO_SPACE,


    ERROR_GOODS_SHOP_NOT_ENOUGH_GOLD,
    ERROR_GOODS_SHOP_NOT_ENOUGH_FLEET_CAPACITY,
    ERROR_GOODS_SHOP_NOT_ENOUGH_SHIP_CAPACITY,
    ERROR_GOODS_SHOP_INTENDED_QTY_AT_ZERO,
    ERROR_GOODS_SHOP_LOADING_QTY_GREATER_THAN_INTENDED,
    ERROR_GOODS_SHOP_GOOD_NOT_IN_INVENTORY,
    ERROR_GOODS_SHOP_NO_GOOD_SET,


    FLEET_NAME_PLAYERS,


    SHIP_MATERIAL_TEAK, SHIP_MATERIAL_CEDAR, SHIP_MATERIAL_BEECH,
    SHIP_MATERIAL_OAK, SHIP_MATERIAL_MAHOGANY,
    SHIP_MATERIAL_COPPER, SHIP_MATERIAL_STEEL,


    FIGUREHEAD_NONE, FIGUREHEAD_SEAHORSE, FIGUREHEAD_COMMODORE,
    FIGUREHEAD_UNICORN, FIGUREHEAD_LION, FIGUREHEAD_GIANT_EAGLE,
    FIGUREHEAD_HERO, FIGUREHEAD_NEPTUNE, FIGUREHEAD_DRAGON,
    FIGUREHEAD_ANGEL, FIGUREHEAD_GODDESS, FIGUREHEAD_GRIFFIN,
    FIGUREHEAD_MERMAID, FIGUREHEAD_PHOENIX, FIGUREHEAD_SIREN,
    FIGUREHEAD_TITAN, FIGUREHEAD_WARRIOR, FIGUREHEAD_WIZARD,
    FIGUREHEAD_ZEUS, FIGUREHEAD_KRAKEN, FIGUREHEAD_LEVIATHAN,


    CANNON, CANNON_DEMI, CANNON_PEDERO, CANNON_CULVERIN,
    CANNON_DEMI_CULVERIN, CANNON_SAKER, CANNON_CARRONADE,
    CANNON_HEAVY, CANNON_CARRONADE_STAR,


    SKILL_CELESTIAL_NAVIGATION,


    OCEAN_BATTLE_END_TURN, OCEAN_BATTLE_EXIT, OCEAN_BATTLE_MOVE,
    OCEAN_BATTLE_BOARD, OCEAN_BATTLE_FIRE_CANNONS,
    OCEAN_BATTLE_RUN_NPC_TURN,


    ENTITY_START_SAILING,


    START_SAILING,


    LOAD_PORT_ATHENS,


    PORT_ATHENS,

    GAME_STRINGS_COUNT,
};


typedef struct __attribute__((packed))
{
    u32 world;
    u32 world_name;
    u32 scene;
    u32 game_mode;
    u32 updated_state;
} CURRENT;
CURRENT current;
u32* get_current_ptr()
{ return (u32*)&current; }
void set_current_world(u32 id)
{
    current.world = id;
    current.world_name = storage_world.data[id].name_id;
}
DATA_WORLD* get_current_world()
{
    return &storage_world.data[current.world];
}


u32 has_game_started = 0;

u32 accepting_input = 0;

u32 previous_game_mode = (4294967295U);


u32 players[5];
u32 active_players[5];
u32 captain_to_player[100];




u32 current_scene_take_action(u32 action)
{
    switch (current.scene)
    {
        case SCENE_NPC_RVICE:
            return scene_npc_rvice(action);
        case SCENE_NPC_LAFOLIE:
            return scene_npc_lafolie(action);
        case SCENE_NPC_NAKOR:
            return scene_npc_nakor(action);
        case SCENE_NPC_TRAVIS:
            return scene_npc_travis(action);
        case SCENE_NPC_LOLLER:
            return scene_npc_loller(action);
        case SCENE_BLACKJACK:
            return scene_blackjack(action);
        case SCENE_GENERAL_SHOP:
            return scene_general_shop(action);
        case SCENE_GOODS_SHOP:
            return scene_goods_shop(action);
        case SCENE_SHIPYARD:
            return scene_shipyard(action);
        case SCENE_DOCKYARD:
            return scene_dockyard(action);
        case SCENE_BANK:
            return scene_bank(action);
        case SCENE_OCEAN_BATTLE:
            return scene_ocean_battle(action);
        default:
            console_log("[I] Possibly missing scene map!");
            break;
    }
    return (4294967295U);
}




u32 check_if_player_stepped_on_entity(u32 player_id)
{
    for (u32 i = 0; i < 10; ++i)
    {
        if (
            storage_entity.data[i].position_x == get_player_in_world_x(player_id)
            &&
            storage_entity.data[i].position_y == get_player_in_world_y(player_id)
            &&
            storage_entity.data[i].is_interactable == 1
            &&
            storage_entity.data[i].interaction_on_step_over == 1
        )
        {
            if (storage_entity.data[i].interaction_scene == START_SAILING)
            {
                generate_world(WORLD_GLOBE_1);
            }
            return 1;
        }
    }
    return (4294967295U);
}
u32 check_if_player_triggered_entity(u32 x, u32 y)
{
    for (u32 i = 0; i < 10; ++i)
    {
        if (
            storage_entity.data[i].position_x == x
            &&
            storage_entity.data[i].position_y == y
            &&
            storage_entity.data[i].is_interactable == 1
        )
        {
            if (storage_entity.data[i].interaction_scene == LOAD_PORT_ATHENS)
            {
                generate_world(WORLD_ATHENS);
            }
            return 1;
        }
    }
    return (4294967295U);
}




u32 distance_between_coordinates(u32 a_x, u32 a_y, u32 b_x, u32 b_y)
{
    u32 dx = (b_x > a_x) ? (b_x - a_x) : (a_x - b_x);
    u32 dy = (b_y > a_y) ? (b_y - a_y) : (a_y - b_y);
    return dx + dy;
}
_Bool is_coordinate_in_range_of_coordinate(u32 a_x, u32 a_y, u32 b_x, u32 b_y, u32 range)
{
    return distance_between_coordinates(a_x, a_y, b_x, b_y) <= range;
}




u32 tick_counter = 1;
u32 rng_state = 1;
u32 init_random(u32 seed)
{
    rng_state = seed;
    return rng_state;
}
static u32 xorshift_state = 1;
u32 get_random_number(u32 min, u32 max)
{
    xorshift_state += tick_counter;
    xorshift_state ^= xorshift_state << 13;
    xorshift_state ^= xorshift_state >> 17;
    xorshift_state ^= xorshift_state << 5;

    u32 range = max - min + 1;

    return min + (xorshift_state >> 16) % range;
}
# 2142 "wasm_game.h"
u32 get_ship_available_cargo_space(u32 ship_id)
{
    DATA_SHIP* ship = get_data_ship(ship_id);
    return (ship->cargo_space - ship->total_cargo_goods);
}
u32 add_good_to_ship(u32 good_id, u32 qty, u32 ship_id)
{
    DATA_SHIP* ship = get_data_ship(ship_id);
    DATA_GOOD* good = get_data_good(good_id);
    u32 intended_goods = ship->total_cargo_goods + qty;
    if (intended_goods > ship->cargo_space)
    {
        console_log("[E] Cannot add goods to ship. Not enough cargo space");
        return (4294967295U);
    }
    _Bool already_in = 0;
    for (u32 i = 0; i < 1000; ++i)
    {
        if (ship->cargo_goods[i] == good_id)
        {
            if (ship->cargo_goods_qty[i] == (4294967295U))
            {
                ship->cargo_goods_qty[i] = 0;
            }
            ship->cargo_goods_qty[i] += qty;
            ship->total_cargo_goods += qty;
            already_in = 1;

            return ship->cargo_goods_qty[i];
        }
    }
    if (!already_in)
    {
        for (u32 i = 0; i < 1000; ++i)
        {
            if (ship->cargo_goods[i] == (4294967295U))
            {
                if (ship->cargo_goods_qty[i] == (4294967295U))
                {
                    ship->cargo_goods_qty[i] = 0;
                }
                ship->cargo_goods[i] = good_id;
                ship->cargo_goods_qty[i] += qty;
                ship->total_cargo_goods += qty;

                return ship->cargo_goods_qty[i];
            }
        }
    }
    return (4294967295U);
}
u32 get_good_qty_from_ship(u32 good_id, u32 ship_id)
{
    DATA_SHIP* ship = get_data_ship(ship_id);
    DATA_GOOD* good = get_data_good(good_id);
    for (u32 i = 0; i < 1000; ++i)
    {
        if (ship->cargo_goods[i] == good_id)
        {
            return ship->cargo_goods_qty[i];
        }
    }
    return 0;
}
u32 get_good_qty_from_fleet_ships(u32 good_id, u32 fleet_id)
{
    u32 total = (4294967295U);
    DATA_FLEET* fleet = get_data_fleet(fleet_id);
    for (u32 f = 0; f < 100; ++f)
    {
        if (fleet->ship_ids[f] == (4294967295U)) { continue; }
        u32 fleet_ship_id = fleet->ship_ids[f];
        DATA_FLEET_SHIP* fleet_ship = get_data_fleet_ship(fleet_ship_id);
        if (total == (4294967295U)) { total = 0; }
        total += get_good_qty_from_ship(good_id, fleet_ship->ship_id);
    }
    return total;
}
u32 get_total_cargo_capacity_from_fleet(u32 fleet_id)
{
    u32 total = (4294967295U);
    DATA_FLEET* fleet = get_data_fleet(fleet_id);
    for (u32 f = 0; f < 100; ++f)
    {
        if (fleet->ship_ids[f] == (4294967295U)) { continue; }
        u32 fleet_ship_id = fleet->ship_ids[f];
        DATA_FLEET_SHIP* fleet_ship = get_data_fleet_ship(fleet_ship_id);
        if (total == (4294967295U)) { total = 0; }
        DATA_SHIP* ship = get_data_ship(fleet_ship->ship_id);
        total += ship->capacity;
    }
    return total;
}
u32 get_available_cargo_capacity_from_fleet(u32 fleet_id)
{
    u32 total = (4294967295U);
    DATA_FLEET* fleet = get_data_fleet(fleet_id);
    for (u32 f = 0; f < 100; ++f)
    {
        if (fleet->ship_ids[f] == (4294967295U)) { continue; }
        u32 fleet_ship_id = fleet->ship_ids[f];
        DATA_FLEET_SHIP* fleet_ship = get_data_fleet_ship(fleet_ship_id);
        if (total == (4294967295U)) { total = 0; }
        DATA_SHIP* ship = get_data_ship(fleet_ship->ship_id);
        total += ship->capacity;
        total -= ship->total_cargo_goods;
    }
    return total;
}
u32 get_ship_total_food(u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_FOOD);
    return get_good_qty_from_ship(good_id, ship_id);
}
u32 get_ship_total_water(u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_WATER);
    return get_good_qty_from_ship(good_id, ship_id);
}
u32 get_ship_total_cannonballs(u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_CANNONBALLS);
    return get_good_qty_from_ship(good_id, ship_id);
}
u32 add_food_to_ship(u32 qty, u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_FOOD);
    return add_good_to_ship(good_id, qty, ship_id);
}
u32 add_water_to_ship(u32 qty, u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_WATER);
    return add_good_to_ship(good_id, qty, ship_id);
}
u32 add_cannonballs_to_ship(u32 qty, u32 ship_id)
{
    u32 good_id = find_storage_good_by_name_id(GOOD_CANNONBALLS);
    return add_good_to_ship(good_id, qty, ship_id);
}

u32 player_menu_previous_mode;
void enter_player_menu()
{
    player_menu_previous_mode = current.game_mode;
    current.game_mode = GAME_MODE_IN_PLAYER_MENU;
    current.updated_state = UPDATED_STATE_SCENE;
}
void exit_player_menu()
{
    current.game_mode = player_menu_previous_mode;
    current.updated_state = UPDATED_STATE_SCENE;
}




void user_input_right()
{
    handle_input(USER_INPUT_RIGHT);
}
void user_input_left()
{
    handle_input(USER_INPUT_LEFT);
}
void user_input_up()
{
    handle_input(USER_INPUT_UP);
}
void user_input_down()
{
    handle_input(USER_INPUT_DOWN);
}
void user_input_a()
{
    handle_input(USER_INPUT_A);
}
void user_input_start()
{
    console_log("START BUTTON PRESSED");
    enter_player_menu();
}
void user_input_right_bumper()
{


}
void handle_interaction_scene(u32 interaction_scene, u32 world_npc_id)
{
    switch (interaction_scene)
    {
    case SCENE_BLACKJACK:
        scene_blackjack(ACTION);
        break;
    case SCENE_GENERAL_SHOP:
        Scene_General_Shop.inventory_id = storage_world_npc.data[world_npc_id].inventory_id;
        scene_general_shop(ACTION);
        break;
    case SCENE_GOODS_SHOP:
        Scene_Goods_Shop.inventory_id = storage_world_npc.data[world_npc_id].inventory_id;
        scene_goods_shop(ACTION);
        break;
    case SCENE_SHIPYARD:

        scene_shipyard(ACTION);
        break;
    case SCENE_DOCKYARD:
        scene_dockyard(ACTION);
        break;
    case SCENE_OCEAN_FAKE_BATTLE:
        fake_ocean_battle();
        scene_ocean_battle(ACTION);
        break;
    case SCENE_NPC_RVICE:
        scene_npc_rvice(ACTION);
        break;
    case SCENE_NPC_LAFOLIE:
        scene_npc_lafolie(ACTION);
        break;
    case SCENE_NPC_NAKOR:
        scene_npc_nakor(ACTION);
        break;
    case SCENE_NPC_TRAVIS:
        scene_npc_travis(ACTION);
        break;
    case SCENE_NPC_LOLLER:
        scene_npc_loller(ACTION);
        break;
    case SCENE_BANK:
        scene_bank(ACTION);
        break;
    }
}
void handle_input(u32 input)
{
    if (current.game_mode == GAME_MODE_SAILING)
    {
        u32 world_npc_id = get_player_in_world(0);
        u32 current_world_x = storage_world_npc.data[world_npc_id].position_x;
        u32 current_world_y = storage_world_npc.data[world_npc_id].position_y;
        u32 current_world_direction = storage_world_npc.data[world_npc_id].direction;
        u32 intended_x;
        u32 intended_y;
        DATA_WORLD* current_world;
        switch (input)
        {
            case USER_INPUT_UP:
                storage_world_npc.data[world_npc_id].direction = DIRECTION_UP;
                current.updated_state = UPDATED_STATE_NPCS;
                u32 intended_y = 0;
                if (current_world_y > 0)
                {
                    intended_y = current_world_y - 1;
                }
                check_if_player_triggered_entity(current_world_x, intended_y);
                break;
            case USER_INPUT_DOWN:
                storage_world_npc.data[world_npc_id].direction = DIRECTION_DOWN;
                current.updated_state = UPDATED_STATE_NPCS;
                current_world = get_current_world();
                intended_y = 0;
                if (current_world_y < (current_world->height - 1))
                {
                    intended_y = current_world_y + 1;
                }
                check_if_player_triggered_entity(current_world_x, intended_y);
                break;
            case USER_INPUT_LEFT:
                storage_world_npc.data[world_npc_id].direction = DIRECTION_LEFT;
                current.updated_state = UPDATED_STATE_NPCS;
                intended_x = 0;
                if (current_world_x > 0)
                {
                    intended_x = current_world_x - 1;
                }
                check_if_player_triggered_entity(intended_x, current_world_y);
                break;
            case USER_INPUT_RIGHT:
                storage_world_npc.data[world_npc_id].direction = DIRECTION_RIGHT;
                current.updated_state = UPDATED_STATE_NPCS;
                current_world = get_current_world();
                intended_x = 0;
                if (current_world_x < (current_world->width - 1))
                {
                    intended_x = current_world_x + 1;
                }
                check_if_player_triggered_entity(intended_x, current_world_x);
                break;
            default:
                console_log("[I] No button push to handle here.");
                break;
        }
    }
    else if (current.game_mode == GAME_MODE_IN_PORT)
    {
        u32 world_npc_id = get_player_in_world(0);
        u32 current_world_x = storage_world_npc.data[world_npc_id].position_x;
        u32 current_world_y = storage_world_npc.data[world_npc_id].position_y;
        u32 current_world_direction = storage_world_npc.data[world_npc_id].direction;
        switch (input)
        {
            case USER_INPUT_A:
                if (current_world_direction == DIRECTION_UP)
                {
                    if (current_world_y > 0)
                    {
                        u32 intended_y = current_world_y - 1;
                        for (u32 i = 0; i < 1000; ++i)
                        {
                            if (i == world_npc_id)
                            {
                                continue;
                            }
                            u32 other_world_x = storage_world_npc.data[i].position_x;
                            u32 other_world_y = storage_world_npc.data[i].position_y;
                            if (other_world_x == current_world_x && other_world_y == intended_y)
                            {
                                u32 interaction_scene = storage_world_npc.data[i].interaction_scene;
                                handle_interaction_scene(interaction_scene, i);
                            }
                        }
                    }
                }
                else if (current_world_direction == DIRECTION_DOWN)
                {
                    if (current_world_y < storage_world.data[current.world].height)
                    {
                        u32 intended_y = current_world_y + 1;
                        for (u32 i = 0; i < 1000; ++i)
                        {
                            if (i == world_npc_id)
                            {
                                continue;
                            }
                            u32 other_world_x = storage_world_npc.data[i].position_x;
                            u32 other_world_y = storage_world_npc.data[i].position_y;
                            if (other_world_x == current_world_x && other_world_y == intended_y)
                            {
                                u32 interaction_scene = storage_world_npc.data[i].interaction_scene;
                                handle_interaction_scene(interaction_scene, i);
                            }
                        }
                    }
                }
                else if (current_world_direction == DIRECTION_LEFT)
                {
                    if (current_world_x > 0)
                    {
                        u32 intended_x = current_world_x - 1;
                        for (u32 i = 0; i < 1000; ++i)
                        {
                            if (i == world_npc_id)
                            {
                                continue;
                            }
                            u32 other_world_x = storage_world_npc.data[i].position_x;
                            u32 other_world_y = storage_world_npc.data[i].position_y;
                            if (other_world_x == intended_x && other_world_y == current_world_y)
                            {
                                u32 interaction_scene = storage_world_npc.data[i].interaction_scene;
                                handle_interaction_scene(interaction_scene, i);
                            }
                        }
                    }
                }
                else if (current_world_direction == DIRECTION_RIGHT)
                {
                    if (current_world_x < storage_world.data[current.world].width)
                    {
                        u32 intended_x = current_world_x + 1;
                        for (u32 i = 0; i < 1000; ++i)
                        {
                            if (i == world_npc_id)
                            {
                                continue;
                            }
                            u32 other_world_x = storage_world_npc.data[i].position_x;
                            u32 other_world_y = storage_world_npc.data[i].position_y;
                            if (other_world_x == intended_x && other_world_y == current_world_y)
                            {
                                u32 interaction_scene = storage_world_npc.data[i].interaction_scene;
                                handle_interaction_scene(interaction_scene, i);
                            }
                        }
                    }
                }
                break;
            case USER_INPUT_B:
            case USER_INPUT_X:
            case USER_INPUT_Y:

                break;
            case USER_INPUT_UP:
                if (current.game_mode != GAME_MODE_IN_SCENE)
                {
                    move_player_up(0);
                    check_if_player_stepped_on_entity(0);
                }
                break;
            case USER_INPUT_DOWN:
                if (current.game_mode != GAME_MODE_IN_SCENE)
                {
                    move_player_down(0);
                    check_if_player_stepped_on_entity(0);
                }
                break;
            case USER_INPUT_LEFT:
                if (current.game_mode != GAME_MODE_IN_SCENE)
                {
                    move_player_left(0);
                    check_if_player_stepped_on_entity(0);
                }
                break;
            case USER_INPUT_RIGHT:
                if (current.game_mode != GAME_MODE_IN_SCENE)
                {
                    move_player_right(0);
                    check_if_player_stepped_on_entity(0);
                }
                break;
            case USER_INPUT_START:
            case USER_INPUT_SELECT:

                break;
            case USER_INPUT_LEFT_BUMPER:
            case USER_INPUT_RIGHT_BUMPER:

                break;
            case USER_INPUT_CUSTOM_NUMBER:

                break;
            case USER_INPUT_CUSTOM_STRING:

                break;
            default:

                break;
        }
    }
}




void apply_base_ship_to_ship(u32 ship_id, u32 base_ship_id)
{
    DATA_SHIP* ship = &storage_ship.data[ship_id];
    DATA_BASE_SHIP* base_ship = &storage_base_ship.data[base_ship_id];
    ship->name_id = base_ship->name_id;
    ship->base_ship_id = base_ship_id;
    ship->tacking = base_ship->tacking;
    ship->power = base_ship->power;
    ship->speed = base_ship->speed;
    ship->durability = base_ship->durability;
    ship->price = base_ship->base_price;
    ship->capacity = base_ship->max_capacity;
}
void apply_material_to_ship(u32 ship_id, u32 material_id)
{
    DATA_SHIP* ship = &storage_ship.data[ship_id];
    DATA_BASE_SHIP* base_ship = &storage_base_ship.data[ship->base_ship_id];
    DATA_SHIP_MATERIAL* material = &storage_ship_material.data[material_id];
    if (material_id > base_ship->top_material_id)
    {
        console_log("[E] Material is not compatible with ship");
        return;
    }
    ship->material_id = material_id;
    ship->capacity += material->mod_capacity;
    ship->tacking += material->mod_tacking;
    ship->power += material->mod_power;
    ship->speed += material->mod_speed;
    ship->durability += material->mod_durability;
}




u32 are_coordinates_blocked(u32 x, u32 y)
{
    for (u32 i = 0; i < 1000; ++i) {




        if (
            storage_world_npc.used[i] == 1
            &&
            storage_world_npc.data[i].position_x == x
            &&
            storage_world_npc.data[i].position_y == y
        )
        {
            return 1;
        }
    }

    u32 block_layer_id = find_storage_layer_by_name_id(LAYER_BLOCK);
    if (block_layer_id != (4294967295U))
    {
        u32 layer_value = layer_get_value(block_layer_id, x, y);
        if (layer_value > 0 && layer_value != (4294967295U))
        {
            console_log("Block layer block");
            return 1;
        }
    }
    return 0;
}

void generate_world(u32 world_name_id)
{
    clear_all_layers();
    clear_all_world_npcs();
    clear_all_entities();
    for (u32 i = 0; i < 10; ++i)
    {
        if (Scene_Shipyard.ships_prefab[i] != (4294967295U))
        {
            free_storage_ship_slot(Scene_Shipyard.ships_prefab[i]);
        }
        Scene_Shipyard.ships_prefab[i] = (4294967295U);
    }
    clear_scene_dockyard();

    DATA_WORLD* current_world = get_current_world();

    for (u32 i = 0; i < 10; ++i)
    {
        current_world->layers[i] = (4294967295U);
    }
    current_world->total_layers = 0;
    current_world->total_npcs = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        storage_captain.data[i].world_npc_id = (4294967295U);
    }

    u32 world_width;
    u32 world_height;
    u32 npc_id;
    DATA_LAYER* layer;
    DATA_WORLD_NPC* world_npc;
    DATA_INVENTORY* inventory;
    DATA_INVENTORY_ITEM* inventory_item;

    switch (world_name_id)
    {
    case WORLD_GLOBE_1:
        previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_SAILING;
        set_current_world(find_storage_world_by_name_id(WORLD_GLOBE_1));
        world_width = current_world->width;
        world_height = current_world->height;

        layer = pull_data_layer();
        layer->name_id = LAYER_BACKGROUND;
        layer->width = world_width;
        layer->height = world_height;
        layer->same_value = 1;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_NPC;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_ONE;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 3, 3, 1);
        layer_set_value(layer->id, 4, 3, 1);
        layer = pull_data_layer();
        layer->name_id = LAYER_TWO;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 4, 3, 1);
        layer = pull_data_layer();
        layer->name_id = LAYER_BLOCK;
        layer->width = world_width;
        layer->height = world_height;
        layer->is_block = 1;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 3, 3, 1);
        layer_set_value(layer->id, 4, 3, 1);

        npc_id = get_player_npc_id(0);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->captain_id = players[0];
        world_npc->position_x = 0;
        world_npc->position_y = 0;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->is_captain = 1;
        world_npc->is_player = 1;

        storage_captain.data[0].world_npc_id = world_npc->id;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        DATA_ENTITY* entity = pull_data_entity();
        entity->name_id = PORT_ATHENS;
        entity->is_interactable = 1;
        entity->interaction_scene = LOAD_PORT_ATHENS;
        entity->position_x = 4;
        entity->position_y = 3;

        current.updated_state = UPDATED_STATE_WORLD;
        break;
    case WORLD_DINGUS_LAND:
        previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_PORT;
        set_current_world(find_storage_world_by_name_id(WORLD_DINGUS_LAND));
        world_width = current_world->width;
        world_height = current_world->height;
        layer = pull_data_layer();
        layer->name_id = LAYER_BACKGROUND;
        layer->width = world_width;
        layer->height = world_height;
        layer->same_value = 1;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_NPC;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_ONE;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_TWO;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_BLOCK;
        layer->width = world_width;
        layer->height = world_height;
        layer->is_block = 1;
        add_layer_to_world(layer->id, current.world);
        current.updated_state = UPDATED_STATE_WORLD;
        break;
    case WORLD_ATHENS:
        previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_PORT;


        Scene_Dockyard.price_food = 10;

        Scene_Dockyard.price_water = 0;
        Scene_Dockyard.price_cannonballs = 10;

        set_current_world(find_storage_world_by_name_id(WORLD_ATHENS));

        u32 world_width = current_world->width;
        u32 world_height = current_world->height;

        layer = pull_data_layer();
        layer->name_id = LAYER_BACKGROUND;
        layer->width = world_width;
        layer->height = world_height;
        layer->same_value = 1;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_NPC;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);
        layer = pull_data_layer();
        layer->name_id = LAYER_ONE;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 0, 0, 33);

        layer_set_value(layer->id, 7, 0, 35);
        layer_set_value(layer->id, 0, 1, 33);
        layer_set_value(layer->id, 0, 2, 33);
        layer_set_value(layer->id, 0, 3, 33);
        layer_set_value(layer->id, 0, 4, 33);
        for (u32 column = 1; column < 7; ++column)
        {

            layer_set_value(layer->id, column, 0, 34);
        }
        for (u32 column = 1; column < 7; ++column)
        {
            layer_set_value(layer->id, column, 1, 34);
            layer_set_value(layer->id, column, 2, 34);
            layer_set_value(layer->id, column, 3, 34);
            layer_set_value(layer->id, column, 4, 34);
        }
        layer_set_value(layer->id, 7, 1, 35);
        layer_set_value(layer->id, 7, 2, 35);
        layer_set_value(layer->id, 7, 3, 35);
        layer_set_value(layer->id, 7, 4, 35);
        layer_set_value(layer->id, 0, 5, 39);
        for (u32 column = 1; column < 7; ++column)
        {
            layer_set_value(layer->id, column, 5, 40);
        }
        layer_set_value(layer->id, 7, 5, 41);
        layer_set_value(layer->id, 4, 6, 53);
        for (u32 column = 5; column < 10; ++column)
        {
            layer_set_value(layer->id, column, 6, 54);
        }
        layer_set_value(layer->id, 10, 6, 50);
        for (u32 row = 7; row < 12; ++row)
        {
            layer_set_value(layer->id, 4, row, 56);
        }
        layer_set_value(layer->id, 4, 11, 52);
        for (u32 column = 5; column < 10; ++column)
        {
            layer_set_value(layer->id, column, 11, 55);
        }
        layer_set_value(layer->id, 10, 11, 51);
        for (u32 row = 7; row < 11; ++row)
        {
            layer_set_value(layer->id, 10, row, 57);
        }
        for (u32 row = 7; row < 11; ++row)
        {
            layer_set_value(layer->id, 5, row, 59);
        }
        for (u32 column = 6; column < 10; ++column)
        {
            for (u32 row = 7; row < 11; ++row)
            {
                layer_set_value(layer->id, column, row, 58);
            }
        }

        layer_set_value(layer->id, 6, 7, 0);
        layer_set_value(layer->id, 7, 7, 1);
        layer_set_value(layer->id, 6, 8, 2);
        layer_set_value(layer->id, 7, 8, 3);
        layer = pull_data_layer();
        layer->name_id = LAYER_TWO;
        layer->width = world_width;
        layer->height = world_height;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 7, 8, 4);

        layer_set_value(layer->id, 6, 8, 10);

        layer_set_value(layer->id, 4, 3, 20);

        layer_set_value(layer->id, 5, 2, 51);
        layer_set_value(layer->id, 6, 2, 52);
        layer_set_value(layer->id, 7, 2, 53);
        layer_set_value(layer->id, 5, 3, 50);
        layer_set_value(layer->id, 6, 3, 50);
        layer_set_value(layer->id, 7, 3, 50);
        layer = pull_data_layer();
        layer->name_id = LAYER_BLOCK;
        layer->width = world_width;
        layer->height = world_height;
        layer->is_block = 1;
        add_layer_to_world(layer->id, current.world);

        layer_set_value(layer->id, 6, 7, 1);
        layer_set_value(layer->id, 7, 7, 1);
        layer_set_value(layer->id, 6, 8, 1);
        layer_set_value(layer->id, 7, 8, 1);



        npc_id = find_storage_npc_by_name_id(NPC_BANK_TELLER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 4;
        world_npc->position_y = 0;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_BANK;
        world_npc->is_interactable = 1;
        ++storage_world.data[current.world].total_npcs;


        inventory = pull_data_inventory();
        inventory->name_id = INVENTORY_ATHENS_GENERAL_SHOP;
        inventory->total_items = 0;

        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = ITEM_TELESCOPE;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GENERAL_ITEM;
        inventory_item->type_reference = find_storage_general_item_by_name_id(ITEM_TELESCOPE);
        inventory_item->adjusted_price = 400;
        add_item_to_inventory(inventory_item->id, inventory->id);
        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = ITEM_QUADRANT;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GENERAL_ITEM;
        inventory_item->type_reference = find_storage_general_item_by_name_id(ITEM_QUADRANT);
        inventory_item->adjusted_price = 430;
        add_item_to_inventory(inventory_item->id, inventory->id);
        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = ITEM_THEODOLITE;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GENERAL_ITEM;
        inventory_item->type_reference = find_storage_general_item_by_name_id(ITEM_THEODOLITE);
        inventory_item->adjusted_price = 222;
        add_item_to_inventory(inventory_item->id, inventory->id);
        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = ITEM_SEXTANT;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GENERAL_ITEM;
        inventory_item->type_reference = find_storage_general_item_by_name_id(ITEM_SEXTANT);
        inventory_item->adjusted_price = 666;
        add_item_to_inventory(inventory_item->id, inventory->id);

        npc_id = find_storage_npc_by_name_id(NPC_GENERAL_SHOP_OWNER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 3;
        world_npc->position_y = 1;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_GENERAL_SHOP;
        world_npc->is_interactable = 1;
        world_npc->inventory_id = inventory->id;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_BLACKJACK_PLAYER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 5;
        world_npc->position_y = 0;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_BLACKJACK;
        world_npc->is_interactable = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = get_player_npc_id(0);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->captain_id = players[0];
        world_npc->position_x = 0;
        world_npc->position_y = 0;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->is_captain = 1;
        world_npc->is_player = 1;

        storage_captain.data[0].world_npc_id = world_npc->id;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_OCEAN_BATTLE);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 0;
        world_npc->position_y = 1;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_OCEAN_FAKE_BATTLE;
        world_npc->is_interactable = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_RVICE);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;

        world_npc->captain_id = 1;
        world_npc->position_x = 0;
        world_npc->position_y = 2;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_NPC_RVICE;
        world_npc->is_interactable = 1;
        world_npc->is_captain = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_LAFOLIE);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;

        world_npc->captain_id = 2;
        world_npc->position_x = 0;
        world_npc->position_y = 3;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_NPC_LAFOLIE;
        world_npc->is_interactable = 1;
        world_npc->is_captain = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_NAKOR);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;

        world_npc->captain_id = 3;
        world_npc->position_x = 0;
        world_npc->position_y = 4;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_NPC_NAKOR;
        world_npc->is_interactable = 1;
        world_npc->is_captain = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_TRAVIS);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;

        world_npc->captain_id = 4;
        world_npc->position_x = 0;
        world_npc->position_y = 5;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_NPC_TRAVIS;
        world_npc->is_interactable = 1;
        world_npc->is_captain = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_LOLLER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;

        world_npc->captain_id = 5;
        world_npc->position_x = 0;
        world_npc->position_y = 6;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_NPC_LOLLER;
        world_npc->is_interactable = 1;
        world_npc->is_captain = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        npc_id = find_storage_npc_by_name_id(NPC_SHIPYARD_OWNER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 8;
        world_npc->position_y = 8;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_SHIPYARD;
        world_npc->is_interactable = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);
        for (u32 i = 0; i < 10; ++i)
        {
            Scene_Shipyard.ships_prefab[i] = (4294967295U);
        }
        u32 base_ship_id = find_storage_base_ship_by_name_id(BASE_SHIP_BALSA);
        u32 ship_id = pull_storage_ship_next_open_slot();
        apply_base_ship_to_ship(ship_id, base_ship_id);
        apply_material_to_ship(ship_id, base_ship_id);
        storage_ship.data[ship_id].price += 107;
        storage_ship.data[ship_id].crew_space = 30;
        storage_ship.data[ship_id].cannon_space = 10;
        storage_ship.data[ship_id].cargo_space = 70;
        Scene_Shipyard.ships_prefab[0] = ship_id;
        base_ship_id = find_storage_base_ship_by_name_id(BASE_SHIP_HANSA_COG);
        ship_id = pull_storage_ship_next_open_slot();
        apply_base_ship_to_ship(ship_id, base_ship_id);
        apply_material_to_ship(ship_id, base_ship_id);
        storage_ship.data[ship_id].price += 33;
        storage_ship.data[ship_id].crew_space = 30;
        storage_ship.data[ship_id].cannon_space = 10;
        storage_ship.data[ship_id].cargo_space = 70;
        Scene_Shipyard.ships_prefab[1] = ship_id;


        Scene_Shipyard.remodel_space_price = 100;
        Scene_Shipyard.remodel_material_price = 103;
        Scene_Shipyard.remodel_cannon_price = 129;
        Scene_Shipyard.remodel_figurehead_price = 30;

        npc_id = find_storage_npc_by_name_id(NPC_DOCKYARD_OWNER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 6;
        world_npc->position_y = 11;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_DOCKYARD;
        world_npc->is_interactable = 1;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);
# 3167 "wasm_game.h"
        inventory = pull_data_inventory();
        inventory->name_id = INVENTORY_ATHENS_GOODS_SHOP;
        inventory->total_items = 0;

        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = GOOD_AMBER;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GOOD;
        inventory_item->type_reference = find_storage_good_by_name_id(GOOD_AMBER);
        inventory_item->adjusted_price = 30;
        add_item_to_inventory(inventory_item->id, inventory->id);
        inventory_item = pull_data_inventory_item();
        inventory_item->name_id = GOOD_ART;
        inventory_item->number_held = 1;
        inventory_item->type = INVENTORY_TYPE_GOOD;
        inventory_item->type_reference = find_storage_good_by_name_id(GOOD_ART);
        inventory_item->adjusted_price = 400;
        add_item_to_inventory(inventory_item->id, inventory->id);
        npc_id = find_storage_npc_by_name_id(NPC_GOODS_SHOP_OWNER);
        world_npc = pull_data_world_npc();
        world_npc->name_id = storage_npc.data[npc_id].name_id;
        world_npc->type_id = storage_npc.data[npc_id].type_id;
        world_npc->npc_id = npc_id;
        world_npc->position_x = 3;
        world_npc->position_y = 2;
        world_npc->direction = DIRECTION_DOWN;
        world_npc->interaction_scene = SCENE_GOODS_SHOP;
        world_npc->is_interactable = 1;
        world_npc->inventory_id = inventory->id;
        ++storage_world.data[current.world].total_npcs;
        update_npc_layer(world_npc->id);

        current.updated_state = UPDATED_STATE_WORLD;
        break;
    default:
        args[0].i = world_name_id;
        console_log_format("Could not find world %d", args, 1);
    }
}




void update_npc_layer(u32 world_npc_id)
{
    u32 npc_layer_id = find_storage_layer_by_name_id(LAYER_NPC);
    if (npc_layer_id != (4294967295U))
    {
        for (u32 i = 0; i < (100 * 100); ++i)
        {
            if (storage_layer.data[npc_layer_id].data[i] == world_npc_id)
            {
                storage_layer.data[npc_layer_id].data[i] = (4294967295U);
                break;
            }
        }
        layer_set_value(
            npc_layer_id,
            storage_world_npc.data[world_npc_id].position_x,
            storage_world_npc.data[world_npc_id].position_y,
            world_npc_id
        );
    }
}
void move_world_npc_to(u32 world_npc_id, u32 x, u32 y)
{
    if (x >= 0 && x < storage_world.data[current.world].width && are_coordinates_blocked(x, y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_x = x;
        current.updated_state = UPDATED_STATE_NPCS;
    }
    if (y >= 0 && y < storage_world.data[current.world].height && are_coordinates_blocked(x, y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_y = y;
        current.updated_state = UPDATED_STATE_NPCS;
    }
    update_npc_layer(world_npc_id);
}
void move_world_npc_left(u32 world_npc_id)
{
    u32 current_x = storage_world_npc.data[world_npc_id].position_x;
    u32 current_y = storage_world_npc.data[world_npc_id].position_y;
    u32 intended_x = current_x - 1;
    if (current_x > 0 && are_coordinates_blocked(intended_x, current_y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_x = intended_x;
    }
    update_npc_layer(world_npc_id);
    storage_world_npc.data[world_npc_id].direction = DIRECTION_LEFT;
    current.updated_state = UPDATED_STATE_NPCS;
}
void move_world_npc_right(u32 world_npc_id)
{
    u32 current_x = storage_world_npc.data[world_npc_id].position_x;
    u32 current_y = storage_world_npc.data[world_npc_id].position_y;
    u32 intended_x = current_x + 1;
    if (intended_x < storage_world.data[current.world].width && are_coordinates_blocked(intended_x, current_y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_x = intended_x;
    }
    update_npc_layer(world_npc_id);
    storage_world_npc.data[world_npc_id].direction = DIRECTION_RIGHT;
    current.updated_state = UPDATED_STATE_NPCS;
}
void move_world_npc_up(u32 world_npc_id)
{
    u32 current_x = storage_world_npc.data[world_npc_id].position_x;
    u32 current_y = storage_world_npc.data[world_npc_id].position_y;
    u32 intended_y = current_y - 1;
    if (current_y > 0 && are_coordinates_blocked(current_x, intended_y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_y = intended_y;
    }
    u32 npc_layer_id = find_storage_layer_by_name_id(LAYER_NPC);
    update_npc_layer(world_npc_id);
    storage_world_npc.data[world_npc_id].direction = DIRECTION_UP;
    current.updated_state = UPDATED_STATE_NPCS;
}
void move_world_npc_down(u32 world_npc_id)
{
    u32 current_x = storage_world_npc.data[world_npc_id].position_x;
    u32 current_y = storage_world_npc.data[world_npc_id].position_y;
    u32 intended_y = current_y + 1;
    if (intended_y < storage_world.data[current.world].height && are_coordinates_blocked(current_x, intended_y) != 1)
    {
        storage_world_npc.data[world_npc_id].position_y = intended_y;
    }
    u32 npc_layer_id = find_storage_layer_by_name_id(LAYER_NPC);
    update_npc_layer(world_npc_id);
    storage_world_npc.data[world_npc_id].direction = DIRECTION_DOWN;
    current.updated_state = UPDATED_STATE_NPCS;
}




u32 get_player_gold(u32 player_id)
{
    u32 captain_id = players[player_id];
    return storage_captain.data[captain_id].gold;
}
void set_player_gold(u32 player_id, u32 value)
{
    u32 captain_id = players[player_id];
    storage_captain.data[captain_id].gold = value;
}
void subtract_player_gold(u32 player_id, u32 value)
{
    u32 captain_id = players[player_id];
    storage_captain.data[captain_id].gold -= value;
}
void add_player_gold(u32 player_id, u32 value)
{
    u32 captain_id = players[player_id];
    storage_captain.data[captain_id].gold += value;
}
u32 get_player_npc_id(u32 player_id)
{
    u32 captain_id = players[player_id];
    return storage_captain.data[captain_id].npc_id;
}
u32 get_player_inventory_id(u32 player_id)
{
    u32 captain_id = players[player_id];
    return storage_captain.data[captain_id].inventory_id;
}
u32 get_player_total_items(u32 player_id)
{
    u32 inventory_id = get_player_inventory_id(player_id);
    return storage_inventory.data[inventory_id].total_items;
}
u32 get_player_in_world(u32 player_id)
{
    u32 npc_id = get_player_npc_id(player_id);
    for (u32 i = 0; i < 1000; ++i)
    {
        if (storage_world_npc.data[i].npc_id == npc_id)
        {
            return i;
        }
    }
    return (4294967295U);
}
u32 get_player_in_world_x(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    return storage_world_npc.data[world_npc_id].position_x;
}
u32 get_player_in_world_y(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    return storage_world_npc.data[world_npc_id].position_y;
}
void move_player_to(u32 player_id, u32 x, u32 y)
{
    u32 world_npc_id = get_player_in_world(player_id);
    move_world_npc_to(world_npc_id, x, y);
}
void move_player_left(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    move_world_npc_left(world_npc_id);
}
void move_player_right(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    move_world_npc_right(world_npc_id);
}
void move_player_up(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    move_world_npc_up(world_npc_id);
}
void move_player_down(u32 player_id)
{
    u32 world_npc_id = get_player_in_world(player_id);
    move_world_npc_down(world_npc_id);
}




void increment_tick_counter(u32* tick)
{
    if (*tick == (4294967295U))
    {

        *tick = 1;
    }
    else
    {
        *tick += 1;
    }
}
u32 artificial_sailing_tick = 0;
void tick()
{
    increment_tick_counter(&tick_counter);


    update_game_time();

    if (!has_game_started)
    {
        has_game_started = 1;
        accepting_input = 1;
        initialize_game_time();

        generate_world(WORLD_ATHENS);
    }
    else if (current.game_mode == GAME_MODE_IN_PORT)
    {

    }
    else if (current.game_mode == GAME_MODE_IN_SCENE)
    {

    }
    else if (current.game_mode == GAME_MODE_SAILING)
    {
        ++artificial_sailing_tick;
        if (artificial_sailing_tick % 50 != 0) { return; }
        u32 world_npc_id = get_player_in_world(0);
        u32 current_world_direction = storage_world_npc.data[world_npc_id].direction;
        if (current_world_direction == DIRECTION_UP)
        {
            move_player_up(0);
        }
        else if (current_world_direction == DIRECTION_DOWN)
        {
            move_player_down(0);
        }
        else if (current_world_direction == DIRECTION_LEFT)
        {
            move_player_left(0);
        }
        else if (current_world_direction == DIRECTION_RIGHT)
        {
            move_player_right(0);
        }
    }
}

u32 initialize_npc(u32 name_id, u32 type_id)
{
    DATA_NPC npc;
    do { u32 *ptr = (u32 *)&npc; u32 count = (sizeof(*&npc) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    npc.name_id = name_id;
    npc.type_id = NPC_TYPE_HUMAN;
    return add_storage_npc(&npc, 0);
}
u32 initialize_general_item(u32 name_id, u32 base_price)
{
    DATA_GENERAL_ITEM item;
    do { u32 *ptr = (u32 *)&item; u32 count = (sizeof(*&item) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    item.name_id = name_id;
    item.base_price = base_price;
    return add_storage_general_item(&item, 1);
}
u32 initialize_good(u32 name_id, u32 base_price)
{
    DATA_GOOD good;
    do { u32 *ptr = (u32 *)&good; u32 count = (sizeof(*&good) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    good.name_id = name_id;
    good.base_price = base_price;
    return add_storage_good(&good, 1);
}
u32 initialize_world(u32 name_id, u32 width, u32 height)
{
    if (width > 100)
    {
        console_log("[E] Cannot create world greater than max width");
        return (4294967295U);
    }
    if (height > 100)
    {
        console_log("[E] Cannot create world greater than max height");
        return (4294967295U);
    }
    DATA_WORLD world;
    do { u32 *ptr = (u32 *)&world; u32 count = (sizeof(*&world) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    world.name_id = name_id;
    world.width = width;
    world.height = height;
    world.total_npcs = 0;
    world.total_captains = 0;
    world.total_layers = 0;
    return add_storage_world(&world, 1);
}
u32 initialize_inventory(u32 name_id)
{
    DATA_INVENTORY inventory;
    do { u32 *ptr = (u32 *)&inventory; u32 count = (sizeof(*&inventory) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    inventory.name_id = name_id;
    inventory.total_items = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        inventory.inventory_items[i] = (4294967295U);
    }
    return add_storage_inventory(&inventory, 1);
}
u32 initialize_stats()
{
    DATA_STATS stats;
    do { u32 *ptr = (u32 *)&stats; u32 count = (sizeof(*&stats) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    default_stats(&stats);

    stats.seamanship = 33;
    return add_storage_stats(&stats, 1);
}
u32 initialize_skill(u32 name_id)
{
    u32 stats_id = initialize_stats();
    DATA_STATS* stats = &storage_stats.data[stats_id];
    stats->battle_level = 2;
    stats->navigation_level = 22;
    stats->leadership = 3;
    stats->seamanship = 4;
    stats->knowledge = 30;
    stats->intuition = 23;
    stats->courage = 12;
    stats->swordsmanship = 8;
    stats->charm = 33;
    stats->luck = 99;

    DATA_SKILL skill;
    do { u32 *ptr = (u32 *)&skill; u32 count = (sizeof(*&skill) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    skill.name_id = name_id;
    skill.stats_requirements_id = stats_id;
    return add_storage_skill(&skill, 1);
}
u32 initialize_fleet(u32 name_id, u32 general_id)
{
    DATA_FLEET fleet;
    do { u32 *ptr = (u32 *)&fleet; u32 count = (sizeof(*&fleet) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    fleet.name_id = name_id;
    fleet.total_ships = 1;
    fleet.total_captains = 1;
    fleet.general_id = general_id;
    return add_storage_fleet(&fleet, 1);
}
u32 initialize_ship(u32 name_id)
{
    DATA_SHIP ship;
    do { u32 *ptr = (u32 *)&ship; u32 count = (sizeof(*&ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    ship.name_id = name_id;
    return add_storage_ship(&ship, 1);



}
u32 initialize_fleet_ship(u32 name_id, u32 ship_id)
{
    DATA_FLEET_SHIP fleet_ship;
    do { u32 *ptr = (u32 *)&fleet_ship; u32 count = (sizeof(*&fleet_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    fleet_ship.name_id = name_id;
    fleet_ship.ship_id = ship_id;
    return add_storage_fleet_ship(&fleet_ship, 1);
}
u32 initialize_captain(u32 name_id, u32 type_id, u32 inventory_name_id)
{
    u32 npc_id = initialize_npc(name_id, type_id);

    DATA_CAPTAIN captain;
    do { u32 *ptr = (u32 *)&captain; u32 count = (sizeof(*&captain) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    captain.name_id = name_id;
    captain.npc_id = npc_id;
    captain.gold = 100000;
    captain.inventory_id = initialize_inventory(inventory_name_id);
    u32 stats_id = initialize_stats();
    captain.stats_id = stats_id;

    u32 captain_id = add_storage_captain(&captain, 1);
    u32 fleet_id = initialize_fleet(name_id, captain.id);
    storage_captain.data[captain_id].general_of_fleet_id = fleet_id;
    storage_fleet.data[fleet_id].general_id = captain_id;


    u32 base_ship_id = find_storage_base_ship_by_name_id(BASE_SHIP_BALSA);
    u32 ship_material_id = find_storage_ship_material_by_name_id(SHIP_MATERIAL_TEAK);
    u32 ship_id = initialize_ship(BASE_SHIP_BALSA);
    DATA_SHIP* new_ship = &storage_ship.data[ship_id];
    new_ship->base_ship_id = base_ship_id;
    new_ship->price = 400;
    new_ship->material_id = ship_material_id;
    u32 max_capacity = storage_base_ship.data[base_ship_id].max_capacity;
    new_ship->capacity = max_capacity;
    new_ship->tacking = 30;
    new_ship->power = 103;
    new_ship->speed = 333;
    new_ship->crew = 50;
    new_ship->durability = storage_base_ship.data[base_ship_id].durability;
    new_ship->cargo_space = my_floor_percentage(max_capacity, 40);
    new_ship->crew_space = my_floor_percentage(max_capacity, 40);
    new_ship->cannon_space = my_floor_percentage(max_capacity, 20);
    new_ship->total_cargo_goods = 0;

    u32 fleet_ship_id = initialize_fleet_ship(BASE_SHIP_BALSA, ship_id);
    storage_fleet_ship.data[fleet_ship_id].is_flagship = 1;
    add_fleet_ship_to_fleet(fleet_ship_id, fleet_id);
    u32 good_food_id = find_storage_good_by_name_id(GOOD_FOOD);
    u32 good_water_id = find_storage_good_by_name_id(GOOD_WATER);
    u32 good_cannonballs_id = find_storage_good_by_name_id(GOOD_CANNONBALLS);
    add_good_to_ship(good_food_id, 10, ship_id);
    add_good_to_ship(good_water_id, 10, ship_id);
    add_good_to_ship(good_cannonballs_id, 10, ship_id);

    if (name_id == NPC_BLACKBEARD)
    {
        ship_id = initialize_ship(BASE_SHIP_BALSA);
        DATA_SHIP* new_ship = &storage_ship.data[ship_id];
        new_ship->base_ship_id = base_ship_id;
        new_ship->price = 400;
        new_ship->material_id = ship_material_id;
        new_ship->capacity = 400;
        new_ship->tacking = 30;
        new_ship->power = 103;
        new_ship->speed = 333;
        new_ship->crew = 50;
        new_ship->total_cargo_goods = 0;
        fleet_ship_id = initialize_fleet_ship(BASE_SHIP_BALSA, ship_id);
        add_fleet_ship_to_fleet(fleet_ship_id, fleet_id);
    }

    return captain_id;
}

void initialize_game()
{




    tick_counter = 1;
    current.game_mode = GAME_MODE_EMPTY;
    clear_all_layers();
    do { for (u32 i = 0; i < (100); ++i) { (captain_to_player)[i] = (4294967295U); } } while (0);


    for (u32 i = 0; i < 10; ++i)
    {
        Scene_Shipyard.ships_prefab[i] = (4294967295U);
    }

    initialize_skill(SKILL_CELESTIAL_NAVIGATION);





    initialize_general_item(ITEM_TELESCOPE, 200);
    initialize_general_item(ITEM_QUADRANT, 201);
    initialize_general_item(ITEM_THEODOLITE, 202);
    initialize_general_item(ITEM_SEXTANT, 203);

    initialize_good(GOOD_CLOVE, 10);
    initialize_good(GOOD_CINNAMON, 10);
    initialize_good(GOOD_PEPPER, 10);
    initialize_good(GOOD_NUTMEG, 10);
    initialize_good(GOOD_PIMENTO, 10);
    initialize_good(GOOD_GINGER, 10);
    initialize_good(GOOD_VANILLA, 10);
    initialize_good(GOOD_TEA, 10);
    initialize_good(GOOD_COFFEE, 10);
    initialize_good(GOOD_CACAO, 10);
    initialize_good(GOOD_SUGAR, 10);
    initialize_good(GOOD_CHEESE, 10);
    initialize_good(GOOD_FISH, 10);
    initialize_good(GOOD_GRAIN, 10);
    initialize_good(GOOD_OLIVE_OIL, 10);
    initialize_good(GOOD_RAISINS, 10);
    initialize_good(GOOD_ROCK_SALT, 10);
    initialize_good(GOOD_SILK, 10);
    initialize_good(GOOD_COTTON, 10);
    initialize_good(GOOD_WOOL, 10);
    initialize_good(GOOD_FLAX, 10);
    initialize_good(GOOD_COTTON_CLOTH, 10);
    initialize_good(GOOD_SILK_CLOTH, 10);
    initialize_good(GOOD_WOOL_CLOTH, 10);
    initialize_good(GOOD_VELVET, 10);
    initialize_good(GOOD_LINEN_CLOTH, 10);
    initialize_good(GOOD_CORAL, 10);
    initialize_good(GOOD_AMBER, 10);
    initialize_good(GOOD_IVORY, 10);
    initialize_good(GOOD_PEARL, 10);
    initialize_good(GOOD_TORTOISE_SHELL, 10);
    initialize_good(GOOD_GOLD, 100);
    initialize_good(GOOD_SILVER, 100);
    initialize_good(GOOD_COPPER_ORE, 100);
    initialize_good(GOOD_TIN_ORE, 220);
    initialize_good(GOOD_IRON_ORE, 230);
    initialize_good(GOOD_ART, 240);
    initialize_good(GOOD_CARPET, 250);
    initialize_good(GOOD_MUSK, 260);
    initialize_good(GOOD_PERFUME, 270);
    initialize_good(GOOD_GLASS_BEADS, 280);
    initialize_good(GOOD_DYE, 290);
    initialize_good(GOOD_PORCELAIN, 300);
    initialize_good(GOOD_GLASSWARE, 500);
    initialize_good(GOOD_ARMS, 800);

    initialize_good(GOOD_WOOD, 100);

    initialize_good(GOOD_CANNONBALLS, 20);
    initialize_good(GOOD_FOOD, 20);
    initialize_good(GOOD_WATER, 0);

    initialize_world(WORLD_ATHENS, 100, 100);
    initialize_world(WORLD_DINGUS_LAND, 100, 100);
    initialize_world(WORLD_GLOBE_1, 100, 100);

    clear_all_ship_materials();
    DATA_SHIP_MATERIAL new_ship_material;
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_TEAK;
    new_ship_material.base_price = 100;
    new_ship_material.mod_power = 10;
    new_ship_material.mod_tacking = 10;
    new_ship_material.mod_speed = 10;
    new_ship_material.mod_durability = 10;
    new_ship_material.mod_capacity = 10;
    u32 sm_teak_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_CEDAR;
    new_ship_material.base_price = 200;
    new_ship_material.mod_power = 20;
    new_ship_material.mod_tacking = 15;
    new_ship_material.mod_speed = 15;
    new_ship_material.mod_durability = 20;
    new_ship_material.mod_capacity = 10;
    u32 sm_cedar_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_BEECH;
    new_ship_material.base_price = 350;
    new_ship_material.mod_power = 25;
    new_ship_material.mod_tacking = 25;
    new_ship_material.mod_speed = 20;
    new_ship_material.mod_durability = 30;
    new_ship_material.mod_capacity = 20;
    u32 sm_beech_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_OAK;
    new_ship_material.base_price = 425;
    new_ship_material.mod_power = 30;
    new_ship_material.mod_tacking = 25;
    new_ship_material.mod_speed = 20;
    new_ship_material.mod_durability = 25;
    new_ship_material.mod_capacity = 20;
    u32 sm_oak_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_MAHOGANY;
    new_ship_material.base_price = 500;
    new_ship_material.mod_power = 30;
    new_ship_material.mod_tacking = 30;
    new_ship_material.mod_speed = 30;
    new_ship_material.mod_durability = 40;
    new_ship_material.mod_capacity = 30;
    u32 sm_mahogany_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_COPPER;
    new_ship_material.base_price = 800;
    new_ship_material.mod_power = 55;
    new_ship_material.mod_tacking = 55;
    new_ship_material.mod_speed = 50;
    new_ship_material.mod_durability = 70;
    new_ship_material.mod_capacity = 50;
    u32 sm_copper_id = add_storage_ship_material(&new_ship_material, 1);
    do { u32 *ptr = (u32 *)&new_ship_material; u32 count = (sizeof(*&new_ship_material) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_ship_material.name_id = SHIP_MATERIAL_STEEL;
    new_ship_material.base_price = 1000;
    new_ship_material.mod_power = 70;
    new_ship_material.mod_tacking = 70;
    new_ship_material.mod_speed = 70;
    new_ship_material.mod_durability = 100;
    new_ship_material.mod_capacity = 100;
    u32 sm_steel_id = add_storage_ship_material(&new_ship_material, 1);

    clear_all_cannons();
    DATA_CANNON new_cannon;
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON;
    new_cannon.range = 3;
    new_cannon.power = 8;
    new_cannon.base_price = 10;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_DEMI;
    new_cannon.range = 3;
    new_cannon.power = 12;
    new_cannon.base_price = 20;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_PEDERO;
    new_cannon.range = 3;
    new_cannon.power = 16;
    new_cannon.base_price = 30;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_CULVERIN;
    new_cannon.range = 4;
    new_cannon.power = 24;
    new_cannon.base_price = 50;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_DEMI_CULVERIN;
    new_cannon.range = 4;
    new_cannon.power = 30;
    new_cannon.base_price = 80;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_SAKER;
    new_cannon.range = 4;
    new_cannon.power = 40;
    new_cannon.base_price = 120;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_CARRONADE;
    new_cannon.range = 5;
    new_cannon.power = 50;
    new_cannon.base_price = 160;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_CARRONADE;
    new_cannon.range = 6;
    new_cannon.power = 60;
    new_cannon.base_price = 240;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_HEAVY;
    new_cannon.range = 6;
    new_cannon.power = 65;
    new_cannon.base_price = 280;
    add_storage_cannon(&new_cannon, 1);
    do { u32 *ptr = (u32 *)&new_cannon; u32 count = (sizeof(*&new_cannon) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_cannon.name_id = CANNON_CARRONADE_STAR;
    new_cannon.range = 7;
    new_cannon.power = 80;
    new_cannon.base_price = 400;
    add_storage_cannon(&new_cannon, 1);

    clear_all_figureheads();
    DATA_FIGUREHEAD new_figurehead;

    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_SEAHORSE;
    new_figurehead.base_price = 100;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_COMMODORE;
    new_figurehead.base_price = 120;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_UNICORN;
    new_figurehead.base_price = 140;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_LION;
    new_figurehead.base_price = 160;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_GIANT_EAGLE;
    new_figurehead.base_price = 180;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_HERO;
    new_figurehead.base_price = 200;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_NEPTUNE;
    new_figurehead.base_price = 220;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_DRAGON;
    new_figurehead.base_price = 240;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_ANGEL;
    new_figurehead.base_price = 260;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_GODDESS;
    new_figurehead.base_price = 280;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_GRIFFIN;
    new_figurehead.base_price = 300;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_MERMAID;
    new_figurehead.base_price = 400;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_PHOENIX;
    new_figurehead.base_price = 500;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_SIREN;
    new_figurehead.base_price = 600;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_TITAN;
    new_figurehead.base_price = 700;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_WARRIOR;
    new_figurehead.base_price = 800;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_WIZARD;
    new_figurehead.base_price = 900;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_ZEUS;
    new_figurehead.base_price = 1000;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_KRAKEN;
    new_figurehead.base_price = 1200;
    add_storage_figurehead(&new_figurehead, 1);
    do { u32 *ptr = (u32 *)&new_figurehead; u32 count = (sizeof(*&new_figurehead) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_figurehead.name_id = FIGUREHEAD_LEVIATHAN;
    new_figurehead.base_price = 1400;
    add_storage_figurehead(&new_figurehead, 1);

    DATA_BASE_SHIP new_base_ship;
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_BALSA;

    new_base_ship.top_material_id = sm_cedar_id;
    new_base_ship.base_price = 100;
    new_base_ship.max_capacity = 100;
    new_base_ship.tacking = 20;
    new_base_ship.power = 20;
    new_base_ship.speed = 20;
    new_base_ship.durability = 20;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_HANSA_COG;

    new_base_ship.top_material_id = sm_cedar_id;
    new_base_ship.base_price = 80;
    new_base_ship.max_capacity = 100;
    new_base_ship.tacking = 17;
    new_base_ship.power = 14;
    new_base_ship.speed = 14;
    new_base_ship.durability = 10;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_LIGHT_GALLEY;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 130;
    new_base_ship.max_capacity = 150;
    new_base_ship.tacking = 28;
    new_base_ship.power = 30;
    new_base_ship.speed = 25;
    new_base_ship.durability = 30;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_TALLETTE;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 180;
    new_base_ship.max_capacity = 180;
    new_base_ship.tacking = 34;
    new_base_ship.power = 35;
    new_base_ship.speed = 35;
    new_base_ship.durability = 40;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_KANSEN;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 300;
    new_base_ship.max_capacity = 240;
    new_base_ship.tacking = 40;
    new_base_ship.power = 40;
    new_base_ship.speed = 40;
    new_base_ship.durability = 50;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_CARAVELA_LATINA;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 500;
    new_base_ship.max_capacity = 320;
    new_base_ship.tacking = 50;
    new_base_ship.power = 52;
    new_base_ship.speed = 51;
    new_base_ship.durability = 60;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_CARAVELA_REDONDA;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 700;
    new_base_ship.max_capacity = 500;
    new_base_ship.tacking = 60;
    new_base_ship.power = 65;
    new_base_ship.speed = 60;
    new_base_ship.durability = 70;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_DHOW;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 800;
    new_base_ship.max_capacity = 400;
    new_base_ship.tacking = 70;
    new_base_ship.power = 70;
    new_base_ship.speed = 70;
    new_base_ship.durability = 75;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_JUNK;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 680;
    new_base_ship.max_capacity = 420;
    new_base_ship.tacking = 69;
    new_base_ship.power = 69;
    new_base_ship.speed = 69;
    new_base_ship.durability = 69;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_BRIGANTINE;

    new_base_ship.top_material_id = sm_beech_id;
    new_base_ship.base_price = 900;
    new_base_ship.max_capacity = 640;
    new_base_ship.tacking = 80;
    new_base_ship.power = 82;
    new_base_ship.speed = 87;
    new_base_ship.durability = 85;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_ATAKABUNE;

    new_base_ship.top_material_id = sm_oak_id;
    new_base_ship.base_price = 1200;
    new_base_ship.max_capacity = 640;
    new_base_ship.tacking = 80;
    new_base_ship.power = 82;
    new_base_ship.speed = 87;
    new_base_ship.durability = 85;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_FLEMISH_GALLEON;

    new_base_ship.top_material_id = sm_oak_id;
    new_base_ship.base_price = 1200;
    new_base_ship.max_capacity = 900;
    new_base_ship.tacking = 88;
    new_base_ship.power = 90;
    new_base_ship.speed = 93;
    new_base_ship.durability = 90;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_NAO;

    new_base_ship.top_material_id = sm_oak_id;
    new_base_ship.base_price = 1800;
    new_base_ship.max_capacity = 1200;
    new_base_ship.tacking = 94;
    new_base_ship.power = 94;
    new_base_ship.speed = 94;
    new_base_ship.durability = 95;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_XEBEC;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 2400;
    new_base_ship.max_capacity = 1000;
    new_base_ship.tacking = 100;
    new_base_ship.power = 100;
    new_base_ship.speed = 100;
    new_base_ship.durability = 120;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_VENETIAN_GALEASS;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 4000;
    new_base_ship.max_capacity = 1400;
    new_base_ship.tacking = 115;
    new_base_ship.power = 115;
    new_base_ship.speed = 120;
    new_base_ship.durability = 140;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_PINNACE;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 4500;
    new_base_ship.max_capacity = 1600;
    new_base_ship.tacking = 105;
    new_base_ship.power = 105;
    new_base_ship.speed = 110;
    new_base_ship.durability = 200;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_CARRACK;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 6000;
    new_base_ship.max_capacity = 2000;
    new_base_ship.tacking = 140;
    new_base_ship.power = 140;
    new_base_ship.speed = 140;
    new_base_ship.durability = 240;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_LA_REALE;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 8000;
    new_base_ship.max_capacity = 2400;
    new_base_ship.tacking = 160;
    new_base_ship.power = 160;
    new_base_ship.speed = 160;
    new_base_ship.durability = 300;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_BUSS;

    new_base_ship.top_material_id = sm_copper_id;
    new_base_ship.base_price = 8000;
    new_base_ship.max_capacity = 3000;
    new_base_ship.tacking = 110;
    new_base_ship.power = 110;
    new_base_ship.speed = 110;
    new_base_ship.durability = 400;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_GALLEON;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 10000;
    new_base_ship.max_capacity = 4000;
    new_base_ship.tacking = 180;
    new_base_ship.power = 180;
    new_base_ship.speed = 180;
    new_base_ship.durability = 600;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_SLOOP;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 11000;
    new_base_ship.max_capacity = 4400;
    new_base_ship.tacking = 160;
    new_base_ship.power = 160;
    new_base_ship.speed = 160;
    new_base_ship.durability = 580;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_TEKKOUSEN;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 16000;
    new_base_ship.max_capacity = 5000;
    new_base_ship.tacking = 200;
    new_base_ship.power = 200;
    new_base_ship.speed = 200;
    new_base_ship.durability = 640;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_FRIGATE;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 25000;
    new_base_ship.max_capacity = 6000;
    new_base_ship.tacking = 240;
    new_base_ship.power = 240;
    new_base_ship.speed = 240;
    new_base_ship.durability = 720;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_BARGE;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 40000;
    new_base_ship.max_capacity = 8000;
    new_base_ship.tacking = 300;
    new_base_ship.power = 300;
    new_base_ship.speed = 300;
    new_base_ship.durability = 860;
    add_storage_base_ship(&new_base_ship, 1);
    do { u32 *ptr = (u32 *)&new_base_ship; u32 count = (sizeof(*&new_base_ship) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
    new_base_ship.name_id = BASE_SHIP_FULL_RIGGED_SHIP;

    new_base_ship.top_material_id = sm_steel_id;
    new_base_ship.base_price = 50000;
    new_base_ship.max_capacity = 9000;
    new_base_ship.tacking = 400;
    new_base_ship.power = 400;
    new_base_ship.speed = 400;
    new_base_ship.durability = 1000;
    add_storage_base_ship(&new_base_ship, 1);


    initialize_captain(NPC_PLAYER_ONE, NPC_TYPE_HUMAN, INVENTORY_PLAYER_ONE);
    initialize_captain(NPC_PLAYER_TWO, NPC_TYPE_HUMAN, INVENTORY_PLAYER_TWO);
    initialize_captain(NPC_PLAYER_THREE, NPC_TYPE_HUMAN, INVENTORY_PLAYER_THREE);
    initialize_captain(NPC_PLAYER_FOUR, NPC_TYPE_HUMAN, INVENTORY_PLAYER_FOUR);
    initialize_captain(NPC_PLAYER_FIVE, NPC_TYPE_HUMAN, INVENTORY_PLAYER_FIVE);
    initialize_captain(NPC_BLACKBEARD, NPC_TYPE_HUMAN, INVENTORY_NPC_BLACKBEARD);
    initialize_captain(NPC_DAVEY_JONES, NPC_TYPE_HUMAN, INVENTORY_NPC_DAVEY_JONES);
    initialize_captain(NPC_RVICE, NPC_TYPE_HUMAN, INVENTORY_NPC_RVICE);
    initialize_captain(NPC_LAFOLIE, NPC_TYPE_HUMAN, INVENTORY_NPC_LAFOLIE);
    initialize_captain(NPC_LOLLER, NPC_TYPE_HUMAN, INVENTORY_NPC_LOLLER);
    initialize_captain(NPC_NAKOR, NPC_TYPE_HUMAN, INVENTORY_NPC_NAKOR);
    initialize_captain(NPC_TRAVIS, NPC_TYPE_HUMAN, INVENTORY_NPC_TRAVIS);

    initialize_npc(NPC_EMPTY, NPC_TYPE_HUMAN);
    initialize_npc(NPC_GENERAL_SHOP_OWNER, NPC_TYPE_HUMAN);
    initialize_npc(NPC_BANK_TELLER, NPC_TYPE_HUMAN);
    initialize_npc(NPC_BLACKJACK_PLAYER, NPC_TYPE_HUMAN);
    initialize_npc(NPC_OCEAN_BATTLE, NPC_TYPE_HUMAN);
    initialize_npc(NPC_SHIPYARD_OWNER, NPC_TYPE_HUMAN);
    initialize_npc(NPC_DOCKYARD_OWNER, NPC_TYPE_HUMAN);
    initialize_npc(NPC_GOODS_SHOP_OWNER, NPC_TYPE_HUMAN);

    initialize_npc(NPC_KRAKEN, NPC_TYPE_MONSTER);

    initialize_npc(NPC_SHIP, NPC_TYPE_SHIP);
}

void test()
{
    set_player_gold(0, 90000);
    console_log("Debug ran");


}





typedef struct __attribute__((packed))
{
    u32 deck[48];
    u32 deck_index;
    u32 player_deck[10];
    u32 player_deck_iterator;
    u32 dealer_deck[10];
    u32 dealer_deck_iterator;
    u32 player_value;
    u32 dealer_value;
    u32 bet_amount;
    u32 bet_minimum;
    u32 bet_maximum;


    u32 initialized;
    u32 player_standing;
    u32 dealer_standing;
    u32 player_hitting;
    u32 dealer_hitting;
    u32 player_won;
    u32 dealer_won;
    u32 game_over;
} BLACKJACK;
BLACKJACK blackjack;
u32* get_blackjack_ptr()
{ return (u32*)&blackjack; }
void clear_blackjack_data()
{
    blackjack.bet_amount = (4294967295U);
    blackjack.player_standing = 0;
    blackjack.dealer_standing = 0;
    blackjack.player_hitting = 0;
    blackjack.dealer_hitting = 0;
    blackjack.player_won = 0;
    blackjack.dealer_won = 0;
    blackjack.game_over = 0;
}
u32 blackjack_get_card_value(u32 card_id)
{
    u32 card = card_id % 13;
    if (card == 0) { card = 11; }
    if (card > 10) { card = 10; }
    return card;
}
u32 blackjack_get_dealers_deck_value()
{
    u32 total = 0;
    for (u32 i = 0; i < 10; ++i)
    {
        if (blackjack.dealer_deck[i] != (4294967295U))
        {
            total += blackjack_get_card_value(blackjack.dealer_deck[i]);
        }
    }
    return total;
}
u32 blackjack_get_players_deck_value()
{
    u32 total = 0;
    for (u32 i = 0; i < 10; ++i)
    {
        if (blackjack.dealer_deck[i] != (4294967295U))
        {
            total += blackjack_get_card_value(blackjack.player_deck[i]);
        }
    }
    return total;
}
void blackjack_add_card_to_players_deck()
{
    blackjack.player_deck[blackjack.player_deck_iterator] = blackjack.deck[blackjack.deck_index];
    ++blackjack.deck_index;
    ++blackjack.player_deck_iterator;
}
void blackjack_add_card_to_dealer_deck()
{
    blackjack.dealer_deck[blackjack.dealer_deck_iterator] = blackjack.deck[blackjack.deck_index];
    ++blackjack.deck_index;
    ++blackjack.dealer_deck_iterator;
}
void blackjack_setup()
{
    if (blackjack.initialized == 1)
    {
        console_log("[E] Tried to initialized blackjack but already setup");
        return;
    }
    u32 deck_index = 0;
    for (u32 i = 0; i < 52; ++i)
    {

        if (i % 13 != 10)
        {
            blackjack.deck[deck_index] = i;
            deck_index += 1;
        }
    }
    for (u32 i = 47; i > 0; --i)
    {
        u32 random_index = get_random_number(0, i + 1);
        u32 temp = blackjack.deck[i];
        blackjack.deck[i] = blackjack.deck[random_index];
        blackjack.deck[random_index] = temp;
    }
    blackjack.deck_index = 0;
    blackjack.bet_amount = (4294967295U);
    blackjack.player_standing = (4294967295U);
    blackjack.dealer_standing = (4294967295U);
    blackjack.player_hitting = (4294967295U);
    blackjack.dealer_hitting = (4294967295U);
    for (u32 i = 0; i < 10; ++i)
    {
        blackjack.player_deck[i] = (4294967295U);
        blackjack.dealer_deck[i] = (4294967295U);
    }
    blackjack.player_standing = (4294967295U);
    blackjack.dealer_standing = (4294967295U);
    blackjack.player_deck_iterator = 0;
    blackjack.dealer_deck_iterator = 0;
    blackjack_add_card_to_players_deck();
    blackjack_add_card_to_dealer_deck();
    blackjack_add_card_to_players_deck();
    blackjack_add_card_to_dealer_deck();
    blackjack.initialized = 1;
}
void blackjack_dealer_turn()
{
    u32 dealer_total = blackjack_get_dealers_deck_value();
    if (dealer_total >= 17)
    {
        blackjack.dealer_standing = 1;
    }
    else
    {
        blackjack.dealer_hitting = 1;
        blackjack_add_card_to_dealer_deck();
    }
}
void blackjack_check_winner()
{
    u32 player_total = blackjack_get_players_deck_value();
    u32 dealer_total = blackjack_get_dealers_deck_value();

    if (dealer_total > 21)
    {
        console_log("Dealer over 21");
        blackjack.player_won = 1;
        blackjack.game_over = 1;
    }
    if (player_total > 21)
    {
        console_log("Player over 21");
        blackjack.dealer_won = 1;
        blackjack.game_over = 1;
    }

    if (blackjack.player_standing != 1 && blackjack.dealer_standing != 1)
    {
        console_log("Nobody is standing");
    }

    if (blackjack.player_standing == 1 && blackjack.dealer_standing == 1)
    {
        console_log("Both are standing");

        if (dealer_total > 21)
        {
            console_log("Dealer over 21 [b]");
            blackjack.player_won = 1;
            blackjack.game_over = 1;
        }
        else if (player_total > 21)
        {
            console_log("Player over 21 [b]");
            blackjack.dealer_won = 1;
            blackjack.game_over = 1;
        }
        else if (dealer_total > player_total)
        {
            console_log("dealer more than player");
            blackjack.dealer_won = 1;
            blackjack.game_over = 1;
        }
        else if (player_total > dealer_total)
        {
            console_log("player more than dealer");
            blackjack.player_won = 1;
            blackjack.game_over = 1;
        }
        else if (dealer_total == player_total)
        {
            console_log("Samesies");

            blackjack.dealer_won = 1;
            blackjack.game_over = 1;
        }
        else if (dealer_total == 21)
        {
            console_log("dealer 21");
            blackjack.dealer_won = 1;
            blackjack.game_over = 1;
        }
        else if (player_total == 21)
        {
            console_log("player 21");
            blackjack.player_won = 1;
            blackjack.game_over = 1;
        }
        else
        {
            console_log("House always wins");

            blackjack.dealer_won = 1;
            blackjack.game_over = 1;
        }
    }
}

u32 scene_blackjack(u32 action)
{
    if (Scene_Blackjack.flag_initialized == 0)
    {
        console_log("[I] Setting up scene blackjack");
        current.scene = SCENE_BLACKJACK;
        Scene_Blackjack.flag_initialized = 1;
        Scene_Blackjack.previous_game_mode = current.game_mode;
        blackjack.bet_minimum = 100;
        blackjack.bet_maximum = 10000;
        Scene_Blackjack.dialog_id = DIALOG_BLACKJACK_WELCOME;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != SCENE_BLACKJACK
    )
    {
        Scene_Blackjack.error_code = ERROR_NOT_CORRECT_SCENE;
        console_log("[E] Already in scene and it's not blackjack");
        return (4294967295U);
    }
    if (
        blackjack.bet_amount < blackjack.bet_minimum
        ||
        blackjack.bet_amount > blackjack.bet_maximum
        ||
        blackjack.bet_amount > get_player_gold(0)
    )
    {
        Scene_Blackjack.error_code = ERROR_BLACKJACK_BET_NOT_RIGHT;
        console_log("[E] Bet amount is less than min or greater than max");
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_PLACE_BET:
        console_log("[I] Blackjack bet placed. Setting up game");
        if (
            blackjack.player_hitting || blackjack.player_standing
            ||
            blackjack.dealer_hitting || blackjack.dealer_standing
        )
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_ALREADY_STARTED;
            console_log("[E] Game is already started");
        }
        else if (blackjack.game_over)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_OVER;
            console_log("[E] Game is already over");
        }
        else
        {
            blackjack_setup();
        }
        break;
    case ACTION_PLAYER_HIT:
        if (blackjack.player_hitting || blackjack.player_standing)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_PLAYER_ALREADY_ACTIONED;
            console_log("[E] Player already took action");
        }
        else if (blackjack.game_over)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_OVER;
            console_log("[E] Game already over");
        }
        else
        {
            blackjack.player_hitting = 1;
            blackjack_add_card_to_players_deck();
            blackjack_check_winner();
        }
        break;
    case ACTION_PLAYER_STAND:
        if (blackjack.player_hitting || blackjack.player_standing)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_PLAYER_ALREADY_ACTIONED;
            console_log("[E] Player already took action");
        }
        else if (blackjack.game_over)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_OVER;
            console_log("[E] Game already over");
        }
        else
        {
            blackjack.player_standing = 1;
            blackjack_check_winner();
        }
        break;
    case ACTION_DEALER_TURN:
        if (blackjack.dealer_hitting || blackjack.dealer_standing)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_DEALER_ALREADY_ACTIONED;
            console_log("[E] Dealer already took action");
        }
        else if (blackjack.game_over)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_OVER;
            console_log("[E] Game already over");
        }
        else
        {
            blackjack_dealer_turn();
            blackjack_check_winner();
        }
        break;
    case ACTION_NEXT:
        if (blackjack.game_over)
        {
            Scene_Blackjack.error_code = ERROR_BLACKJACK_GAME_OVER;
            console_log("[E] Game already over");
        }
        else if (
            (blackjack.player_standing && blackjack.dealer_standing)
            ||
            (blackjack.player_standing && blackjack.dealer_hitting)
            ||
            (blackjack.player_hitting && blackjack.dealer_standing)
            ||
            (blackjack.player_hitting && blackjack.dealer_hitting)
        )
        {
            console_log("[I] Resetting blackjack turn");
            blackjack.player_standing = 0;
            blackjack.dealer_standing = 0;
            blackjack.player_hitting = 0;
            blackjack.dealer_hitting = 0;
        }
        else
        {
            Scene_Blackjack.error_code = ERROR_GENERAL;
            console_log("[E] Not ready to reset blackjack turn");
        }
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting blackjack scene");
        clear_blackjack_data();
        break;
    case ACTION:
        console_log("[I] Nothing to do here");
        break;
    default:
        Scene_Blackjack.error_code = ERROR_GENERAL;
        console_log("[E] Invalid action for blackjack");
        break;
    }
    return (4294967295U);
}





u32 scene_general_shop(u32 action)
{
    if (Scene_General_Shop.flag_initialized == 0)
    {
        console_log("[I] Setting up scene general shop");
        current.scene = SCENE_GENERAL_SHOP;
        Scene_General_Shop.flag_initialized = 1;
        Scene_General_Shop.flag_confirmed = 0;
        Scene_General_Shop.previous_game_mode = current.game_mode;
        current.updated_state = UPDATED_STATE_SCENE;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != SCENE_GENERAL_SHOP
    )
    {
        console_log("[E] Already in scene and it's not general shop");
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_BUY:
        console_log("[I] General shop buying.");
        u32 total_price = 0;
        for (u32 c = 0; c < 100; ++c)
        {
            u32 qty = Scene_General_Shop.chosen_items[c];
            if (qty == 0 || qty == (4294967295U)) { continue; }
            u32 id = storage_inventory.data[Scene_General_Shop.inventory_id].inventory_items[c];
            total_price += storage_inventory_item.data[id].adjusted_price;
        }
        u32 player_gold = get_player_gold(0);
        if (total_price > player_gold)
        {
            Scene_General_Shop.error_code = ERROR_NOT_ENOUGH_GOLD;
            Scene_General_Shop.flag_bought = 0;
        }
        else
        {
            subtract_player_gold(0, total_price);
            u32 player_inventory_id = get_player_inventory_id(0);
            for (u32 c = 0; c < 100; ++c)
            {
                u32 qty = Scene_General_Shop.chosen_items[c];
                if (qty == 0 || qty == (4294967295U)) { continue; }
                u32 id = storage_inventory.data[Scene_General_Shop.inventory_id].inventory_items[c];
                u32 new_id = pull_storage_inventory_item_next_open_slot();

                storage_inventory_item.data[new_id] = storage_inventory_item.data[id];
                add_item_to_inventory(new_id, player_inventory_id);
            }
            Scene_General_Shop.flag_bought = 1;
        }
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting Scene");
        clear_inventory_items_by_inventory_id(Scene_General_Shop.inventory_id);
        Scene_General_Shop.flag_confirmed = 1;
        Scene_General_Shop.flag_initialized = 0;
        Scene_General_Shop.flag_bought = 0;
        Scene_General_Shop.inventory_id = (4294967295U);
        current.game_mode = Scene_General_Shop.previous_game_mode;
        current.updated_state = UPDATED_STATE_SCENE;
        current.scene = (4294967295U);
        break;
    case ACTION:
        console_log("[I] Nothing to do here");
        break;
    default:
        console_log("[E] Invalid action for general shop");
        break;
    }
    return (4294967295U);
}





typedef struct __attribute__((packed))
{
    u32 id;
    u32 dialog_id;
    u32 flag_initialized;
    u32 flag_confirmed;
    u32 previous_game_mode;
    u32 error_code;
} DATA_SCENE_OCEAN_BATTLE;
DATA_SCENE_OCEAN_BATTLE Scene_Ocean_Battle;
u32* get_data_scene_ocean_battle_ptr()
{ return (u32*)&Scene_Ocean_Battle; }






typedef struct __attribute__((packed))
{
    u32 turn_order_fleets[10];
    u32 turn_order_fleet_ships[(10 * 100)];
    u32 turn_order_world_npcs[(10 * 100)];
    u32 turn_order_ships[(10 * 100)];
    u32 total_fleets;
    u32 attacker_id;
    u32 target_id;
    u32 total_ships;
    u32 turn_order;
    u32 turn_history[3000];
    u32 valid_move_coords[100];
    u32 total_valid_move_coords;
    u32 valid_cannon_coords[100];
    u32 total_valid_cannon_coords;
    u32 valid_boarding_coords[100];
    u32 total_valid_boarding_coords;
    u32 intended_move_coords[2];
    u32 intended_cannon_coords[2];
    u32 intended_boarding_coords[2];
    u32 victory;
    u32 player_victory;
    u32 fleet_victory;
    u32 who_won;
    u32 moved;
    u32 attacked;
} DATA_OCEAN_BATTLE;
DATA_OCEAN_BATTLE data_ocean_battle;
u32* get_data_ocean_battle_ptr()
{ return (u32*)&data_ocean_battle; }
void clear_ocean_battle()
{
    for (u32 i = 0; i < 10; ++i)
    {
        data_ocean_battle.turn_order_fleets[i] = (4294967295U);
    }
    for (u32 i = 0; i < (10 * 100); ++i)
    {
        data_ocean_battle.turn_order_fleet_ships[i] = (4294967295U);
        data_ocean_battle.turn_order_world_npcs[i] = (4294967295U);
        data_ocean_battle.turn_order_ships[i] = (4294967295U);
    }
    for (u32 i = 0; i < 3000; ++i)
    {
        data_ocean_battle.turn_history[i] = (4294967295U);
    }
    for (u32 i = 0; i < 100; ++i)
    {
        data_ocean_battle.valid_move_coords[i] = (4294967295U);
        data_ocean_battle.valid_cannon_coords[i] = (4294967295U);
        data_ocean_battle.valid_boarding_coords[i] = (4294967295U);
    }
    for (u32 i = 0; i < 2; ++i)
    {
        data_ocean_battle.intended_move_coords[i] = (4294967295U);
        data_ocean_battle.intended_cannon_coords[i] = (4294967295U);
        data_ocean_battle.intended_boarding_coords[i] = (4294967295U);
    }
    data_ocean_battle.total_ships = 0;
    data_ocean_battle.total_fleets = 0;
}

void ob_add_fleet(u32 fleet_id)
{
    _Bool is_already_in = 0;
    for (u32 i = 0; i < 10; ++i)
    {
        if (data_ocean_battle.turn_order_fleets[i] == fleet_id)
        {
            is_already_in = 1;
            return;
        }
    }
    _Bool added = 0;
    for (u32 i = 0; i < 10; ++i)
    {
        if (data_ocean_battle.turn_order_fleets[i] != (4294967295U)) { continue; }
        data_ocean_battle.turn_order_fleets[i] = fleet_id;
        ++data_ocean_battle.total_fleets;
        added = 1;
        break;
    }
    if (!added)
    {
        console_log("[E] Could not add fleet to battle");
        return;
    }
    DATA_FLEET* fleet = &storage_fleet.data[fleet_id];
    for (u32 i = 0; i < 100; ++i)
    {
        if (fleet->ship_ids[i] != (4294967295U))
        {
            data_ocean_battle.turn_order_fleet_ships[data_ocean_battle.total_ships] = fleet->ship_ids[i];
            DATA_FLEET_SHIP* fleet_ship = &storage_fleet_ship.data[fleet->ship_ids[i]];
            data_ocean_battle.turn_order_ships[data_ocean_battle.total_ships] = fleet_ship->ship_id;

            DATA_WORLD_NPC world_npc;
            do { u32 *ptr = (u32 *)&world_npc; u32 count = (sizeof(*&world_npc) / sizeof(u32)); for (u32 i = 0; i < count; ++i) { ptr[i] = ((4294967295U)); } } while (0);
            world_npc.name_id = NPC_SHIP;
            world_npc.position_x = 0;
            world_npc.position_y = 0;
            world_npc.direction = DIRECTION_DOWN;
            world_npc.entity_id = fleet_ship->id;
            world_npc.type_id = NPC_TYPE_SHIP;
            world_npc.is_player = 0;
            if (fleet->general_id == 0)
            {
                world_npc.is_player = 1;
            }
            u32 wnpcid = add_storage_world_npc(&world_npc, 1);
            data_ocean_battle.turn_order_world_npcs[data_ocean_battle.total_ships] = wnpcid;
            ++data_ocean_battle.total_ships;
        }
    }
}
void ob_setup_turn_order()
{
    u32 new_fleet_ships_turn_order[(10 * 100)];
    u32 new_world_npcs_turn_order[(10 * 100)];
    u32 new_ships_turn_order[(10 * 100)];







    data_ocean_battle.turn_order = 0;
}
void ob_get_moves_in_range()
{
    u32 current_turn_order = data_ocean_battle.turn_order;
    u32 current_fsid = data_ocean_battle.turn_order_fleet_ships[current_turn_order];
    DATA_FLEET_SHIP* current_fs = &storage_fleet_ship.data[current_fsid];
    u32 current_wnpcid = data_ocean_battle.turn_order_world_npcs[current_turn_order];
    DATA_WORLD_NPC* current_wnpc = &storage_world_npc.data[current_wnpcid];

    u32 current_valid_cannon_coords_iterator = 0;
    u32 current_valid_boarding_coords_iterator = 0;

    for (u32 i = 0; i < (10 * 100); ++i)
    {
        u32 fsid = data_ocean_battle.turn_order_fleet_ships[i];
        if (fsid == (4294967295U)) { continue; }
        DATA_FLEET_SHIP* fleet_ship = &storage_fleet_ship.data[fsid];
        if (fleet_ship->id == current_fs->id || fleet_ship->fleet_id == current_fs->fleet_id)
        {
            continue;
        }
        u32 ship_id = data_ocean_battle.turn_order_ships[i];
        DATA_SHIP* ship = &storage_ship.data[ship_id];
        if (ship->durability <= 0 || ship->crew <= 0)
        {
            continue;
        }
        u32 wnpcid = data_ocean_battle.turn_order_world_npcs[i];
        DATA_WORLD_NPC* wnpc = &storage_world_npc.data[wnpcid];
        u32 cannon_range = 8;
        u32 boarding_range = 1;
        if (
            is_coordinate_in_range_of_coordinate(
                current_wnpc->position_x,
                current_wnpc->position_y,
                wnpc->position_x,
                wnpc->position_y,
                cannon_range
            )
        )
        {
            data_ocean_battle.valid_cannon_coords[current_valid_cannon_coords_iterator] = wnpc->position_x;
            ++current_valid_cannon_coords_iterator;
            data_ocean_battle.valid_cannon_coords[current_valid_cannon_coords_iterator] = wnpc->position_y;
            ++current_valid_cannon_coords_iterator;
            ++data_ocean_battle.total_valid_cannon_coords;
        }
        else
        {
            args[0].i = wnpc->position_x;
            args[1].i = wnpc->position_y;
            args[2].i = wnpcid;
            console_log_format("Not in range somehow px:%d, py:%d wnpcid:%d", args, 3);
        }
        if (
            is_coordinate_in_range_of_coordinate(
                current_wnpc->position_x,
                current_wnpc->position_y,
                wnpc->position_x,
                wnpc->position_y,
                boarding_range
            )
        )
        {
            data_ocean_battle.valid_boarding_coords[current_valid_boarding_coords_iterator] = wnpc->position_x;
            ++current_valid_boarding_coords_iterator;
            data_ocean_battle.valid_boarding_coords[current_valid_boarding_coords_iterator] = wnpc->position_y;
            ++current_valid_boarding_coords_iterator;
            ++data_ocean_battle.total_valid_boarding_coords;
        }
    }
    u32 move_range = 4;
    u32 start_x = 0;
    u32 start_y = 0;
    DATA_WORLD* current_world = get_current_world();
    u32 end_x = current_world->width;
    u32 end_y = current_world->height;
    u32 current_valid_coords_iterator = 0;
    if ((current_wnpc->position_x - move_range) <= ((4294967295U) - 100))
    {
        start_x = (current_wnpc->position_x - move_range);
    }
    if ((current_wnpc->position_y - move_range) <= ((4294967295U) - 100))
    {
        start_y = (current_wnpc->position_y - move_range);
    }
    if ((current_wnpc->position_x + move_range) <= current_world->width)
    {
        end_x = (current_wnpc->position_x + move_range);
    }
    if ((current_wnpc->position_y + move_range) <= current_world->height)
    {
        end_y = (current_wnpc->position_y + move_range);
    }
    u32 cx = current_wnpc->position_x;
    u32 cy = current_wnpc->position_y;
    for (u32 y = start_y; y < end_y; ++y)
    {
        for (u32 x = start_x; x < end_x; ++x)
        {
            if (
                x == current_wnpc->position_x
                &&
                y == current_wnpc->position_y
            ) { continue; }
            if (are_coordinates_blocked(x, y)) { continue; }
            if (!is_coordinate_in_range_of_coordinate(cx, cy, x, y, move_range))
            { continue; }
            data_ocean_battle.valid_move_coords[current_valid_coords_iterator] = x;
            ++current_valid_coords_iterator;
            data_ocean_battle.valid_move_coords[current_valid_coords_iterator] = y;
            ++current_valid_coords_iterator;
            ++data_ocean_battle.total_valid_move_coords;
        }
    }
}
void ob_get_in_range()
{
    ob_get_moves_in_range();



}
void ob_increment_turn_order()
{
    data_ocean_battle.moved = 0;
    data_ocean_battle.attacked = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        data_ocean_battle.valid_move_coords[i] = (4294967295U);
        data_ocean_battle.valid_cannon_coords[i] = (4294967295U);
        data_ocean_battle.valid_boarding_coords[i] = (4294967295U);
    }
    data_ocean_battle.total_valid_move_coords = 0;
    data_ocean_battle.total_valid_cannon_coords = 0;
    data_ocean_battle.total_valid_boarding_coords = 0;
    _Bool turn_updated = 0;

    for (u32 i = 0; i < (10 * 100); ++i)
    {
        if (i <= data_ocean_battle.turn_order) { continue; }
        u32 ship_id = data_ocean_battle.turn_order_ships[i];
        if (ship_id == (4294967295U))
        {
            continue;
        }
        DATA_SHIP* ship = &storage_ship.data[ship_id];
        if (ship->crew == 0 || ship->durability == 0)
        {
            continue;
        }
        turn_updated = 1;
        data_ocean_battle.turn_order = i;
        break;
    }
    if (!turn_updated)
    {
        console_log("[E] Might have reached end of turn order");
        data_ocean_battle.turn_order = 0;
    }
    u32 wnpcid = data_ocean_battle.turn_order_world_npcs[data_ocean_battle.turn_order];
    DATA_WORLD_NPC* wnpc = &storage_world_npc.data[wnpcid];
    if (wnpc->is_player == (4294967295U) || wnpc->is_player == 0)
    {
        ob_get_in_range();

        if (data_ocean_battle.total_valid_move_coords > 0)
        {
            u32 max_moves = data_ocean_battle.total_valid_move_coords - 1;
            u32 rand_move = get_random_number(0, max_moves);
            rand_move *= 2;
            u32 x = data_ocean_battle.valid_move_coords[rand_move];
            u32 y = data_ocean_battle.valid_move_coords[rand_move + 1];
            if (x != (4294967295U))
            {
                data_ocean_battle.intended_move_coords[0] = x;
                data_ocean_battle.intended_move_coords[1] = y;
            }
            else
            {
                args[0].i = rand_move;
                console_log_format("somehow got a bad rand move", args, 1);
            }
        }

        if (data_ocean_battle.total_valid_cannon_coords > 0)
        {
            for (u32 i = 0; i < 100; i += 2)
            {
                u32 x = data_ocean_battle.valid_cannon_coords[i];
                u32 y = data_ocean_battle.valid_cannon_coords[i + 1];
                if (x == (4294967295U))
                {
                    continue;
                }
                data_ocean_battle.intended_cannon_coords[0] = x;
                data_ocean_battle.intended_cannon_coords[1] = y;
                break;
            }
            data_ocean_battle.intended_boarding_coords[0] = (4294967295U);
            data_ocean_battle.intended_boarding_coords[1] = (4294967295U);
        }
        else if (data_ocean_battle.total_valid_boarding_coords > 0)
        {
            for (u32 i = 0; i < 100; i += 2)
            {
                u32 x = data_ocean_battle.valid_boarding_coords[i];
                u32 y = data_ocean_battle.valid_boarding_coords[i + 1];
                if (x == (4294967295U))
                {
                    continue;
                }
                data_ocean_battle.intended_boarding_coords[0] = x;
                data_ocean_battle.intended_boarding_coords[1] = y;
                break;
            }
            data_ocean_battle.intended_cannon_coords[0] = (4294967295U);
            data_ocean_battle.intended_cannon_coords[1] = (4294967295U);
        }
        console_log("[I] got new coords for npc");
    }
}
void ob_last_man_standing()
{


    u32 fleet_ship_count[10] = {0};
    u32 fleet_ship_ids[(10 * 100)];
    for (u32 i = 0; i < (10 * 100); ++i)
    {
        fleet_ship_ids[i] = (4294967295U);
    }

    _Bool players_fleet_standing = 0;
    for (u32 i = 0; i < (10 * 100); ++i)
    {
        u32 fleet_ship_id = data_ocean_battle.turn_order_fleet_ships[i];
        u32 ship_id = data_ocean_battle.turn_order_ships[i];
        if (fleet_ship_id == (4294967295U)) { continue; }
        DATA_SHIP* ship = &storage_ship.data[ship_id];
        if (ship->crew > 0 && ship->durability > 0)
        {
            u32 fleet_id = storage_fleet_ship.data[fleet_ship_id].fleet_id;
            if (storage_fleet.data[fleet_id].general_id == 0)
            {
                players_fleet_standing = 1;
            }
            ++fleet_ship_count[fleet_id];
            fleet_ship_ids[i] = fleet_id;
        }
    }

    u32 total_fleets_with_ships = 0;
    for (u32 i = 0; i < 10; ++i)
    {
        if (fleet_ship_count[i] > 0)
        {
            ++total_fleets_with_ships;
        }
    }

    if (total_fleets_with_ships > 1)
    {
        console_log("[I] Still more than one fleet left in the battle");
    }
    else if (total_fleets_with_ships == 1)
    {
        for (u32 i = 0; i < (10 * 100); ++i)
        {
            if (fleet_ship_ids[i] != (4294967295U))
            {
                data_ocean_battle.fleet_victory = fleet_ship_ids[i];
            }
        }

        if (players_fleet_standing)
        {
            data_ocean_battle.player_victory = 1;
        }
        data_ocean_battle.victory = 1;
        console_log("[I] One fleet left. Victory condition set.");
    }
    else
    {
        console_log("[E] Got into some unknown state when checking for fleets with ships left in battle");
    }
}
void fake_ocean_battle()
{
    generate_world(WORLD_DINGUS_LAND);
    clear_ocean_battle();

    ob_add_fleet(storage_captain.data[0].general_of_fleet_id);
    u32 blackbeard = find_storage_captain_by_name_id(NPC_BLACKBEARD);
    ob_add_fleet(storage_captain.data[blackbeard].general_of_fleet_id);
    DATA_WORLD* current_world = get_current_world();
# 5159 "wasm_game.h"
    u32 start_x = 0;
    u32 start_y = 0;
    u32 formation[12] = {1, 3, 5, (4294967295U), 0, 2, 4, 6, (4294967295U), 1, 3, 5};
    u32 formation_x = 0;
    for (u32 f = 0; f < 10; ++f)
    {
        u32 fleet_id = data_ocean_battle.turn_order_fleets[f];
        u32 total = get_storage_world_npc_total_used_slots();
        for (u32 i = 0; i < total; ++i)
        {
            u32 fleet_ship_id = storage_world_npc.data[i].entity_id;
            if (storage_fleet_ship.data[fleet_ship_id].fleet_id == fleet_id)
            {
                if (formation[formation_x] == (4294967295U))
                {
                    start_y += 1;
                    ++formation_x;
                }
                u32 this_x = start_x + formation[formation_x];

                move_world_npc_to(i, this_x, start_y);
                ++formation_x;
            }
        }
        start_x += 8;
        if (start_x > current_world->width)
        {
            start_y += 3;
            start_x = 0;
        }
        if (start_y > current_world->height)
        {
            console_log("[E] We somehow went over the battle map placing ships");
        }
        formation_x = 0;
    }



    u32 max_attempts = 300;
    u32 current_attempt = 0;
    u32 max_width = current_world->width - 1;
    u32 max_height = current_world->height - 1;
    while (current_attempt < max_attempts)
    {
        u32 x = get_random_number(0, max_width);
        u32 y = get_random_number(0, max_height);
        if (!are_coordinates_blocked(x, y))
        {
            u32 layer_id = find_storage_layer_by_name_id(LAYER_ONE);
            layer_set_value(layer_id, x, y, 42);
            layer_id = find_storage_layer_by_name_id(LAYER_BLOCK);
            layer_set_value(layer_id, x, y, 1);
        }
        ++current_attempt;
    }
}
u32 scene_ocean_battle(u32 action)
{
    if (Scene_Ocean_Battle.flag_initialized == 0)
    {
        console_log("[I] Setting up ocean battle scene");
        current.scene = SCENE_OCEAN_BATTLE;
        Scene_Ocean_Battle.id = SCENE_OCEAN_BATTLE;

        Scene_Ocean_Battle.flag_initialized = 1;
        Scene_Ocean_Battle.flag_confirmed = 0;
        Scene_Ocean_Battle.previous_game_mode = current.game_mode;
        current.updated_state = UPDATED_STATE_SCENE;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Ocean_Battle.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }






    u32 intended_x;
    u32 intended_y;
    switch (action)
    {
    case OCEAN_BATTLE_END_TURN:
        if (data_ocean_battle.victory)
        {
            console_log("[I] Battle already has a victory. Cannot end turn");
            break;
        }
        console_log("[I] Ending Turn");
        u32 wnpcid = data_ocean_battle.turn_order_world_npcs[data_ocean_battle.turn_order];
        DATA_WORLD_NPC* wnpc = &storage_world_npc.data[wnpcid];
        if (wnpc->is_player)
        {
            data_ocean_battle.intended_move_coords[0] = (4294967295U);
            data_ocean_battle.intended_move_coords[1] = (4294967295U);
            data_ocean_battle.intended_cannon_coords[0] = (4294967295U);
            data_ocean_battle.intended_cannon_coords[1] = (4294967295U);
            data_ocean_battle.intended_boarding_coords[0] = (4294967295U);
            data_ocean_battle.intended_boarding_coords[1] = (4294967295U);
            ob_increment_turn_order();



        }
        else
        {
            console_log("[E] Player cannot end a turn when it's not their turn");
        }
        break;
    case OCEAN_BATTLE_FIRE_CANNONS:
        if (data_ocean_battle.victory)
        {
            console_log("[I] Battle already has a victory. Cannot fire cannons");
            break;
        }
        if (data_ocean_battle.attacked)
        {
            console_log("[I] Already attacked with boarding. Cannot attack again");
            break;
        }

        intended_x = data_ocean_battle.intended_cannon_coords[0];
        intended_y = data_ocean_battle.intended_cannon_coords[1];
        for (u32 i = 0; i < 1000; ++i)
        {
            if (
                storage_world_npc.data[i].position_x == intended_x
                &&
                storage_world_npc.data[i].position_y == intended_y
            )
            {
                u32 ship_id = storage_world_npc.data[i].entity_id;
                DATA_SHIP* ship = &storage_ship.data[ship_id];
                u32 damage = get_random_number(1, 20);
                if (damage > ship->durability)
                {
                    ship->durability = 0;
                }
                else
                {
                    ship->durability -= damage;
                }
                console_log("[I] Damage dealt");
                break;
            }
        }
        data_ocean_battle.attacked = 1;
        console_log("[I] Cannon attack complete");
        ob_last_man_standing();
        break;
    case OCEAN_BATTLE_BOARD:
        if (data_ocean_battle.victory)
        {
            console_log("[I] Battle already has a victory. Cannot fire cannons");
            break;
        }
        if (data_ocean_battle.attacked)
        {
            console_log("[I] Already attacked with cannons. Cannot attack again");
            break;
        }

        intended_x = data_ocean_battle.intended_boarding_coords[0];
        intended_y = data_ocean_battle.intended_boarding_coords[1];
        for (u32 i = 0; i < 1000; ++i)
        {
            if (
                storage_world_npc.data[i].position_x == intended_x
                &&
                storage_world_npc.data[i].position_y == intended_y
            )
            {
                u32 ship_id = storage_world_npc.data[i].entity_id;
                DATA_SHIP* ship = &storage_ship.data[ship_id];
                u32 damage = get_random_number(1, 20);
                if (damage > ship->crew)
                {
                    ship->crew = 0;
                }
                else
                {
                    ship->crew -= damage;
                }
                console_log("[I] Damage dealt");
                break;
            }
        }
        data_ocean_battle.attacked = 1;
        console_log("[I] Boarding complete");
        ob_last_man_standing();
        break;
    case OCEAN_BATTLE_MOVE:
        if (data_ocean_battle.victory)
        {
            console_log("[I] Battle already has a victory. Cannot fire cannons");
            break;
        }
        if (data_ocean_battle.moved)
        {
            console_log("[I] Already moved. Cannot move again.");
            break;
        }

        u32 wnpc_id = data_ocean_battle.turn_order_world_npcs[data_ocean_battle.turn_order];
        storage_world_npc.data[wnpc_id].position_x = data_ocean_battle.intended_move_coords[0];
        storage_world_npc.data[wnpc_id].position_y = data_ocean_battle.intended_move_coords[1];
        data_ocean_battle.moved = 1;
        console_log("[I] Move completed");
        break;
    case OCEAN_BATTLE_RUN_NPC_TURN:
        if (data_ocean_battle.victory)
        {
            console_log("[I] Battle already has a victory. Cannot fire cannons");
        }
        if (data_ocean_battle.moved)
        {
            console_log("[I] Already moved. Cannot move again.");
        }
        else if (data_ocean_battle.total_valid_move_coords > 0)
        {
            u32 wnpc_id = data_ocean_battle.turn_order_world_npcs[data_ocean_battle.turn_order];
            storage_world_npc.data[wnpc_id].position_x = data_ocean_battle.intended_move_coords[0];
            storage_world_npc.data[wnpc_id].position_y = data_ocean_battle.intended_move_coords[1];
            data_ocean_battle.moved = 1;
            console_log("[I] Move completed");
        }

        if (data_ocean_battle.attacked)
        {
            console_log("[I] Already moved. Cannot attack again.");
        }
        else
        {
            if (data_ocean_battle.total_valid_cannon_coords > 0)
            {

                u32 intended_x = data_ocean_battle.intended_cannon_coords[0];
                u32 intended_y = data_ocean_battle.intended_cannon_coords[1];
                if (intended_x != (4294967295U))
                {
                    for (u32 i = 0; i < 1000; ++i)
                    {
                        if (
                            storage_world_npc.data[i].position_x == intended_x
                            &&
                            storage_world_npc.data[i].position_y == intended_y
                        )
                        {
                            u32 ship_id = storage_world_npc.data[i].entity_id;
                            DATA_SHIP* ship = &storage_ship.data[ship_id];
                            u32 damage = get_random_number(1, 20);
                            if (damage > ship->durability)
                            {
                                ship->durability = 0;
                            }
                            else
                            {
                                ship->durability -= damage;
                            }
                            console_log("[I] Damage dealt");
                            break;
                        }
                    }
                    data_ocean_battle.attacked = 1;
                    console_log("[I] Cannon attack complete");
                }
            }
            else if (data_ocean_battle.total_valid_boarding_coords > 0)
            {

                intended_x = data_ocean_battle.intended_boarding_coords[0];
                intended_y = data_ocean_battle.intended_boarding_coords[1];
                if (intended_x != (4294967295U))
                {
                    for (u32 i = 0; i < 1000; ++i)
                    {
                        if (
                            storage_world_npc.data[i].position_x == intended_x
                            &&
                            storage_world_npc.data[i].position_y == intended_y
                        )
                        {
                            u32 ship_id = storage_world_npc.data[i].entity_id;
                            DATA_SHIP* ship = &storage_ship.data[ship_id];
                            u32 damage = get_random_number(1, 20);
                            if (damage > ship->crew)
                            {
                                ship->crew = 0;
                            }
                            else
                            {
                                ship->crew -= damage;
                            }
                            console_log("[I] Damage dealt");
                            break;
                        }
                    }
                    data_ocean_battle.attacked = 1;
                    console_log("[I] Cannon attack complete");
                }
            }
        }
        ob_last_man_standing();
        if (data_ocean_battle.victory == 0)
        {
            ob_increment_turn_order();
        }
        break;
    case OCEAN_BATTLE_EXIT:

        console_log("[I] Ocean battle exit. Exiting scene.");
        Scene_Ocean_Battle.flag_confirmed = 1;
        Scene_Ocean_Battle.flag_initialized = 0;
        current.game_mode = Scene_Ocean_Battle.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;


        break;
    }
# 5497 "wasm_game.h"
    console_log("[I] Did anything happen?");
    return (4294967295U);
}




u32 run_scene_single_dialog(u32 action, u32 scene_id, u32 scene_dialog_id)
{
    if (Scene_Single_Dialog.flag_initialized == 0)
    {
        console_log("[I] Setting up single dialog scene");
        current.scene = scene_id;
        Scene_Single_Dialog.id = scene_id;
        Scene_Single_Dialog.dialog_id = scene_dialog_id;
        Scene_Single_Dialog.flag_initialized = 1;
        Scene_Single_Dialog.flag_confirmed = 0;
        Scene_Single_Dialog.previous_game_mode = current.game_mode;
        current.updated_state = UPDATED_STATE_SCENE;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Single_Dialog.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }


    if (
        action == ACTION_CONFIRM
        &&
        Scene_Single_Dialog.flag_confirmed == 0
    )
    {
        console_log("[I] Single dialog scene confirmation. Exiting scene.");
        Scene_Single_Dialog.flag_confirmed = 1;
        Scene_Single_Dialog.flag_initialized = 0;
        current.game_mode = Scene_Single_Dialog.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;


        return (4294967295U);
    }
    else if (action != ACTION)
    {
        console_log("[E] Invalid action for this scene");
    }

    return Scene_Single_Dialog.dialog_id;
}
u32 scene_npc_rvice(u32 action)
{
    return run_scene_single_dialog(
        action,
        SCENE_NPC_RVICE,
        DIALOG_NPC_RVICE
    );
}
u32 scene_npc_lafolie(u32 action)
{
    return run_scene_single_dialog(
        action,
        SCENE_NPC_LAFOLIE,
        DIALOG_NPC_LAFOLIE
    );
}
u32 scene_npc_nakor(u32 action)
{
    return run_scene_single_dialog(
        action,
        SCENE_NPC_NAKOR,
        DIALOG_NPC_NAKOR
    );
}
u32 scene_npc_travis(u32 action)
{
    return run_scene_single_dialog(
        action,
        SCENE_NPC_TRAVIS,
        DIALOG_NPC_TRAVIS
    );
}
u32 scene_npc_loller(u32 action)
{
    return run_scene_single_dialog(
        action,
        SCENE_NPC_LOLLER,
        DIALOG_NPC_LOLLER
    );
}





u32 scene_bank(u32 action)
{
    if (Scene_Bank.flag_initialized == 0)
    {
        console_log("[I] Setting up bank scene");
        current.scene = SCENE_BANK;
        bank.deposit_interest_rate = 7;
        bank.loan_interest_rate = 20;
        Scene_Bank.id = SCENE_BANK;
        Scene_Bank.dialog_id = DIALOG_BANK_WELCOME;
        Scene_Bank.flag_initialized = 1;
        Scene_Bank.previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Bank.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }
    Scene_Bank.error_code = (4294967295U);
    switch (action)
    {
    case ACTION_BANK_DEPOSIT:
        if (bank.to_deposit == 0)
        {
            console_log("[E] Need to deposit more than 0 gold");
            Scene_Bank.error_code = ERROR_BANK_NOT_ENOUGH_DEPOSIT;
        }
        else if (bank.to_deposit > get_player_gold(0))
        {
            console_log("[E] Player doesn't have enough gold to deposit");
            Scene_Bank.error_code = ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD;
        }
        else
        {
            console_log("[I] Depositing gold to bank");
            subtract_player_gold(0, bank.to_deposit);
            bank.deposit_amount += bank.to_deposit;
            Scene_Bank.dialog_id = ACTION_BANK_DEPOSIT_SUCCESS;
        }
        break;
    case ACTION_BANK_WITHDRAW:
        if (bank.to_withdraw == 0)
        {
            console_log("[E] Need to withdraw more than 0 gold");
            Scene_Bank.error_code = ERROR_BANK_NOT_ENOUGH_WITHDRAW;
        }
        else if (bank.to_withdraw > bank.deposit_amount)
        {
            console_log("[E] Cannot withdraw more than current account");
            Scene_Bank.error_code = ERROR_BANK_WITHDRAW_MORE_THAN_DEPOSIT;
        }
        else
        {
            console_log("[I] Withdrawing gold from bank");
            bank.deposit_amount -= bank.to_withdraw;
            Scene_Bank.dialog_id = ACTION_BANK_WITHDRAW_SUCCESS;
        }
        break;
    case ACTION_BANK_TAKE_LOAN:
        if (bank.loan_amount > 0)
        {
            console_log("[E] Must first pay off existing loan");
            Scene_Bank.error_code = ERROR_BANK_PAY_EXISTING_LOAN_FIRST;
        }
        else if (bank.to_loan == 0)
        {
            console_log("[E] Need to loan more than 0 gold");
            Scene_Bank.error_code = ERROR_BANK_NOT_ENOUGH_LOAN;
        }
        else if (bank.to_loan > 10000)
        {
            console_log("[E] Cannot loan this amount");
            Scene_Bank.error_code = ERROR_BANK_TOO_MUCH_LOAN;
        }
        else
        {
            console_log("[I] Loaning gold from bank");
            bank.loan_amount = bank.to_loan;
            add_player_gold(0, bank.to_loan);
            Scene_Bank.dialog_id = ACTION_BANK_TAKE_LOAN_SUCCESS;
        }
        break;
    case ACTION_BANK_PAY_LOAN:
        if (bank.loan_amount == 0)
        {
            console_log("[E] No loan from bank");
            Scene_Bank.error_code = ERROR_BANK_NO_LOAN;
        }
        else if (bank.to_pay_loan == 0)
        {
            console_log("[E] Cannot pay loan with 0 gold");
            Scene_Bank.error_code = ERROR_BANK_PAY_LOAN_NOT_ENOUGH;
        }
        else if (bank.to_pay_loan > get_player_gold(0))
        {
            console_log("[E] Not enough player gold to pay loan");
            Scene_Bank.error_code = ERROR_BANK_NOT_ENOUGH_PLAYER_GOLD;
        }
        else if (bank.to_pay_loan > bank.loan_amount)
        {
            console_log("[E] Cannot pay more than the loan amount");
            Scene_Bank.error_code = ERROR_BANK_PAY_LOAN_MORE_THAN_LOAN;
        }
        else
        {
            bank.loan_amount -= bank.to_pay_loan;
            subtract_player_gold(0, bank.to_pay_loan);
            Scene_Bank.dialog_id = ACTION_BANK_PAY_LOAN_SUCCESS;
        }
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting bank scene");
        Scene_Bank.flag_initialized = 0;
        current.game_mode = Scene_Bank.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    }
    return (4294967295U);
}




u32 scene_shipyard(u32 action)
{
    if (Scene_Shipyard.flag_initialized == 0)
    {
        console_log("[I] Setting up shipyard scene");
        current.scene = SCENE_SHIPYARD;
        Scene_Shipyard.id = SCENE_SHIPYARD;
        Scene_Shipyard.dialog_id = DIALOG_SHIPYARD_WELCOME;
        Scene_Shipyard.flag_initialized = 1;
        Scene_Shipyard.previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Shipyard.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }
    DATA_SHIP* ship;
    DATA_SHIP_MATERIAL* material;
    Scene_Shipyard.error_code = (4294967295U);
    u32 total_space;
    if (
        (
            ACTION_SHIPYARD_REMODEL_SHIP
            ||
            ACTION_SHIPYARD_REMODEL_SHIP_MATERIAL
            ||
            ACTION_SHIPYARD_REMODEL_SHIP_FIGUREHEAD
            ||
            ACTION_SHIPYARD_REMODEL_SHIP_CANNON_TYPE
            ||
            ACTION_SHIPYARD_REMODEL_SHIP_SPACE
        )
        &&
        Scene_Shipyard.remodel_ship_id == (4294967295U)
    )
    {
        console_log("[E] No ship selected to remodel");
        Scene_Shipyard.error_code = ERROR_SHIPYARD_NO_SHIP_SELECTED;
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_SHIPYARD_BUY_USED:
        if (Scene_Shipyard.buying_prefab_ship_id == (4294967295U))
        {
            console_log("[E] No ship selected to buy");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_NO_SHIP_SELECTED;
            break;
        }
        if (Scene_Shipyard.ships_prefab[Scene_Shipyard.buying_prefab_ship_id] == (4294967295U))
        {
            console_log("[E] No ship in prefab slot");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_EMPTY_PREFAB_SLOT;
            break;
        }
        ship = &storage_ship.data[Scene_Shipyard.buying_prefab_ship_id];
        if (ship->price > get_player_gold(0))
        {
            console_log("[E] Not enough gold to buy ship");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_NOT_ENOUGH_GOLD;
            break;
        }

        DATA_CAPTAIN* captain = &storage_captain.data[0];
        DATA_FLEET* fleet = &storage_fleet.data[captain->general_of_fleet_id];
        if (fleet->total_ships >= (100 - 1))
        {
            console_log("[E] Fleet is full. Cannot add ship");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_FLEET_FULL;
            break;
        }
        else
        {
            subtract_player_gold(0, ship->price);
            u32 ship_id = Scene_Shipyard.ships_prefab[
                Scene_Shipyard.buying_prefab_ship_id
            ];
            DATA_SHIP* prefab_ship = &storage_ship.data[ship_id];
            u32 fleet_ship_id = initialize_fleet_ship(
                prefab_ship->name_id,
                ship_id
            );
            add_fleet_ship_to_fleet(
                fleet_ship_id,
                captain->general_of_fleet_id
            );
            Scene_Shipyard.ships_prefab[Scene_Shipyard.buying_prefab_ship_id] = (4294967295U);
            Scene_Shipyard.dialog_id = DIALOG_SHIPYARD_PREFAB_PURCHASE_SUCCESS;
            console_log("[I] Bought ship");
        }
        break;
    case ACTION_SHIPYARD_REMODEL_SHIP_MATERIAL:
        ship = get_data_ship(Scene_Shipyard.remodel_ship_id);
        Remodel_Ship.material_price = 0;
        if (Remodel_Ship.material_id != ship->material_id)
        {
            material = get_data_ship_material(Remodel_Ship.material_id);
            Remodel_Ship.material_price = Scene_Shipyard.remodel_material_price;
            Remodel_Ship.capacity = material->mod_capacity;
            Remodel_Ship.tacking = material->mod_tacking;
            Remodel_Ship.power = material->mod_power;
            Remodel_Ship.speed = material->mod_speed;
            Remodel_Ship.durability = material->mod_durability;
        }
        else
        {
            Remodel_Ship.capacity = 0;
            Remodel_Ship.tacking = 0;
            Remodel_Ship.power = 0;
            Remodel_Ship.speed = 0;
            Remodel_Ship.durability = 0;
        }
        Scene_Shipyard.error_code = (4294967295U);
        calculate_remodel_ship();
        break;
    case ACTION_SHIPYARD_REMODEL_SHIP_FIGUREHEAD:
        ship = get_data_ship(Scene_Shipyard.remodel_ship_id);
        Remodel_Ship.figurehead_price = 0;
        if (Remodel_Ship.figurehead_id != ship->figurehead_id)
        {
            Remodel_Ship.figurehead_price = Scene_Shipyard.remodel_figurehead_price;

        }
        Scene_Shipyard.error_code = (4294967295U);
        calculate_remodel_ship();
        break;
    case ACTION_SHIPYARD_REMODEL_SHIP_CANNON_TYPE:
        ship = get_data_ship(Scene_Shipyard.remodel_ship_id);
        Remodel_Ship.cannon_price = 0;
        if (Remodel_Ship.cannon_type_id != ship->cannon_type_id)
        {
            Remodel_Ship.cannon_type_id = Scene_Shipyard.remodel_cannon_price;

        }
        Scene_Shipyard.error_code = (4294967295U);
        calculate_remodel_ship();
        break;
    case ACTION_SHIPYARD_REMODEL_SHIP_SPACE:
        if (
            Remodel_Ship.crew_space == 0
            &&
            Remodel_Ship.cargo_space == 0
            &&
            Remodel_Ship.cannon_space == 0
        )
        {
            console_log("[E] No space adjustment to remodel with");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_NO_SPACE_REMODEL_VALUES;
            break;
        }
        ship = get_data_ship(Scene_Shipyard.remodel_ship_id);
        total_space = 0;
        total_space += Remodel_Ship.crew_space;
        total_space += Remodel_Ship.cargo_space;
        total_space += Remodel_Ship.cannon_space;
        if (
            Remodel_Ship.capacity > 0
            &&
            Remodel_Ship.capacity != (4294967295U)
            &&
            total_space > Remodel_Ship.capacity
        )
        {
            console_log("[E] Remodel space greater than remodel capacity");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_REMODEL_SPACE_GREATER_THAN_REMODEL_CAPACITY;
            break;
        }
        else if (total_space > ship->capacity)
        {
            console_log("[E] Remodel space greater than ship capacity");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_REMODEL_SPACE_GREATER_THAN_SHIP_CAPACITY;
            break;
        }
        else
        {
            console_log("[I] Remodel space should work out");
# 5915 "wasm_game.h"
            Scene_Shipyard.error_code = (4294967295U);
        }
        break;
    case ACTION_SHIPYARD_REMODEL_SHIP:
        if (Remodel_Ship.total_price > get_player_gold(0))
        {
            console_log("[E] Not enough gold to remodel ship");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_NOT_ENOUGH_GOLD;
            break;
        }
        total_space = 0;
        if (Remodel_Ship.crew_space > 0 && Remodel_Ship.crew_space != (4294967295U))
        {
            total_space += Remodel_Ship.crew_space;
        }
        if (Remodel_Ship.cannon_space > 0 && Remodel_Ship.cannon_space != (4294967295U))
        {
            total_space += Remodel_Ship.cannon_space;
        }
        if (Remodel_Ship.cargo_space > 0 && Remodel_Ship.cargo_space != (4294967295U))
        {
            total_space += Remodel_Ship.cargo_space;
        }
        _Bool remodel_has_capacity = (
            Remodel_Ship.capacity > 0 && Remodel_Ship.capacity != (4294967295U)
        );
        if (
            (
                remodel_has_capacity
                &&
                total_space > Remodel_Ship.capacity
            )
            ||
            (
                !remodel_has_capacity
                &&
                total_space > ship->capacity
            )
        )
        {
            console_log("[E] Not enough capacity for remodel");
            Scene_Shipyard.error_code = ERROR_SHIPYARD_REMODEL_SPACE_GREATER_THAN_SHIP_CAPACITY;
            break;
        }
        ship = get_data_ship(Scene_Shipyard.remodel_ship_id);
        if (
            Remodel_Ship.material_id != (4294967295U)
            &&
            ship->material_id != Remodel_Ship.material_id
        )
        {
            material = get_data_ship_material(ship->material_id);
            ship->power -= material->mod_power;
            ship->capacity -= material->mod_capacity;
            ship->tacking -= material->mod_tacking;
            ship->speed -= material->mod_speed;
            ship->durability -= material->mod_durability;

            ship->material_id = Remodel_Ship.material_id;
            material = get_data_ship_material(Remodel_Ship.material_id);
            ship->power += material->mod_power;
            ship->capacity += material->mod_capacity;
            ship->tacking += material->mod_tacking;
            ship->speed += material->mod_speed;
            ship->durability += material->mod_durability;
        }
        if (
            Remodel_Ship.crew_space != (4294967295U)
            &&
            ship->crew_space != Remodel_Ship.crew_space
        )
        {
            ship->crew_space = Remodel_Ship.crew_space;
        }
        if (
            Remodel_Ship.cannon_space != (4294967295U)
            &&
            ship->cannon_space != Remodel_Ship.cannon_space
        )
        {
            ship->cannon_space = Remodel_Ship.cannon_space;
        }
        if (
            Remodel_Ship.cargo_space != (4294967295U)
            &&
            ship->cargo_space != Remodel_Ship.cargo_space
        )
        {
            ship->cargo_space = Remodel_Ship.cargo_space;
        }
        if (
            Remodel_Ship.cannon_type_id != (4294967295U)
            &&
            ship->cannon_type_id != Remodel_Ship.cannon_type_id
        )
        {
            ship->cannon_type_id = Remodel_Ship.cannon_type_id;
        }
        if (
            Remodel_Ship.figurehead_id != (4294967295U)
            &&
            ship->figurehead_id != Remodel_Ship.figurehead_id
        )
        {
            ship->figurehead_id = Remodel_Ship.figurehead_id;
        }
        Scene_Shipyard.error_code = (4294967295U);
        subtract_player_gold(0, Remodel_Ship.total_price);
        clear_remodel_ship();
        Scene_Shipyard.dialog_id = DIALOG_SHIPYARD_REMODEL_SUCCESS;
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting shipyard scene");
        Scene_Shipyard.flag_initialized = 0;
        Scene_Shipyard.buying_prefab_ship_id = (4294967295U);
        Scene_Shipyard.remodel_space_price = (4294967295U);
        Scene_Shipyard.remodel_material_price = (4294967295U);
        Scene_Shipyard.remodel_cannon_price = (4294967295U);
        Scene_Shipyard.remodel_figurehead_price = (4294967295U);
        clear_remodel_ship();
        current.game_mode = Scene_Shipyard.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    }
# 6055 "wasm_game.h"
    return (4294967295U);
}





u32 scene_dockyard(u32 action)
{
    if (Scene_Dockyard.flag_initialized == 0)
    {
        console_log("[I] Setting up dockyard scene");
        current.scene = SCENE_DOCKYARD;
        Scene_Dockyard.id = SCENE_DOCKYARD;
        Scene_Dockyard.dialog_id = DIALOG_DOCKYARD_WELCOME;
        Scene_Dockyard.flag_initialized = 1;
        Scene_Dockyard.previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Dockyard.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_DOCKYARD_PURCHASE:
        if (get_player_gold(0) == 0)
        {
            console_log("[E] Player has zero gold");
            Scene_Dockyard.error_code = ERROR_DOCKYARD_NOT_ENOUGH_GOLD;
            break;
        }
        u32 goods_total = 0;
        goods_total += Scene_Dockyard.purchase_water;
        goods_total += Scene_Dockyard.purchase_food;
        goods_total += Scene_Dockyard.purchase_cannonballs;
        if (goods_total > get_ship_available_cargo_space(Scene_Dockyard.purchase_for_ship_id))
        {
            console_log("[E] Ship does not have enough cargo space for goods");
            Scene_Dockyard.error_code = ERROR_DOCKYARD_SHIP_NOT_ENOUGH_CARGO_SPACE;
            break;
        }
        u32 price_total = 0;
        price_total += Scene_Dockyard.purchase_water * Scene_Dockyard.price_water;
        price_total += Scene_Dockyard.purchase_food * Scene_Dockyard.price_food;
        price_total += Scene_Dockyard.purchase_cannonballs * Scene_Dockyard.price_cannonballs;
        if (price_total > get_player_gold(0))
        {
            console_log("[E] Not enough gold for this purchase");
            Scene_Dockyard.error_code = ERROR_DOCKYARD_NOT_ENOUGH_GOLD;
            break;
        }
        subtract_player_gold(0, price_total);
        add_food_to_ship(Scene_Dockyard.purchase_food, Scene_Dockyard.purchase_for_ship_id);
        add_water_to_ship(Scene_Dockyard.purchase_water, Scene_Dockyard.purchase_for_ship_id);
        add_cannonballs_to_ship(Scene_Dockyard.purchase_cannonballs, Scene_Dockyard.purchase_for_ship_id);
        Scene_Dockyard.dialog_id = DIALOG_DOCKYARD_SUPPLIES_LOADED;
        break;
    case ACTION_DOCKYARD_SET_SAIL:

        console_log("[I] Exiting dockyard scene");
        Scene_Dockyard.flag_initialized = 0;
        clear_scene_dockyard();
        current.game_mode = Scene_Dockyard.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        generate_world(WORLD_GLOBE_1);
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting dockyard scene");
        Scene_Dockyard.flag_initialized = 0;
        clear_scene_dockyard();
        current.game_mode = Scene_Dockyard.previous_game_mode;
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    }
    return (4294967295U);
}

u32 scene_innkeeper(u32 action)
{
# 6152 "wasm_game.h"
    return (4294967295U);
}

u32 scene_blacksmith(u32 action)
{
# 6169 "wasm_game.h"
    return (4294967295U);
}





u32 scene_goods_shop_get_total_good_cost()
{
    u32 total_cost = 0;
    u32 good_id = Scene_Goods_Shop.intended_good_id;
    u32 good_qty = Scene_Goods_Shop.intended_good_qty;
    get_inventory_items_by_inventory_id(Scene_Goods_Shop.inventory_id);
    for (u32 i = 0; i < 100; ++i)
    {
        if (inventory_items_by_inventory_id[i] == (4294967295U)) { continue; }
        u32 offset = inventory_items_by_inventory_id[i];
        if (storage_inventory_item.data[offset].type_reference == good_id)
        {
            u32 adjusted_price = storage_inventory_item.data[offset].adjusted_price;
            total_cost = adjusted_price * good_qty;
            return total_cost;
        }
    }
    return (4294967295U);
}
u32 scene_goods_shop_get_total_good_loaded_cargo_space()
{
    u32 total_loaded_cargo_space = 0;
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        if (Scene_Goods_Shop.loading_qty[i] == (4294967295U)) { continue; }
        total_loaded_cargo_space += Scene_Goods_Shop.loading_qty[i];
    }
    return total_loaded_cargo_space;
}
u32 scene_goods_shop_set_fleet_ship_good_qty(u32 fleet_ship_id, u32 good_qty)
{
    u32 available_spot = (4294967295U);
    _Bool already_set = 0;
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        u32 l_fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
        if (l_fleet_ship_id == (4294967295U) && available_spot == (4294967295U))
        {
            available_spot = i;
        }
        if (l_fleet_ship_id == fleet_ship_id)
        {
            DATA_SHIP* ship = get_ship_from_fleet_ship(fleet_ship_id);
            u32 available_space = ship->capacity - ship->total_cargo_goods;
            if (good_qty > available_space)
            {
                console_log("[E] Ship does not have the capacity");
                return ERROR_GOODS_SHOP_NOT_ENOUGH_SHIP_CAPACITY;
            }
            already_set = 1;
            Scene_Goods_Shop.loading_qty[i] = good_qty;
            break;
        }
    }
    if (!already_set)
    {
        Scene_Goods_Shop.loading_fleet_ships[available_spot] = fleet_ship_id;
        Scene_Goods_Shop.loading_qty[available_spot] = good_qty;
    }
    return (4294967295U);
}
u32 scene_goods_shop_increase_fleet_ship_good_qty(u32 fleet_ship_id)
{
    u32 current_total_qty = scene_goods_shop_get_total_good_loaded_cargo_space();
    u32 intended_total = current_total_qty;
    intended_total += 1;
    if (intended_total > Scene_Goods_Shop.intended_good_qty)
    {
        console_log("[E] Goods shop greater than intended");
        return ERROR_GOODS_SHOP_LOADING_QTY_GREATER_THAN_INTENDED;
    }
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        u32 l_fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
        u32 l_qty = Scene_Goods_Shop.loading_qty[i];
        if (l_fleet_ship_id == fleet_ship_id)
        {
            u32 new_qty = l_qty + 1;
            return scene_goods_shop_set_fleet_ship_good_qty(fleet_ship_id, new_qty);
        }
    }


    return scene_goods_shop_set_fleet_ship_good_qty(fleet_ship_id, 1);
}
u32 scene_goods_shop_decrease_fleet_ship_good_qty(u32 fleet_ship_id)
{
    u32 current_total_qty = scene_goods_shop_get_total_good_loaded_cargo_space();
    u32 intended_total = current_total_qty;
    if (intended_total > 0)
    {
        intended_total -= 1;
    }
    if (intended_total > Scene_Goods_Shop.intended_good_qty)
    {
        console_log("[E] Goods shop greater than intended");
        return ERROR_GOODS_SHOP_LOADING_QTY_GREATER_THAN_INTENDED;
    }
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        u32 l_fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
        u32 l_qty = Scene_Goods_Shop.loading_qty[i];
        if (l_fleet_ship_id == fleet_ship_id)
        {
            if (l_qty == 0)
            {
                console_log("[I] Intended purchase qt already at 0");
                return ERROR_GOODS_SHOP_INTENDED_QTY_AT_ZERO;
            }
            u32 new_qty = l_qty - 1;
            return scene_goods_shop_set_fleet_ship_good_qty(fleet_ship_id, new_qty);
        }
    }


    return scene_goods_shop_set_fleet_ship_good_qty(fleet_ship_id, 0);
}
void scene_goods_shop_clear_intended_good_id()
{
    Scene_Goods_Shop.intended_good_id = (4294967295U);
}
_Bool scene_goods_shop_is_in_inventory(u32 good_id)
{
    get_inventory_items_by_inventory_id(Scene_Goods_Shop.inventory_id);
    _Bool in_inventory = 0;
    for (u32 i = 0; i < 100; ++i)
    {
        if (inventory_items_by_inventory_id[i] == (4294967295U)) { continue; }
        if (storage_inventory_item.data[i].type_reference == good_id)
        {
            in_inventory = 1;
            break;
        }
    }
    return in_inventory;
}
u32 scene_goods_shop_set_intended_good_id(u32 id)
{

    if (!scene_goods_shop_is_in_inventory(id))
    {
        console_log("[E] Trying to add a good that's not in goods shop inventory");
        return ERROR_GOODS_SHOP_GOOD_NOT_IN_INVENTORY;
    }

    scene_goods_shop_clear_intended_good_id();
    Scene_Goods_Shop.intended_good_id = id;
    return (4294967295U);
}
void scene_goods_shop_clear_intended_good_qty()
{
    Scene_Goods_Shop.intended_good_qty = 0;
}
u32 scene_goods_shop_set_intended_good_qty(u32 qty)
{
    if (Scene_Goods_Shop.intended_good_id == (4294967295U))
    {
        console_log("[E] No good id in scene goods shop to put qty to");
        return ERROR_GOODS_SHOP_NO_GOOD_SET;
    }
    Scene_Goods_Shop.intended_good_qty = qty;
    return (4294967295U);
}
void scene_goods_shop_clear_fleet_ship_good_qty(u32 fleet_ship_id)
{
    u32 good_id = Scene_Goods_Shop.intended_good_id;
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        u32 l_fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
        if (l_fleet_ship_id == fleet_ship_id)
        {
            Scene_Goods_Shop.loading_qty[i] = 0;
            return;
        }
    }
    return;
}
void scene_goods_shop_clear_intended()
{
    Scene_Goods_Shop.intended_good_id = (4294967295U);
    Scene_Goods_Shop.intended_good_qty = (4294967295U);
    for (u32 i = 0; i < (100 * 20); ++i)
    {
        Scene_Goods_Shop.loading_fleet_ships[i] = (4294967295U);
        Scene_Goods_Shop.loading_qty[i] = 0;
    }
}
u32 scene_goods_shop(u32 action)
{
    if (Scene_Goods_Shop.flag_initialized == 0)
    {
        console_log("[I] Setting up goods shop scene");
        current.scene = SCENE_GOODS_SHOP;
        Scene_Goods_Shop.id = SCENE_GOODS_SHOP;
        Scene_Goods_Shop.dialog_id = DIALOG_GOODS_SHOP_WELCOME;
        Scene_Goods_Shop.flag_initialized = 1;
        Scene_Goods_Shop.previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Goods_Shop.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_GOODS_SHOP_BUY:
        console_log("[I] Gathering total gold cost");
        u32 total_cost = scene_goods_shop_get_total_good_cost();
        if (total_cost > get_player_gold(0))
        {
            console_log("[E] Player does not have enough gold for this");
            Scene_Goods_Shop.error_code = ERROR_GOODS_SHOP_NOT_ENOUGH_GOLD;
            break;
        }
        u32 fleet_id = storage_captain.data[0].general_of_fleet_id;
        u32 capacity = get_available_cargo_capacity_from_fleet(fleet_id);
        u32 total_cargo = scene_goods_shop_get_total_good_loaded_cargo_space();
        if (total_cargo > capacity)
        {
            console_log("[E] Not enough cargo capacity in fleet for goods");
            Scene_Goods_Shop.error_code = ERROR_GOODS_SHOP_NOT_ENOUGH_FLEET_CAPACITY;
            break;
        }
        _Bool have_space = 1;
        for (u32 i = 0; i < (100 * 20); ++i)
        {
            u32 fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
            DATA_FLEET_SHIP* fleet_ship = get_data_fleet_ship(fleet_ship_id);
            DATA_SHIP* ship = get_data_ship(fleet_ship->ship_id);
            u32 available_space = 0;
            available_space += ship->capacity;
            available_space -= ship->total_cargo_goods;
            u32 qty = Scene_Goods_Shop.loading_qty[i];
            if (qty > available_space)
            {
                have_space = 0;
                break;
            }
        }
        if (!have_space)
        {
            console_log("[E] Not enough space in a specific ship for cargo");
            Scene_Goods_Shop.error_code = ERROR_GOODS_SHOP_NOT_ENOUGH_SHIP_CAPACITY;
            break;
        }
        u32 total_added = 0;
        for (u32 i = 0; i < (100 * 20); ++i)
        {
            u32 fleet_ship_id = Scene_Goods_Shop.loading_fleet_ships[i];
            if (fleet_ship_id == (4294967295U))
            {
                continue;
            }
            DATA_FLEET_SHIP* fleet_ship = get_data_fleet_ship(fleet_ship_id);
            DATA_SHIP* ship = get_data_ship(fleet_ship->ship_id);
            u32 qty = Scene_Goods_Shop.loading_qty[i];
            if (qty > 0 && qty != (4294967295U))
            {
                total_added += qty;
                add_good_to_ship(Scene_Goods_Shop.intended_good_id, qty, ship->id);
            }
        }
        console_log("[I] Successfully loaded goods onto fleet ships");
        subtract_player_gold(0, total_cost);
        scene_goods_shop_clear_intended();
        Scene_Goods_Shop.dialog_id = DIALOG_GOODS_SHOP_PURCHASED_GOODS;
        Scene_Goods_Shop.error_code = (4294967295U);
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting goods shop scene");
        Scene_Goods_Shop.flag_initialized = 0;
        Scene_Goods_Shop.inventory_id = (4294967295U);
        current.game_mode = Scene_Goods_Shop.previous_game_mode;
        Scene_Goods_Shop.previous_game_mode = (4294967295U);
        clear_scene_goods_shop();
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    }
    return (4294967295U);
# 6475 "wasm_game.h"
    return (4294967295U);
}





u32 scene_guild(u32 action)
{
# 6494 "wasm_game.h"
    return (4294967295U);
}





u32 scene_cafe(u32 action)
{
# 6524 "wasm_game.h"
    return (4294967295U);
}





u32 scene_test(u32 action)
{
    if (Scene_Test.flag_initialized == 0)
    {
        console_log("[I] Setting up test scene");
        current.scene = SCENE_TEST;
        Scene_Test.id = SCENE_TEST;
        Scene_Test.dialog_id = DIALOG_TEST_ONE;
        Scene_Test.flag_initialized = 1;
        Scene_Test.previous_game_mode = current.game_mode;
        current.game_mode = GAME_MODE_IN_SCENE;
    }
    if (
        current.scene != (4294967295U)
        &&
        current.scene != Scene_Test.id
    )
    {
        console_log("[E] Already in scene and it's not this one");
        return (4294967295U);
    }
    switch (action)
    {
    case ACTION_CONFIRM:
        console_log("[I] Confirming test scene");
        if (Scene_Test.dialog_id == DIALOG_TEST_ONE)
        {
            Scene_Test.dialog_id = DIALOG_TEST_TWO;
            move_player_right(0);
            move_world_npc_right(2);
        }
        else if (Scene_Test.dialog_id == DIALOG_TEST_TWO)
        {
            Scene_Test.dialog_id = DIALOG_TEST_THREE;
            move_player_down(0);
        }
        else if (Scene_Test.dialog_id == DIALOG_TEST_THREE)
        {

            console_log("[E] Test scene complete");
            Scene_Test.dialog_id = (4294967295U);
            scene_test(ACTION_EXIT);
        }
        break;
    case ACTION_EXIT:
        console_log("[I] Exiting test scene");
        Scene_Test.flag_initialized = 0;
        current.game_mode = Scene_Test.previous_game_mode;
        Scene_Test.previous_game_mode = (4294967295U);
        current.scene = (4294967295U);
        current.updated_state = UPDATED_STATE_SCENE;
        break;
    }
    return (4294967295U);
}
